# A0112659A
###### simplyamazing\parser\Handler.java
``` java
package simplyamazing.parser;

import simplyamazing.data.Task;

public class Handler {
	private Task task;
	private String commandType;
	private String index;
	private String keyWord;
	private String feedback;
	private boolean hasError;
	private boolean hasEndDate;
   
	private static final String INDEX_DEFAULT_VALUE = null;
	private static final String EMPTY_STRING = "";
	private static final boolean HASERROR_DEFAULT_VALUE = false;
	private static final boolean HASENDDATE_DEFAULT_VALUE = false;
	private static final Task TASK_DEFAULT_VALUE = null;

	public Handler() {
		task = new Task();
		this.commandType = EMPTY_STRING;
		this.index = INDEX_DEFAULT_VALUE;
		this.keyWord = EMPTY_STRING;
		this.feedback = EMPTY_STRING;
		this.hasError = HASERROR_DEFAULT_VALUE;
		this.hasEndDate = HASENDDATE_DEFAULT_VALUE;
	}

	public void setTask(Task task) {
		this.task = task;
	}

	public void setCommandType(String commandType) {
		this.commandType = commandType;
	}

	public void setIndex(String index) {
		this.index = index;
	}

	public void setKeyWord(String keyWord) {
		this.keyWord = keyWord;
	}

	public void setFeedBack(String feedback) {
		this.feedback = feedback;
	}

	public void setHasError(boolean hasError) {
		this.hasError = hasError;
	}
	
	public void setHasEndDate(boolean hasEndDate) {
		this.hasEndDate = hasEndDate;
	}

	public Task getTask() {
		return task;
	}

	public String getCommandType() {
		return commandType;
	}

	public String getIndex() {
		return index;
	}

	public String getKeyWord() {
		return keyWord;
	}

	public String getFeedBack() {
		return feedback;
	}

	public boolean getHasError() {
		return hasError;
	}
	public boolean getHasEndDate() {
		return hasEndDate;
	}

}
```
###### simplyamazing\parser\Parser.java
``` java
package simplyamazing.parser;

import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;

/*enum CommandType {
	ADD ("add", "+"),
	DELETE ("delete", "-", "del", "remove", "cancel"),
	VIEW ("view","display", "show", "list"),
	EDIT ("edit", "change", "update"),
	SEARCH ("search", "find"),
	UNDO ("undo"),
	DONE ("mark", "complete", "finish", "done"),
	HELP ("help", "?"),
	LOCATION("location", "path", "address"),
	EXIT("exit","quit","logout");
}*/
public class Parser {
	private static Logger logger = Logger.getLogger("Parser");
	
	
	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_ADD_ALT = "+";
	private static final String COMMAND_DELETE = "delete";
	private static final String COMMAND_DELETE_ALT = "del";
	private static final String COMMAND_DELETE_ALT_2 = "-";
	private static final String COMMAND_DELETE_ALT_3 = "remove";
	private static final String COMMAND_DELETE_ALT_4 = "cancel";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_EDIT_ALT = "change";
	private static final String COMMAND_EDIT_ALT_2 = "update";
	private static final String COMMAND_VIEW = "view";
	private static final String COMMAND_VIEW_ALT ="display";
	private static final String COMMAND_VIEW_ALT_2 = "show";
	private static final String COMMAND_VIEW_ALT_3 = "list";
	private static final String COMMAND_SEARCH = "search";
	private static final String COMMAND_SEARCH_ALT = "find";
	private static final String COMMAND_SEARCH_ALT_2 = "get";
	private static final String COMMAND_HELP = "help";
	private static final String COMMAND_HELP_ALT = "?";
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_SET_LOCATION = "location";
	private static final String COMMAND_SET_LOCATION_ALT = "path";
	private static final String COMMAND_SET_LOCATION_ALT_2 = "address";
	private static final String COMMAND_MARK_AS_DONE = "done";
	private static final String COMMAND_MARK_AS_DONE_ALT = "mark";
	private static final String COMMAND_MARK_AS_DONE_ALT_2 = "finish";
	private static final String COMMAND_MARK_AS_DONE_ALT_3 = "complete";
	private static final String COMMAND_EXIT = "exit";
	private static final String COMMAND_EXIT_ALT = "quit";
	private static final String COMMAND_EXIT_ALT_2 = "logout";
	private static final String COMMAND_INVALID = "Error: Invalid command entered. Please enter \"help\" to view command format";
	
	private static final String STRING_EMPTY = "";
	private static final String CHARACTER_SPACE = "\\s";
	
	private String firstWord = STRING_EMPTY;
	private String taskIndex = STRING_EMPTY;
	private String taskInfoWithoutIndex= STRING_EMPTY;
	private String removeFirstWord = STRING_EMPTY;

	public Parser() {
		
	}

	public static String removeFirstWord(String userCommand) {
		final String replace = Pattern.quote(getFirstWord(userCommand));
		return userCommand.replaceFirst(replace, STRING_EMPTY).trim();
	}
	
	public static String getFirstWord(String userCommand) {
		return userCommand.trim().split(CHARACTER_SPACE)[0];
	}	
    
	private Handler parserAddCommand(Handler handler, String taskInfo) throws Exception {
	    ParserAdd parserAdd = new ParserAdd();
	    return parserAdd.parseAddCommand(handler,taskInfo);
	    
	}	
	private Handler parserEditCommand(Handler handler, String taskInfo) throws Exception {
		ParserEdit parserEdit = new ParserEdit();
		//assert parserEdit !=  null;					//assert
		taskIndex =  getFirstWord(taskInfo);
		taskInfoWithoutIndex = removeFirstWord(taskInfo);
		
		return parserEdit.parseEditCommand(handler, taskIndex, taskInfoWithoutIndex);
	}
	private Handler parserDeleteCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserDelete parserDelete = new ParserDelete();
		//assert parserDelete != null;					// assert
		return parserDelete.parserDeleteCommand(handler,removeFirstWord);
	}
	private Handler parserViewCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserView parserView = new ParserView();
		//assert parserView != null;
		return parserView.parserViewCommand(handler,removeFirstWord);
	}
	private Handler parserLocationCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserLocation parseLocation = new ParserLocation();
		//assert parseLocation != null;
		return parseLocation.parseLocationCmd(handler,removeFirstWord);
	}
	private Handler parserDoneCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserDone parserDone = new ParserDone();
		//assert parserDone != null;
		return parserDone.parserDoneCommand(handler,removeFirstWord);
	}
	private Handler parserHelpCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserHelp parserHelp = new ParserHelp();
		return parserHelp.parserHelpCommand(handler,removeFirstWord);
	}
	
	private Handler parserSearchCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserSearch parserSearch = new ParserSearch();
		return parserSearch.parserSearchCommand(handler,removeFirstWord);
	}
	
	
	private Handler parserFirstWord(Handler handler, String firstWord,String removeFirstWord) throws Exception{
		switch(firstWord.toLowerCase()){
		 case COMMAND_ADD: case COMMAND_ADD_ALT:
			 handler.setCommandType(COMMAND_ADD);
			 handler = parserAddCommand(handler, removeFirstWord);
			 break;
		 case COMMAND_DELETE: case COMMAND_DELETE_ALT : case COMMAND_DELETE_ALT_2: case COMMAND_DELETE_ALT_3: case COMMAND_DELETE_ALT_4:
			 handler.setCommandType(COMMAND_DELETE);
			 handler = parserDeleteCommand(handler, removeFirstWord);
			 break;
		 case COMMAND_EDIT: case COMMAND_EDIT_ALT: case COMMAND_EDIT_ALT_2:
			 handler.setCommandType(COMMAND_EDIT);
			 handler = parserEditCommand(handler, removeFirstWord);
			 break;
		 case COMMAND_VIEW: case COMMAND_VIEW_ALT: case COMMAND_VIEW_ALT_2: case COMMAND_VIEW_ALT_3:
			 handler.setCommandType(COMMAND_VIEW);
			 handler = parserViewCommand(handler, removeFirstWord);
			 break;
		 case COMMAND_SEARCH: case COMMAND_SEARCH_ALT: case COMMAND_SEARCH_ALT_2:
			 handler.setCommandType(COMMAND_SEARCH);
			 handler = parserSearchCommand(handler,removeFirstWord);
			 break;
		 case COMMAND_HELP: case COMMAND_HELP_ALT:
			 handler.setCommandType(COMMAND_HELP);
			 handler = parserHelpCommand(handler,removeFirstWord);
			 break;
		 case COMMAND_UNDO:
			 handler.setCommandType(COMMAND_UNDO);
			 break;
		 case COMMAND_SET_LOCATION: case COMMAND_SET_LOCATION_ALT: case COMMAND_SET_LOCATION_ALT_2: 
			 handler.setCommandType(COMMAND_SET_LOCATION);
			 handler = parserLocationCommand(handler, removeFirstWord);
			 break;
		 case COMMAND_MARK_AS_DONE: case COMMAND_MARK_AS_DONE_ALT: case COMMAND_MARK_AS_DONE_ALT_2: case COMMAND_MARK_AS_DONE_ALT_3:
			 handler.setCommandType(COMMAND_MARK_AS_DONE);
			 handler = parserDoneCommand(handler, removeFirstWord);
		     break;
		 case COMMAND_EXIT: case COMMAND_EXIT_ALT: case COMMAND_EXIT_ALT_2:
			 handler.setCommandType(COMMAND_EXIT);
		     break;
		 default:
			 logger.log(Level.WARNING, "invalid command");
			 handler.setHasError(true);
			 handler.setFeedBack(COMMAND_INVALID);
		}
		return handler;
	}
	
	public Handler getHandler(String input) throws Exception{
		//logger.log(Level.INFO, "before starting on getHandler");
		Handler handler = new Handler();
		firstWord = getFirstWord(input);
		removeFirstWord = removeFirstWord(input);
		handler = parserFirstWord(handler,firstWord,removeFirstWord);
		//logger.log(Level.INFO, "about to return to storage");
		return handler;
	}
}
```
###### simplyamazing\parser\ParserAdd.java
``` java
package simplyamazing.parser;
import com.joestelmach.natty.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ParserAdd {
	private static final String STRING_TIME_FORMATTER = ":";
	private static final String KEYWORD_SCHEDULE_TO = "to";
	private static final String KEYWORD_SCHEDULE_FROM = "from";
	private static final String KEYWORD_DEADLINE = "by";
	private static final String EMPTY_STRING = "";
	private static final String TIME_FORMAT = "HH:mm dd MMM yyyy";
	private static final String ERROR_MESSAGE_FIELDS_NOT_CORRECT = "Error: Please ensure the fields are correct";
	private static final String ERROR_MESSAGE_TIME_FORMAT_INVALID ="Error: Please ensure the time format is valid. Please use the \"help\"command to view the format";
	private static final String ERROR_MESSAGE_START_AFTER_END ="Error: Start date and time cannot be after the End date and time";
	private static final String ERROR_MESSAGE_DATE_BEFORE_CURRENT ="Error: Time provided must be after the current time";
	private static String description = "";
	private static String startTime = "";
	private static String endTime = "";
	private static Date startingDate = null;
	private static Date endingDate = null;
	private static int startTimeIndex;
	private static int endTimeIndex;
	private static int year;
	private boolean checkValue = false, isEvent = false, isDeadline = false, isFloatingTask = false;

	private static Logger logger = Logger.getLogger("ParserAdd");

	public Handler parseAddCommand(Handler handler, String taskInfo) throws Exception {
		//logger.log(Level.INFO, "going to start processing cmd");
		checkValue = isAddingValid(handler,taskInfo);
		if (checkValue) {
			if (isEvent) { // For events
				handler.getTask().setDescription(description);
				handler.getTask().setStartTime(startingDate);
				handler.getTask().setEndTime(endingDate);
			} 
			if (isDeadline) { // For deadlines
				handler.getTask().setDescription(description);
				handler.getTask().setEndTime(endingDate);
			} 
			if (isFloatingTask) {
				handler.getTask().setDescription(taskInfo.trim());
			}
		} else {
		}
		//logger.log(Level.INFO, "returning to parser");
		return handler;
	}

	public boolean isAddingValid(Handler handler,String taskInfo) throws Exception {
		com.joestelmach.natty.Parser dateParser = new com.joestelmach.natty.Parser();

		if (taskInfo.contains(KEYWORD_SCHEDULE_FROM) && taskInfo.contains(KEYWORD_SCHEDULE_TO)) {
			System.out.println("Found "+KEYWORD_SCHEDULE_FROM+", "+KEYWORD_SCHEDULE_TO);
			startTimeIndex = taskInfo.lastIndexOf(KEYWORD_SCHEDULE_FROM);
			
			String taskInfoFiltered = taskInfo;
			endTimeIndex = taskInfoFiltered.lastIndexOf(KEYWORD_SCHEDULE_TO);
			
			while(!taskInfoFiltered.substring((endTimeIndex+2),(endTimeIndex+3)).trim().equals(EMPTY_STRING)) {
				taskInfoFiltered = taskInfoFiltered.substring(0, endTimeIndex) ;
				endTimeIndex = taskInfoFiltered.lastIndexOf(KEYWORD_SCHEDULE_TO);
			}
			
			System.out.println(startTimeIndex);
			System.out.println(endTimeIndex);
			if (startTimeIndex < endTimeIndex) {

				startTime = Parser.removeFirstWord(taskInfo.substring(startTimeIndex, endTimeIndex).trim());
				endTime = Parser.removeFirstWord(taskInfo.substring(endTimeIndex).trim());
				description = taskInfo.substring(0, startTimeIndex);
				System.out.println("StartTime:"+ startTime);
				System.out.println("EndTime:" + endTime);

				if (description.equals(EMPTY_STRING) || startTime.equals(EMPTY_STRING) || endTime.equals(EMPTY_STRING)) {
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_FIELDS_NOT_CORRECT);
					return false;
				} else if (!startTime.equals(EMPTY_STRING) && !endTime.equals(EMPTY_STRING)) {
					boolean isStartFormatCorrect = followStandardFormat(startTime);
					boolean isEndFormatCorrect = followStandardFormat(endTime);

					SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT,Locale.ENGLISH);
					sdf.setLenient(false);
					if(isStartFormatCorrect == false && isEndFormatCorrect == false){
						System.out.println("Endtime and Startime both use Natty format");					
						List<DateGroup> dateGroup1 = dateParser.parse(startTime);
						List<DateGroup> dateGroup2 = dateParser.parse(endTime);
						
						if(dateGroup1.isEmpty()||dateGroup2.isEmpty() ){
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}						
						List<Date> date1 = dateGroup1.get(0).getDates();
						startingDate = date1.get(0);
						System.out.println(startingDate);
						List<Date> date2 = dateGroup2.get(0).getDates();
						endingDate = date2.get(0);
						System.out.println(endingDate);
					}else if (isStartFormatCorrect == true && isEndFormatCorrect == true){
						System.out.println("Endtime and Startime both use our format");
						try{
							startingDate = (Date)sdf.parse(startTime);
							endingDate = (Date)sdf.parse(endTime);
						}catch (ParseException e) {
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}
					}else if (isStartFormatCorrect == true && isEndFormatCorrect == false){
						System.out.println("Startime use our format, Endtime use Natty format");
						try{
							startingDate = (Date)sdf.parse(startTime);
						}catch (ParseException e) {
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}
						List<DateGroup> dateGroup2 = dateParser.parse(endTime);

						if(dateGroup2.isEmpty()){
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}						
						List<Date> date2 = dateGroup2.get(0).getDates();
						endingDate = date2.get(0);
					}else if(isStartFormatCorrect == false && isEndFormatCorrect == true){
						System.out.println("Startime use Natty format, Endtime use our format");
						try{
							endingDate = (Date)sdf.parse(endTime);
						}catch (ParseException e) {
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}
						List<DateGroup> dateGroup2 = dateParser.parse(startTime);

						if(dateGroup2.isEmpty()){
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}						
						List<Date> date2 = dateGroup2.get(0).getDates();
						startingDate = date2.get(0);
					}



					/*
					List<DateGroup> dateGroup1 = dateParser.parse(startTime);
					List<DateGroup> dateGroup2 = dateParser.parse(endTime);

					if(dateGroup1.isEmpty()||dateGroup2.isEmpty()){
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
						return false;
					}
						SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT,Locale.ENGLISH);
						sdf.setLenient(true);
						/*Date startingDate = null;
					startingDate = (Date)sdf.parse(startTime);
					Date endingDate = null;
					endingDate = (Date)sdf.parse(endTime); //
						List<Date> date1 = dateGroup1.get(0).getDates();
						startingDate = date1.get(0);
						List<Date> date2 = dateGroup2.get(0).getDates();
						endingDate = date2.get(0);
					 */
					Date todayDate = null;
					todayDate = (Date)sdf.parse(sdf.format(new Date()));

					if (startingDate.after(endingDate)||startingDate.compareTo(endingDate) == 0) {
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_START_AFTER_END);
						return false;
					} else if (!startingDate.after(todayDate) || !endingDate.after(todayDate)) {
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_DATE_BEFORE_CURRENT);
						return false;
					} else {
						isEvent = true;
						return true;
					}
				}
			} else if(taskInfo.contains(KEYWORD_DEADLINE)){
				endTimeIndex = taskInfo.lastIndexOf(KEYWORD_DEADLINE);
				startTimeIndex = taskInfo.lastIndexOf(KEYWORD_SCHEDULE_FROM);
				System.out.println(startTimeIndex);
				System.out.println(endTimeIndex);
				if(endTimeIndex < startTimeIndex){
					System.out.println("This is not an event");
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_FIELDS_NOT_CORRECT);
					return false;
				}
			}
		}
		if (taskInfo.contains(KEYWORD_DEADLINE)) {
			System.out.println("Found "+KEYWORD_DEADLINE+", "+STRING_TIME_FORMATTER);
			System.out.println("This is a deadline task");
			endTimeIndex = taskInfo.lastIndexOf(KEYWORD_DEADLINE);
			endTime = Parser.removeFirstWord(taskInfo.substring(endTimeIndex));
			description = taskInfo.substring(0, endTimeIndex).trim();

			if (description.equals(EMPTY_STRING) || endTime.equals(EMPTY_STRING)) {
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_FIELDS_NOT_CORRECT);
				return false;
			} else if (!endTime.equals(EMPTY_STRING)) {
				boolean isEndFormatCorrect = followStandardFormat(endTime);

				SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT,Locale.ENGLISH);
				sdf.setLenient(false);

				if(isEndFormatCorrect == false){
                    System.out.println("Endtime use Natty");
					List<DateGroup> dateGroup3 = dateParser.parse(endTime);

					if(dateGroup3.isEmpty()){
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
						return false;
					}
					List<Date> date3 = dateGroup3.get(0).getDates();
					endingDate = date3.get(0);
				}else if (isEndFormatCorrect == true){
					System.out.println("Endtime use our format");
					try{
						endingDate = (Date)sdf.parse(endTime);
					}catch (ParseException e) {
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
						return false;
					}
				}

				Date todayDate = null;
				todayDate = (Date)sdf.parse(sdf.format(new Date()));

				/*
				try {
					SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT, Locale.ENGLISH);
					sdf.setLenient(true);
					//Date endingDate = null;
					endingDate = (Date)sdf.parse(endTime);//
					Date todayDate = null;
					todayDate = (Date)sdf.parse(sdf.format(new Date()));
					List<Date> date3 = dateGroup3.get(0).getDates();
					endingDate = date3.get(0);
				 */

				if (!endingDate.after(todayDate)) {
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_DATE_BEFORE_CURRENT);
					return false;
				} 			
			}
			isDeadline = true;
			return true;
		} else {
			if(taskInfo.contains(STRING_TIME_FORMATTER)) {
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_FIELDS_NOT_CORRECT);
				return false;
			} else {
				if (taskInfo.trim().equals(EMPTY_STRING)) {
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_FIELDS_NOT_CORRECT);
					return false;
				}
			}
		}
		isFloatingTask = true;
		return true;
	}



	public boolean followStandardFormat(String dateTimeString){
		String[] dateTimeArr = dateTimeString.trim().split(" ");

		if (dateTimeArr.length != 4) {
			return false;
		} else {
			// dateTimeArr len should be 4 here, now check end time
			String time = dateTimeArr[0];
			if ((time.contains(":") && (time.length() == 4 || time.length()== 5))) {

				int date;
				try{
					date = Integer.parseInt(dateTimeArr[1], 10);
				} catch (NumberFormatException e){
					return false;
				}	
				// reach here means that it time given follows format and date given is an int

				if ((date > 31) || (date < 0)) {	//date given not valid
					return false;
				} else {

					String givenMonth = dateTimeArr[2].toLowerCase();
					if ( !(givenMonth.contains("jan") || givenMonth.contains("feb") || givenMonth.contains("mar") ||givenMonth.contains("apr")
							|| givenMonth.contains("may") || givenMonth.contains("jun") || givenMonth.contains("jul") || givenMonth.contains("aug")
							|| givenMonth.contains("sep") || givenMonth.contains("oct") || givenMonth.contains("nov") || givenMonth.contains("dec"))) {
						// month given follows the required format
						return false;
					} else {
						try {
							year = Integer.parseInt(dateTimeArr[3], 10);
						} catch (NumberFormatException e) {
							return false; 	// year not in int format
						}
					}
				}
			} else {
				return false;
			}
			return true;
		}
	}
}
```
###### simplyamazing\parser\ParserDelete.java
``` java
package simplyamazing.parser;

public class ParserDelete {
	private final String COMMAND_INVALID = "Error: Index provided is not an Integer.";
	
	public Handler parserDeleteCommand(Handler handler, String taskInfo) throws Exception{
		if (isInteger(taskInfo)){
			handler.setIndex(taskInfo);
		}else{
			handler.setHasError(true);
			handler.setFeedBack(COMMAND_INVALID);
		}
		return handler;
	}
	public static boolean isInteger(String taskInfo) {
	    try { 
	        Integer.parseInt(taskInfo); 
	    } catch(NumberFormatException e) { 
	        return false; 
	    }
	    // only got here if we didn't return false
	    return true;
	}
}
```
###### simplyamazing\parser\ParserDone.java
``` java
package simplyamazing.parser;

public class ParserDone {
	private final String COMMAND_INVALID = "Error: Index provided is not an Integer.";

	public Handler parserDoneCommand(Handler handler, String taskInfo) throws Exception {
		if (isInteger(taskInfo)) {
			handler.setIndex(taskInfo);
		} else {
			handler.setHasError(true);
			handler.setFeedBack(COMMAND_INVALID);
		}
		return handler;
	}

	private boolean isInteger(String taskInfo) {
		try {
			Integer.parseInt(taskInfo);
		} catch (NumberFormatException e) {
			return false;
		}
		// only got here if we didn't return false
		return true;
	}
}
```
###### simplyamazing\parser\ParserEdit.java
``` java
package simplyamazing.parser;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;

import com.joestelmach.natty.*;

import simplyamazing.data.Task;

public class ParserEdit {
	private static final String ERROR_MESSAGE_INVALID_INDEX = "Error: Index provided is not an Integer.";
	private static final String ERROR_MESSAGE_INVALID_FIELD = "Error: Please input a valid field. Use the \"help edit\" command to see all the valid fields";
	private static final String ERROR_MESSAGE_START_AFTER_END ="Error: Start date and time cannot be after the End date and time";
	private static final String ERROR_MESSAGE_DATE_BEFORE_CURRENT ="Error: Time provided must be after the current time";
	private static final String ERROR_MESSAGE_PRIORITY_LEVEL = "Error: Priority level can be only high, medium, low or none.";
	private static final String ERROR_MESSAGE_TIME_FORMAT_INVALID ="Error: Please ensure the time format is valid. Please use the \"help\"command to view the format";
	private static final String TIME_FORMAT = "HH:mm dd MMM yyyy";
	private static Date startingDate = null;
	private static Date endingDate = null;
	public Handler parseEditCommand(Handler handler, String taskIndex, String taskInfoWithoutIndex) throws Exception {
		com.joestelmach.natty.Parser dateParser = new com.joestelmach.natty.Parser();
		if (isInteger(taskIndex)) {
			handler.setIndex(taskIndex);
		} else {
			handler.setHasError(true);
			handler.setFeedBack(ERROR_MESSAGE_INVALID_INDEX);
			return handler;
		}
		String[] fieldValuePairs = taskInfoWithoutIndex.split(",");
		
			for (int i = 0; i < fieldValuePairs.length; i++) {
				String field = Parser.getFirstWord(fieldValuePairs[i]);
				String value = Parser.removeFirstWord(fieldValuePairs[i]);

				switch (field.toLowerCase()) {
				case "description" :
					handler.getTask().setDescription(value);
					break;
				case "start" :
					List<DateGroup> dateGroup1 = dateParser.parse(value);
					if(dateGroup1.isEmpty()){
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
						break;
					}
					SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT,Locale.ENGLISH);
					sdf.setLenient(true);
					List<Date> date1 = dateGroup1.get(0).getDates();
					startingDate = date1.get(0);
					handler.getTask().setStartTime(startingDate);
					break;
				case "end" :
					List<DateGroup> dateGroup2 = dateParser.parse(value);
					if(dateGroup2.isEmpty()){
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
						break;
					}
					SimpleDateFormat sdf2 = new SimpleDateFormat(TIME_FORMAT,Locale.ENGLISH);
					sdf2.setLenient(true);
					List<Date> date2 = dateGroup2.get(0).getDates();
					endingDate = date2.get(0);
					handler.getTask().setEndTime(endingDate);
					break;
				case "priority" :
					try{
					handler.getTask().setPriority(value);
					}catch(Exception e){
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_PRIORITY_LEVEL);
					}
					break;
				default :
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_INVALID_FIELD);
				}
			}
			
			     startingDate = handler.getTask().getStartTime();
			     endingDate = handler.getTask().getEndTime();
			Date todayDate = new Date();

			if (startingDate.compareTo(Task.DEFAULT_DATE_VALUE)!=0 && endingDate.compareTo(Task.DEFAULT_DATE_VALUE)!=0) { // if both start time and end time are modified
				if (!startingDate.after(todayDate) || !endingDate.after(todayDate)){ 
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_DATE_BEFORE_CURRENT);
				}else if (!endingDate.after(startingDate)){
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_START_AFTER_END);
				}
			} else if (startingDate.compareTo(Task.DEFAULT_DATE_VALUE)!=0) { // start time is modified
				if (!startingDate.after(todayDate)) {
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_DATE_BEFORE_CURRENT);
				}
			} else if (endingDate.compareTo(Task.DEFAULT_DATE_VALUE)!=0) { // end time is modified
				if (!endingDate.after(todayDate)) {
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_DATE_BEFORE_CURRENT);
				}
			}  
			/*if (startingDate.compareTo(Task.DEFAULT_DATE_VALUE)!=0 && startingDate.after(endingDate)) {
				handler.setHasError(true);
				handler.setFeedBack(MESSAGE_INVALID_FORMAT);
			} else if ((startingDate.compareTo(Task.DEFAULT_DATE_VALUE)!=0 && startingDate.before(todayDate)) || (endingDate.compareTo(Task.DEFAULT_DATE_VALUE)!=0 && endingDate.before(todayDate))) {
				handler.setHasError(true);
				handler.setFeedBack(MESSAGE_INVALID_FORMAT);
			}*/
		return handler;
	}

	public static boolean isInteger(String taskInfo) {
		try {
			Integer.parseInt(taskInfo);
		} catch (NumberFormatException e) {
			return false;
		}
		// only got here if we didn't return false
		return true;
	}
}
```
###### simplyamazing\parser\ParserHelp.java
``` java
package simplyamazing.parser;

public class ParserHelp {
	private final String STRING_ADD = "add";
	private final String STRING_DELETE = "delete";
	private final String STRING_VIEW = "view";
	private final String STRING_UNDO = "undo";
	private final String STRING_DONE = "done";
	private final String STRING_EDIT = "edit";
	private final String STRING_SEARCH = "search";
	private final String STRING_LOCATION = "location";
	private final String STRING_EXIT = "exit";
	private final String STRING_EMPTY="";
	
	private final String COMMAND_INVALID = "Error: Please input a valid keyword. Use the \"help\" command to view all valid keywords";

	public Handler parserHelpCommand(Handler handler, String taskInfo) throws Exception {
		switch (taskInfo.toLowerCase()) {
		case STRING_ADD:
			handler.setKeyWord(STRING_ADD);
			break;
		case STRING_DELETE:
			handler.setKeyWord(STRING_DELETE);
			break;
		case STRING_VIEW:
			handler.setKeyWord(STRING_VIEW);
			break;
		case STRING_UNDO:
			handler.setKeyWord(STRING_UNDO);
			break;
		case STRING_DONE:
			handler.setKeyWord(STRING_DONE);
			break;
		case STRING_EDIT:
			handler.setKeyWord(STRING_EDIT);
			break;
		case STRING_LOCATION :
			handler.setKeyWord(STRING_LOCATION);
			break;
		case STRING_EXIT:
			handler.setKeyWord(STRING_EXIT);
			break;
		case STRING_SEARCH:
			handler.setKeyWord(STRING_SEARCH);
			break;
		case STRING_EMPTY:
			handler.setKeyWord(STRING_EMPTY);
			break;
		default:
			handler.setHasError(true);
			handler.setFeedBack(COMMAND_INVALID);
		}
		return handler;
	}
}
```
###### simplyamazing\parser\ParserLocation.java
``` java
package simplyamazing.parser;

public class ParserLocation {
	private static final String STRING_EMPTY = "";
	private static final String INVALID_LOCATION = "Error: Location provided is invalid";

	public Handler parseLocationCmd(Handler handler, String taskInfo) throws Exception {
		
		if (taskInfo.equals(STRING_EMPTY)) {
			handler.setHasError(true);
			handler.setFeedBack(INVALID_LOCATION);
		} else {
			handler.setKeyWord(taskInfo);
		}
		return handler;
	}
}
```
###### simplyamazing\parser\ParserSearch.java
``` java
package simplyamazing.parser;

import com.joestelmach.natty.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;

import com.joestelmach.natty.DateGroup;

public class ParserSearch {
	private static final String TIME_FORMAT = "HH:mm dd MMM yyyy";
	private static final String ERROR_MESSAGE_TIME_FORMAT_INVALID ="Error: Please ensure the time format is valid. Please use the \"help\"command to view the format";
	private static Date endingDate = null;
	private static int year;
	private boolean checkValue;

	public Handler parserSearchCommand(Handler handler, String taskInfo) throws Exception {
		checkValue = isSearchingDate(handler,taskInfo);
		if (checkValue == true){
			handler.setKeyWord(taskInfo);
		}
		return handler;
	}
	public boolean isSearchingDate(Handler handler,String taskInfo) throws Exception {
		com.joestelmach.natty.Parser dateParser = new com.joestelmach.natty.Parser();
		boolean isEndFormatCorrect = followStandardFormat(taskInfo);
		SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT,Locale.ENGLISH);
		sdf.setLenient(false);

		if (isEndFormatCorrect == true){
			try{
				endingDate = (Date)sdf.parse(taskInfo);
				handler.setHasEndDate(true);
				handler.getTask().setEndTime(endingDate);
			}catch (ParseException e) {
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
				return false;
			}
		}else{
			List<DateGroup> dateGroup2 = dateParser.parse(taskInfo);

			if(dateGroup2.isEmpty()){
				return true;
			}						
			List<Date> date2 = dateGroup2.get(0).getDates();
			endingDate = date2.get(0);
			handler.setHasEndDate(true);
			handler.getTask().setEndTime(endingDate);
		}
		return false;

	}
	public boolean followStandardFormat(String dateTimeString){
		String[] dateTimeArr = dateTimeString.trim().split(" ");

		if (dateTimeArr.length != 4) {
			return false;
		} else {
			// dateTimeArr len should be 4 here, now check end time
			String time = dateTimeArr[0];
			if ((time.contains(":") && (time.length() == 4 || time.length()== 5))) {

				int date;
				try{
					date = Integer.parseInt(dateTimeArr[1], 10);
				} catch (NumberFormatException e){
					return false;
				}	
				// reach here means that it time given follows format and date given is an int

				if ((date > 31) || (date < 0)) {	//date given not valid
					return false;
				} else {

					String givenMonth = dateTimeArr[2].toLowerCase();
					if ( !(givenMonth.contains("jan") || givenMonth.contains("feb") || givenMonth.contains("mar") ||givenMonth.contains("apr")
							|| givenMonth.contains("may") || givenMonth.contains("jun") || givenMonth.contains("jul") || givenMonth.contains("aug")
							|| givenMonth.contains("sep") || givenMonth.contains("oct") || givenMonth.contains("nov") || givenMonth.contains("dec"))) {
						// month given follows the required format
						return false;
					} else {
						try {
							year = Integer.parseInt(dateTimeArr[3], 10);
						} catch (NumberFormatException e) {
							return false; 	// year not in int format
						}
					}
				}
			} else {
				return false;
			}
			return true;
		}
	}
}
```
###### simplyamazing\parser\ParserView.java
``` java
package simplyamazing.parser;

public class ParserView {
	private final String STRING_EVENT = "events";
	private final String STRING_DEADLINE = "deadlines";
	private final String STRING_EMPTY = "";
	private final String STRING_DONE = "done";
	private final String STRING_TASKS = "tasks";
	private final String STRING_OVERDUE = "overdue";
	private final String COMMAND_INVALID = "Error: Please input a valid keyword. Use the \"help view\" command to see all the valid keywords";

	public Handler parserViewCommand(Handler handler, String taskInfo) throws Exception {
		switch (taskInfo.toLowerCase()) {
		case STRING_EVENT:
			handler.setKeyWord(STRING_EVENT);
			break;
		case STRING_DEADLINE:
			handler.setKeyWord(STRING_DEADLINE);
			break;
		case STRING_EMPTY:
			handler.setKeyWord(STRING_EMPTY);
			break;
		case STRING_TASKS:
			handler.setKeyWord(STRING_TASKS);
			break;
		case STRING_OVERDUE:
			handler.setKeyWord(STRING_OVERDUE);
			break;
		case STRING_DONE:
			handler.setKeyWord(STRING_DONE);
			break;
		default:
			handler.setHasError(true);
			handler.setFeedBack(COMMAND_INVALID);
		}
		return handler;
	}
}
```
###### test\ParserTest.java
``` java
package test;

import static org.junit.Assert.*;
import org.junit.Test;
import simplyamazing.parser.Parser;

public class ParserTest {
	private static final String EDIT_COMMAND_VALID_DESCRIPTION = "edit 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_ALT = "change 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_ALT_2 = "update 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_CAP = "EDIT 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_CAP_FIRSTCHAR = "Edit 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_CAP_SECONDCHAR = "eDit 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_CAP_THIRDCHAR = "edIt 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_CAP_FOURTHCHAR = "ediT 1 description dancing";
	private static final String EDIT_COMMAND_VALID_ENDTIME = "edit 1 end 22:00 05 Apr 2016";
	private static final String EDIT_COMMAND_VALID_STARTTIME = "edit 1 start 29:00 05 Apr 2016";
	private static final String EDIT_COMMAND_VALID_PRIORITY = "edit 1 priority high";
	private static final String EDIT_COMMAND_VALID_FEEDBACK = "";
	private static final String EDIT_COMMAND_INVALID_STARTTIME_BEFORE_CURRENT = "edit 2 start 12:00 30 Mar 2016";
	private static final String EDIT_COMMAND_INVALID_ENDTIME_BEFORE_CURRENT = "edit 3 end 14:00 01 Apr 2016";
	private static final String EDIT_COMMAND_INVALID_TWO_KEYWORDS = "edit 3 start 12:00 24 Mar 2016,end 15:00 26 Mar 2016";
	private static final String EDIT_COMMAND_INVALID_WRONG_KEYWORD = "edit 2 drink";	
	private static final String EDIT_COMMAND_INVALID_WITHOUT_INDEX = "edit startTime 12:00 20 Mar 2016";
	private static final String EDIT_COMMAND_INVALID_FEEDBACK = "Error: Please input a valid field. Use the \"help edit\" command to see all the valid fields";
	private static final String EDIT_COMMAND_INVALID_STARTTIME_AFTER_ENDTIME = "edit 2 start 23:00 18 Apr 2017, end 21:00 19 Apr 2016";
	private static final String EDIT_COMMAND_INVALID_STARTTIME_EQUAL_ENDTIME = "edit 1 start 11:00 20 Apr 2016, end 11:00 20 Apr 2016";
	private static final String EDIT_COMMAND_INVALID_PRIORITY = "edit 1 priority abc";
	private static final String EDIT_COMMAND_INVALID_INDEX_FEEDBACK = "Error: Index provided is not an Integer.";
	private static final String EDIT_COMMAND_INVALID_DATE_BEFORE_CURRENT_FEEDBACK ="Error: Time provided must be after the current time";
	private static final String EDIT_COMMAND_INVALID_START_AFTER_END_FEEDBACK = "Error: Start date and time cannot be after the End date and time";
	private static final String EDIT_COMMAND_ERROR_MESSAGE_PRIORITY_LEVEL_FEEDBACK = "Error: Priority level can be only high, medium, low or none.";
	
	private static final String ADD_COMMAND_TYPE_VALID = "add";
	private static final String ADD_COMMAND_FLOATING_VALID = "add go home";
	private static final String ADD_COMMAND_FLOATING_VALID_CAP = "ADD go home";
	private static final String ADD_COMMAND_FLOATING_VALID_ALT = "+ go home";
	private static final String ADD_COMMAND_FLOATING_VALID_CAP_FIRSTCHAR = "Add go home";
	private static final String ADD_COMMAND_FLOATING_VALID_CAP_SECONDCHAR = "aDd go home";
	private static final String ADD_COMMAND_FLOATING_VALID_CAP_THIRDCHAR = "adD go home";
	private static final String ADD_COMMAND_VALID_FEEDBACK = "";
	private static final String ADD_COMMAND_DEADLINE_VALID = "add finish homework by 22:00 20 Apr 2017";
	private static final String ADD_COMMAND_DEADLINE_VALID_FEEDBACK = "";
	private static final String ADD_COMMAND_EVENT_VALID = "add have a dinner from 19:00 28 Apr 2016 to 21:00 28 Apr 2016";
	private static final String ADD_COMMAND_EVENT_COMPLEX_INVALID = "add watch nba to 18:00 29 Apr 2016 by me from 19:00 29 Apr 2016"; 
	private static final String ADD_COMMAND_WITH_ONLY_STARTTIME_INVALID = "add walk from 14:00 10 May 2017";
	private static final String ADD_COMMAND_STARTTIME_BEFORE_CURRENTTIME ="add test from 13:00 12 Mar 2016 to 14:00 11 Apr 2016";
	private static final String ADD_COMMAND_DEADLINE_NO_DESCRIPTION = "add by 23:00 01 May 2016";
	private static final String ADD_COMMAND_STARTIME_BIGGER_THAN_ENDTIME = "add swim from 21:00 22 Mar 2017 to 17:00 10 Mar 2016";
	private static final String ADD_COMMAND_EVENT_NO_DESCRIPTION = "add from 13:00 02 May 2016 to 16:00 02 May 2016";
	private static final String ADD_COMMAND_EVENT_FROM_AFTER_TO = "add go to nus to 12:00 04 May 2016 from 13:00 05 May 2016";
	private static final String ADD_COMMAND_EVENT_WRONG_TIME_FORMAT = "add testing from e:rr to b:ca";
	private static final String ADD_COMMAND_DEADLINES_ENDTIME_BEFORE_CURRENT = "add demo by 14:00 23 Mar 2016";
	private static final String ADD_COMMAND_DEADLINES_WRONG_ENDTIME = "add study by ww:aa";
	private static final String ADD_COMMAND_NONE = "add ";
	private static final String ADD_COMMAND_EVENT_VALID_FEEDBACK = "";
	private static final String ADD_COMMAND_INVALID_FEEDBACK = "Error: Start date and time cannot be after the End date and time";
	private static final String ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK = "Error: Please ensure the fields are correct";
	private static final String ADD_COMMAND_ERROR_MESSAGE_DATE_BEFORE_CURRENT_FEEDBACK ="Error: Time provided must be after the current time";
	private static final String ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK="Error: Please ensure the time format is valid. Please use the \"help\"command to view the format";
     
	private static final String HELP_COMMAND_VALID = "help";
	private static final String HELP_COMMAND_ADD_VALID = "help add";
	private static final String HELP_COMMAND_ADD_VALID_ALT = "? add";
	private static final String HELP_COMMAND_ADD_VALID_CAP = "HELP add";
	private static final String HELP_COMMAND_DELETE_VALID = "help delete";
	private static final String HELP_COMMAND_EDIT_VALID = "help edit";
	private static final String HELP_COMMAND_VIEW_VALID = "help view";
	private static final String HELP_COMMAND_DONE_VALID = "help done";
	private static final String HELP_COMMAND_SEARCH_VALID = "help search";
	private static final String HELP_COMMAND_UNDO_VALID = "help undo";
	private static final String HELP_COMMAND_LOCATION_VALID = "help location";
	private static final String HELP_COMMAND_EXIT_VALID = "help exit";
	private static final String HELP_COMMAND_VALID_FEEDBACK = "";
	private static final String HELP_COMMAND_INVALID_WITH_STRING = "help abc";
	private static final String HELP_COMMAND_INVALID_FEEDBACK = "Error: Please input a valid keyword. Use the \"help\" command to view all valid keywords";

	private static final String DELETE_COMMAND_VALID_INDEX = "delete 1";
	private static final String DELETE_COMMAND_VALID_ALT = "- 1";
	private static final String DELETE_COMMAND_VALID_ALT_2 = "del 1";
	private static final String DELETE_COMMAND_VALID_ALT_3 = "remove 1";
	private static final String DELETE_COMMAND_VALID_ALT_4 = "cancel 1";
	private static final String DELETE_COMMAND_VALID_CAP = "DELETE 1";
	private static final String DELETE_COMMAND_VALID_ALT_2_CAP = "DEL 1";
	private static final String DELETE_COMMAND_VALID_ALT_3_CAP = "REMOVE 1";
	private static final String DELETE_COMMAND_VALID_ALT_4_CAP = "CANCEL 1";
	private static final String DELETE_COMMAND_VALID_INDEX_FEEDBACK = "";
	private static final String DELETE_COMMAND_INVALID_DUMMY_STRING = "delete cba";
	private static final String DELETE_COMMAND_INVALID_FEEDBACK = "Error: Index provided is not an Integer.";

	private static final String LOCATION_COMMAND_INVALID = "location ";
	private static final String LOCATION_COMMAND_VALID = "location C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_VALID_ALT = "path C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_VALID_ALT_2 = "address C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_VALID_CAP = "LOCATION C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_VALID_ALT_CAP = "PATH C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_VALID_ALT_2_CAP = "ADDRESS C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_INVALID_FEEDBACK = "Error: Location provided is invalid";
	private static final String LOCATION_COMMAND_VALID_FEEDBACK = "";
    private static final boolean LOCATION_COMMAND_ERROR = true;
    
	private static final String DONE_COMMAND_VALID = "done 1";
	private static final String DONE_COMMAND_VALID_ALT = "finish 1";
	private static final String DONE_COMMAND_VALID_ALT_2 = "complete 1";
	private static final String DONE_COMMAND_VALID_ALT_3 = "mark 1";
	private static final String DONE_COMMAND_VALID_CAP = "DONE 1";
	private static final String DONE_COMMAND_VALID_ALT_CAP = "FINISH 1";
	private static final String DONE_COMMAND_VALID_ALT_2_CAP = "COMPLETE 1";
	private static final String DONE_COMMAND_VALID_ALT_3_CAP = "MARK 1";
	private static final String DONE_COMMAND_VALID_FEEDBACK = "";
	private static final String DONE_COMMAND_INVALID_WRONG_KEYWORD = "done home";
	private static final String DONE_COMMAND_INVALID_FEEDBACK = "Error: Index provided is not an Integer.";
	private static final String DONE_COMMAND_VALID_INDEX = "1";
	
	private static final String VIEW_COMMAND_VALID = "view";
	private static final String VIEW_COMMAND_EVENT_VALID = "view events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT = "display events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT_2 = "show events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT_3 = "list events";
	private static final String VIEW_COMMAND_EVENT_VALID_CAP = "VIEW events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT_CAP = "DISPLAY events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT_2_CAP = "SHOW events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT_3_CAP = "LIST events";
	private static final String VIEW_COMMAND_DEADLINES_VALID = "view deadlines";
	private static final String VIEW_COMMAND_TASKS_VALID = "view tasks";
	private static final String VIEW_COMMAND_DONE_VALID = "view done";
	private static final String VIEW_COMMAND_OVERDUE_VALID = "view overdue";
	private static final String VIEW_COMMAND_VALID_FEEDBACK = "";
	private static final String VIEW_COMMAND_INVALID_WRONG_KEYWORD = "view abc";
	private static final String VIEW_COMMAND_INVALID_FEEDBACK = "Error: Please input a valid keyword. Use the \"help view\" command to see all the valid keywords";
    
	private static final String SEARCH_COMMAND_VALID = "search dinner";
	private static final String SEARCH_COMMAND_VALID_ALT = "find dinner";
	private static final String SEARCH_COMMAND_VALID_CAP = "SEARCH dinner";
	private static final String SEARCH_COMMAND_VALID_ALT_CAP = "FIND dinner";
	private static final String SEARCH_COMMAND_VALID_FEEDBACK = "";
	private static final String SEARCH_COMMAND_VALID_KEYWORD = "dinner";
	
	private static final String UNDO_COMMAND_VALID = "undo";
	private static final String UNDO_COMMAND_VALID_FEEDBACK = "";
	
	private static final String EXIT_COMMAND_VALID = "exit";
	private static final String EXIT_COMMAND_VALID_ALT ="quit";
	private static final String EXIT_COMMAND_VALID_ALT_2 ="logout";
	private static final String EXIT_COMMAND_VALID_CAP = "EXIT";
	private static final String EXIT_COMMAND_VALID_ALT_CAP ="QUIT";
	private static final String EXIT_COMMAND_VALID_ALT_2_CAP ="LOGOUT";
	private static final String EXIT_COMMAND_VALID_CAP_FIRSTCHAR = "Exit";
	private static final String EXIT_COMMAND_VALID_CAP_SECONDCHAR = "eXit";
	private static final String EXIT_COMMAND_VALID_CAP_THIRDCHAR = "exIt";
	private static final String EXIT_COMMAND_VALID_CAP_FOURTHCHAR = "exiT";
	private static final String EXIT_COMMAND_VALID_FEEDBACK = "";
	
	private static final String WRONG_COMMAND_TYPE = "redoing";
	private static final String WRONG_COMMAND_TYPE_FEEDBACK = "Error: Invalid command entered. Please enter \"help\" to view command format";
    
	private static Parser parser = new Parser();

	@Test//(expected = Exception.class)
	/*
	 * The following test uses the equivalence partitioning for heuristic
	 * testing. There are two equivalent partitions which are valid and invalid
	 * commands.
	 */
	public void testAddCommand() throws Exception {
		assertEquals(ADD_COMMAND_TYPE_VALID, parser.getHandler(ADD_COMMAND_FLOATING_VALID).getCommandType());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_FLOATING_VALID).getFeedBack());
		assertEquals(ADD_COMMAND_EVENT_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_EVENT_VALID).getFeedBack());
		assertEquals(ADD_COMMAND_DEADLINE_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_DEADLINE_VALID).getFeedBack());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_FLOATING_VALID_CAP).getFeedBack());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_FLOATING_VALID_ALT).getFeedBack());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_FLOATING_VALID_CAP_FIRSTCHAR).getFeedBack());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_FLOATING_VALID_CAP_SECONDCHAR).getFeedBack());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_FLOATING_VALID_CAP_THIRDCHAR).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK, parser.getHandler(ADD_COMMAND_WITH_ONLY_STARTTIME_INVALID).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_STARTIME_BIGGER_THAN_ENDTIME).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_MESSAGE_DATE_BEFORE_CURRENT_FEEDBACK, parser.getHandler(ADD_COMMAND_STARTTIME_BEFORE_CURRENTTIME).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK, parser.getHandler(ADD_COMMAND_DEADLINE_NO_DESCRIPTION).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK, parser.getHandler(ADD_COMMAND_EVENT_NO_DESCRIPTION).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK, parser.getHandler(ADD_COMMAND_EVENT_FROM_AFTER_TO).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_MESSAGE_DATE_BEFORE_CURRENT_FEEDBACK, parser.getHandler(ADD_COMMAND_DEADLINES_ENDTIME_BEFORE_CURRENT).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK, parser.getHandler(ADD_COMMAND_EVENT_WRONG_TIME_FORMAT).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK, parser.getHandler(ADD_COMMAND_DEADLINES_WRONG_ENDTIME).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK, parser.getHandler(ADD_COMMAND_NONE).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK, parser.getHandler(ADD_COMMAND_EVENT_COMPLEX_INVALID).getFeedBack());
	}

	@Test//(expected = Exception.class)
	public void testLocationCommand() throws Exception {
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_VALID).getFeedBack());
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_VALID_ALT).getFeedBack());
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_VALID_ALT_2).getFeedBack());
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_VALID_CAP).getFeedBack());
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_VALID_ALT_CAP).getFeedBack());
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_VALID_ALT_2_CAP).getFeedBack());
		assertEquals(LOCATION_COMMAND_INVALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_INVALID).getFeedBack());
		assertEquals(LOCATION_COMMAND_ERROR, parser.getHandler(LOCATION_COMMAND_INVALID).getHasError());
	}
	
    @Test
	public void testEditCommand() throws Exception {
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_ALT).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_ALT_2).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_CAP).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_CAP_FIRSTCHAR).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_CAP_SECONDCHAR).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_CAP_THIRDCHAR).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_CAP_FOURTHCHAR).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_ENDTIME).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_STARTTIME).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_PRIORITY).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_FEEDBACK,parser.getHandler(EDIT_COMMAND_INVALID_WRONG_KEYWORD).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_INDEX_FEEDBACK,parser.getHandler(EDIT_COMMAND_INVALID_WITHOUT_INDEX).getFeedBack());
		assertEquals(EDIT_COMMAND_ERROR_MESSAGE_PRIORITY_LEVEL_FEEDBACK ,parser.getHandler(EDIT_COMMAND_INVALID_PRIORITY).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_DATE_BEFORE_CURRENT_FEEDBACK,parser.getHandler(EDIT_COMMAND_INVALID_STARTTIME_BEFORE_CURRENT).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_DATE_BEFORE_CURRENT_FEEDBACK,parser.getHandler(EDIT_COMMAND_INVALID_ENDTIME_BEFORE_CURRENT).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_DATE_BEFORE_CURRENT_FEEDBACK,parser.getHandler(EDIT_COMMAND_INVALID_TWO_KEYWORDS).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_START_AFTER_END_FEEDBACK ,parser.getHandler(EDIT_COMMAND_INVALID_STARTTIME_AFTER_ENDTIME).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_START_AFTER_END_FEEDBACK ,parser.getHandler(EDIT_COMMAND_INVALID_STARTTIME_EQUAL_ENDTIME).getFeedBack());
	}
	
    @Test//(expected = Exception.class)
	public void testHelpCommand() throws Exception {
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_ADD_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_ADD_VALID_ALT).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_ADD_VALID_CAP).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_DELETE_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_VIEW_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_LOCATION_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_DONE_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_EXIT_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_SEARCH_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_EDIT_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_UNDO_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_INVALID_FEEDBACK, parser.getHandler(HELP_COMMAND_INVALID_WITH_STRING).getFeedBack());
	}

	@Test//(expected = Exception.class)
	public void testDeleteCommand() throws Exception {
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_INDEX).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_ALT).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_ALT_2).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_ALT_3).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_ALT_4).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_CAP).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_ALT_2_CAP).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_ALT_3_CAP).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_ALT_4_CAP).getFeedBack());
		assertEquals(DELETE_COMMAND_INVALID_FEEDBACK,parser.getHandler(DELETE_COMMAND_INVALID_DUMMY_STRING).getFeedBack());
	}

	@Test//(expected = Exception.class)
	public void testDoneCommand() throws Exception {
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT_2).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT_3).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_CAP).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT_CAP).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT_2_CAP).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT_3_CAP).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_INDEX, parser.getHandler(DONE_COMMAND_VALID).getIndex());
		assertEquals(DONE_COMMAND_INVALID_FEEDBACK,parser.getHandler(DONE_COMMAND_INVALID_WRONG_KEYWORD).getFeedBack());
	}
	
	@Test
	public void testViewCommand() throws Exception {
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_EVENT_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT_2).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT_3).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_EVENT_VALID_CAP).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT_CAP).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT_2_CAP).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT_3_CAP).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_DEADLINES_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_TASKS_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_DONE_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_OVERDUE_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_INVALID_FEEDBACK,parser.getHandler(VIEW_COMMAND_INVALID_WRONG_KEYWORD).getFeedBack());	
	}
	
	@Test
	public void testSearchCommand() throws Exception {
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID_ALT).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID_CAP).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID_ALT_CAP).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_KEYWORD, parser.getHandler(SEARCH_COMMAND_VALID).getKeyWord());
	}
	
	@Test
	public void testUndoCommand() throws Exception {
		assertEquals(UNDO_COMMAND_VALID_FEEDBACK, parser.getHandler(UNDO_COMMAND_VALID).getFeedBack());
	}
	
	@Test
	public void testExitCommand() throws Exception {
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_ALT).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_ALT_2).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_CAP).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_ALT_CAP).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_ALT_2_CAP).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_CAP_FIRSTCHAR).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_CAP_SECONDCHAR).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_CAP_THIRDCHAR).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_CAP_FOURTHCHAR).getFeedBack());
	}
	
	@Test
	public void testInvalidCommand() throws Exception {
		assertEquals(WRONG_COMMAND_TYPE_FEEDBACK, parser.getHandler(WRONG_COMMAND_TYPE).getFeedBack());
	}
	
	

}
```
