# A0126289W
###### simplyamazing\data\Task.java
``` java
package simplyamazing.data;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

public class Task implements Comparable<Task>{
	private static final int DEFAULT_PRIORITY_LEVEL = 0;
	private static final int DEFAULT_PRIORITY_LEVEL_LOW = 1;
	private static final int DEFAULT_PRIORITY_LEVEL_MEDIUM = 2;
	private static final int DEFAULT_PRIORITY_LEVEL_HIGH = 3;
	
	private static final int DEFAULT_TASK_TYPE = 1;
	private static final int DEFAULT_TASK_TYPE_FOR_EVENTS = 2;
	private static final int DEFAULT_TASK_TYPE_FOR_DEADLINES = 3;
	
	public static final Date DEFAULT_DATE_VALUE = new Date(0);

	public static final String TIME_FORMAT = "HH:mm dd MMM yyyy";
	public static final String FIELD_SEPARATOR = ",";
	
	private static final String CHARACTER_SPACE = " ";
	
	private static final String STRING_HIGH_PRIORITY = "high";
	private static final String STRING_MEDIUM_PRIORITY = "medium";
	private static final String STRING_LOW_PRIORITY = "low";
	private static final String STRING_NO_PRIORITY = "none";
	
	public static final int ARRAY_POSITION_FOR_DESCRIPTION = 0;
	public static final int ARRAY_POSITION_FOR_START_TIME = 1;
	public static final int ARRAY_POSITION_FOR_END_TIME = 2;
	public static final int ARRAY_POSITION_FOR_PRIORITY = 3;
	public static final int ARRAY_POSITION_FOR_STATUS = 4;
	
	private static final String MESSAGE_INVALID_PRIORITY_LEVEL = "Priority level can be only high, medium, low or none.";
	
	private String description;
	private Date startTime, endTime;
	private int priority, taskType;
	private boolean done; 

	public Task() {
		this.description = CHARACTER_SPACE;
		this.startTime = DEFAULT_DATE_VALUE;
		this.endTime = DEFAULT_DATE_VALUE;
		this.priority = DEFAULT_PRIORITY_LEVEL;
		this.taskType = DEFAULT_TASK_TYPE;
		this.done = false;
	}
	
	public Task(String description) {
		this.description = description.trim();
		this.startTime = DEFAULT_DATE_VALUE;
		this.endTime = DEFAULT_DATE_VALUE;
		this.priority = DEFAULT_PRIORITY_LEVEL;
		this.taskType = DEFAULT_TASK_TYPE;
		this.done = false;
	}

	public Task(String description, String endTime) throws Exception {
		this.description = description.trim();
		this.startTime = DEFAULT_DATE_VALUE;
		this.endTime = convertStringToDate(endTime.trim(), TIME_FORMAT);
		this.priority = DEFAULT_PRIORITY_LEVEL;
		this.taskType = DEFAULT_TASK_TYPE_FOR_EVENTS;
		this.done = false;
	}

	public Task(String description, String startTime, String endTime) throws Exception {
		this.description = description.trim();
		this.startTime = convertStringToDate(startTime.trim(), TIME_FORMAT);
		this.endTime = convertStringToDate(endTime.trim(), TIME_FORMAT);
		this.priority = DEFAULT_PRIORITY_LEVEL;
		this.taskType = DEFAULT_TASK_TYPE_FOR_DEADLINES;
		this.done = false;
	}

	public static Date convertStringToDate(String timeString, String format) throws Exception {
        SimpleDateFormat formatter = new SimpleDateFormat(format, Locale.ENGLISH);
        Date date = formatter.parse(timeString);
        return date;
    }

    public static String convertDateToString(Date date, String format) {
        String timeString = CHARACTER_SPACE;
        SimpleDateFormat formatter = new SimpleDateFormat(format, Locale.ENGLISH);
        timeString = formatter.format(date);
        String[] fields = timeString.split(CHARACTER_SPACE);
        assert(fields.length > 0);
        String monthFirstWord = fields[2].toLowerCase().substring(0,1).toUpperCase();
        String monthFormatted = monthFirstWord + fields[2].substring(1, 3);
        timeString = fields[0] + CHARACTER_SPACE + fields[1] + CHARACTER_SPACE + monthFormatted + CHARACTER_SPACE + fields[3];
        return timeString;
    }
	
	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description.trim();
	}

	public Date getStartTime() {
		return startTime;
	}

	public void setStartTime(String startTime) throws Exception {
		this.startTime = convertStringToDate(startTime.trim(), TIME_FORMAT);
		this.taskType = DEFAULT_TASK_TYPE_FOR_EVENTS;
	}
	
	public void setStartTime(Date startTime) {
		this.startTime = startTime;
		this.taskType = DEFAULT_TASK_TYPE_FOR_EVENTS;
	}

	public Date getEndTime() {
		return endTime;
	}

	public void setEndTime(String endTime) throws Exception {
		this.endTime = convertStringToDate(endTime.trim(), TIME_FORMAT);
		if (this.startTime.compareTo(DEFAULT_DATE_VALUE) == 0) { // For floating tasks and deadlines
			this.taskType = DEFAULT_TASK_TYPE_FOR_DEADLINES;
		}
	}

	public void setEndTime(Date endTime) {
		this.endTime = endTime;
		if (this.startTime.compareTo(DEFAULT_DATE_VALUE) == 0) { // For floating tasks and deadlines
			this.taskType = DEFAULT_TASK_TYPE_FOR_DEADLINES;
		}
	}

	public int getPriority() {
		return priority;
	}

	public void setPriority(String priorityLevel) throws Exception {
		switch (priorityLevel.trim().toLowerCase()) {
			case STRING_HIGH_PRIORITY :
				this.priority = DEFAULT_PRIORITY_LEVEL_HIGH;
				break;
			case STRING_MEDIUM_PRIORITY :
				this.priority = DEFAULT_PRIORITY_LEVEL_MEDIUM;
				break;
			case STRING_LOW_PRIORITY :
				this.priority = DEFAULT_PRIORITY_LEVEL_LOW;
				break;
			case STRING_NO_PRIORITY :
				this.priority = DEFAULT_PRIORITY_LEVEL;
				break;
			default :
				throw new Exception(MESSAGE_INVALID_PRIORITY_LEVEL);
		}
	}

	public void setPriority(int priority) {
		this.priority = priority;
	}
	
	public int getTaskType() {
		return taskType;
	}

	public boolean isDone() {
		return done;
	}

	public void setDone(boolean done) {
		this.done = done;
	}
	
	@Override
	public int compareTo(Task task) {
		if (task.getPriority() == this.priority) { // Same priority
			if (task.getEndTime().compareTo(this.endTime) == 0) { // Same end time 
				if (task.getStartTime().compareTo(this.startTime) == 0) { // Same start time
					return this.description.compareToIgnoreCase(task.getDescription());
				} 
				return this.startTime.compareTo(task.getStartTime());	
			} else { // Different end time
				if (this.endTime.compareTo(DEFAULT_DATE_VALUE) == 0 || task.getEndTime().compareTo(DEFAULT_DATE_VALUE) == 0) { // One floating task and other event/deadline
					return task.getTaskType() - this.taskType;
				}
				return this.endTime.compareTo(task.getEndTime());		
			}
		}
		return task.getPriority() - this.priority;
	}

	@Override
	public String toString() {
		String startTimeString = CHARACTER_SPACE;
		String endTimeString = CHARACTER_SPACE;
		String priorityLevel = CHARACTER_SPACE;
		String status = CHARACTER_SPACE;
		
		if (this.startTime != DEFAULT_DATE_VALUE) {
			startTimeString = convertDateToString(this.startTime, TIME_FORMAT);
			assert(!startTimeString.matches(CHARACTER_SPACE));
		}
		if (this.endTime != DEFAULT_DATE_VALUE) {
			endTimeString = convertDateToString(this.endTime, TIME_FORMAT);
			assert(!endTimeString.matches(CHARACTER_SPACE));
		}
		switch (this.priority) {
			case DEFAULT_PRIORITY_LEVEL_HIGH :
				priorityLevel = STRING_HIGH_PRIORITY;
				break;
			case DEFAULT_PRIORITY_LEVEL_MEDIUM :
				priorityLevel = STRING_MEDIUM_PRIORITY;
				break;
			case DEFAULT_PRIORITY_LEVEL_LOW : 
				priorityLevel = STRING_LOW_PRIORITY;
				break;
			default :
				priorityLevel = CHARACTER_SPACE;
				break;
		}
		if (this.isDone()) {
			status = "done";
			assert(!status.matches(CHARACTER_SPACE));
		}
		return this.description.trim() + FIELD_SEPARATOR + startTimeString + FIELD_SEPARATOR + endTimeString + FIELD_SEPARATOR + priorityLevel + FIELD_SEPARATOR + status;
	}
	
	public String toFilteredString() {
		String[] fields = this.toString().split(FIELD_SEPARATOR);
		assert(fields.length == 5);
		String filteredString = "Task [";
		for (int i = 0; i < ARRAY_POSITION_FOR_STATUS; i++) {
			if (!fields[ARRAY_POSITION_FOR_START_TIME].matches(CHARACTER_SPACE)) {
				if (i == ARRAY_POSITION_FOR_START_TIME) {
					filteredString += " from ";
				}
				if (i == ARRAY_POSITION_FOR_END_TIME) {
					filteredString += " to ";
				}
			} else {
				if (!fields[ARRAY_POSITION_FOR_END_TIME].matches(CHARACTER_SPACE)) {
					if (i == ARRAY_POSITION_FOR_END_TIME) {
						filteredString += " by ";
					}
				} 
			}
			if (i == ARRAY_POSITION_FOR_PRIORITY && !fields[i].matches(CHARACTER_SPACE)) {
				filteredString += " with " + fields[i] + " priority";
			}
			if (i != ARRAY_POSITION_FOR_PRIORITY) {
				filteredString += fields[i].trim();
			}
		}
		filteredString = filteredString+"]";
		return filteredString;
	}
}
```
###### simplyamazing\data\TaskList.java
``` java
package simplyamazing.data;

import java.util.ArrayList;
import java.util.Collections;

import simplyamazing.data.Task;

public class TaskList {
	
	private static final String CHARACTER_SPACE = " ";
	private static final int SIZE_EMPTY = 0;
	
	private ArrayList<Task> tasks, completedTasks;
	
	public TaskList() {
		tasks = new ArrayList<Task>();
		completedTasks = new ArrayList<Task>();
	}
	
	public ArrayList<Task> getTasks() {
		return tasks;
	}
	
	public ArrayList<Task> getCompletedTasks() {
		return completedTasks;
	}

	public void resetTaskList() {
		tasks = new ArrayList<Task>();
		assert(tasks.size()==0);
	}

	public void resetCompletedTaskList() {
		completedTasks = new ArrayList<Task>();
		assert(completedTasks.size()==0);
	}
	
	public void createTaskList(ArrayList<String> lines, ArrayList<Task> taskList) throws Exception {
		for (int i = 0; i < lines.size(); i++) {
			String[] fields = lines.get(i).split(Task.FIELD_SEPARATOR);
			assert(fields.length == 5);
			
			String description = fields[Task.ARRAY_POSITION_FOR_DESCRIPTION];
			String startTimeString = fields[Task.ARRAY_POSITION_FOR_START_TIME];
			String endTimeString = fields[Task.ARRAY_POSITION_FOR_END_TIME];
			String priorityLevel = fields[Task.ARRAY_POSITION_FOR_PRIORITY];
			String status = fields[Task.ARRAY_POSITION_FOR_STATUS];
			
			Task task = new Task();
			if (!description.matches(CHARACTER_SPACE)) {
				task.setDescription(description);
			}
			if (!startTimeString.matches(CHARACTER_SPACE)) {
				task.setStartTime(startTimeString);
			}
			if (!endTimeString.matches(CHARACTER_SPACE)) {
				task.setEndTime(endTimeString);
			}
			if (!priorityLevel.matches(CHARACTER_SPACE)) {
				task.setPriority(priorityLevel);
			}
			if (!status.matches(CHARACTER_SPACE)) {
				task.setDone(true);
			}
			addTaskToList(task, taskList);
		}
	}
	
	public void updateTaskList(ArrayList<String> lines, ArrayList<Task> taskList) throws Exception {
		if (taskList.size() == SIZE_EMPTY) {
			createTaskList(lines, taskList);
		}
	}
	
	public void addTaskToList(Task task, ArrayList<Task> taskList) throws Exception {
		int taskListSizeBeforeAdding = taskList.size();
		taskList.add(task);
		int taskListSizeAfterAdding = taskList.size();
		assert(taskListSizeAfterAdding == taskListSizeBeforeAdding + 1);
		Collections.sort(taskList);
	}
	
	public void removeTaskFromList(Task task) throws Exception {
		int taskListSizeBeforeRemoving = 0, taskListSizeAfterRemoving = 0;
		
		if (tasks.contains(task)) {
			taskListSizeBeforeRemoving = tasks.size();
			tasks.remove(task);
			taskListSizeAfterRemoving = tasks.size();
			Collections.sort(tasks);
		} else {
			taskListSizeBeforeRemoving = completedTasks.size();
			completedTasks.remove(task);
			taskListSizeAfterRemoving = completedTasks.size();
			Collections.sort(completedTasks);
		}
		assert(taskListSizeAfterRemoving == taskListSizeBeforeRemoving - 1);
	}
}
```
###### simplyamazing\storage\FileBuilder.java
``` java
package simplyamazing.storage;

import java.io.File;

public class FileBuilder {
	public void createDirectory(String directoryName) {
		new File(directoryName).mkdirs();
	}
	
	public void createNewFile(File file) throws Exception {
		file.createNewFile();
	}
	
	public File createFile(String filename) {
		File file = new File(filename);
		return file;
	}
}
```
###### simplyamazing\storage\FileCopier.java
``` java
package simplyamazing.storage;

import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;

import java.io.File;
import java.nio.file.Files;

public class FileCopier {
	public void copy(File source, File destination) throws Exception {
		Files.copy(source.toPath(), destination.toPath(), REPLACE_EXISTING);
	}
}
```
###### simplyamazing\storage\FileManager.java
``` java
package simplyamazing.storage;

import java.io.File;
import java.util.ArrayList;

import simplyamazing.data.Task;

public class FileManager {
	
	FileBuilder fileBuilder;
	FileVerifier fileVerifier;
	FileCopier fileCopier;
	ReadManager readManager;
	WriteManager writeManager;
	
	public FileManager() {
		fileBuilder = new FileBuilder();
		fileVerifier = new FileVerifier();
		fileCopier = new FileCopier();
		readManager = new ReadManager();
		writeManager = new WriteManager();
	}
	
	public void createDirectory(String directoryName) {
		fileBuilder.createDirectory(directoryName);
	}
	
	public void createNewFile(File file) throws Exception {
		if(fileVerifier.isFileExisting(file)) {
			file.delete();
		}
		fileBuilder.createNewFile(file);
	}
	
	public File createFile(String filename) {
		return fileBuilder.createFile(filename);
	}
	
	public boolean isDirectory(String location) {
		return fileVerifier.isDirectory(location);
	}
	
	public boolean isEmptyFile(File file) {
		return fileVerifier.isEmptyFile(file);
	}
	
	public boolean isFileExisting(File file) {
		return fileVerifier.isFileExisting(file);
	}
	
	public int getLineCount(File file) throws Exception {
		return readManager.read(file).size();
	}
	
	public void importListToFile(ArrayList<Task> tasks, File file) throws Exception {
		if (!fileVerifier.isEmptyFile(file)) { 
			cleanFile(file);
		}
		for (int i = 0; i < tasks.size(); i++) {
			writeToFile(file, tasks.get(i).toString());
		}	
	}
	
	public void writeToFile(File file, String text) throws Exception {
		writeManager.write(file, text);
	}
	
	public ArrayList<String> readFile(File file) throws Exception {
		return readManager.read(file);
	}
	
	public void cleanFile(File file) throws Exception {
		writeManager.writeEmptyFile(file);
	}
	
	public void createBackup(File file, File backupFile) throws Exception {
		if(!isEmptyFile(file)) {
			fileCopier.copy(file, backupFile);
		}
	}
	
	public void restoreFromBackup(File file, File backupFile) throws Exception {
		fileCopier.copy(backupFile, file);
	}
}
```
###### simplyamazing\storage\FileVerifier.java
``` java
package simplyamazing.storage;

import java.io.File;

public class FileVerifier {
	
	private static final int SIZE_EMPTY = 0;
	
	public boolean isDirectory(String location) {
		return new File(location).isDirectory();
	}
	
	public boolean isEmptyFile(File file) {
		return file.length() == SIZE_EMPTY;
	}
	
	public boolean isFileExisting(File file) {
		return file.exists();
	}
}
```
###### simplyamazing\storage\ReadManager.java
``` java
package simplyamazing.storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class ReadManager {
	
	public ArrayList<String> read(File file) throws Exception {
		FileInputStream fileInputStream = new FileInputStream(file);
		InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream);
		BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
		String line = null;
		ArrayList<String> lines = new ArrayList<String>();
		
		while ((line = bufferedReader.readLine()) != null) {	
			lines.add(line);
		}
		bufferedReader.close();
		return lines;	 
	}
}
```
###### simplyamazing\storage\Storage.java
``` java
package simplyamazing.storage;

import java.io.File;
import java.util.ArrayList;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import simplyamazing.data.Task;
import simplyamazing.data.TaskList;

public class Storage {
	private static final String DIRECTORY_SYSTEM = "C:\\Users\\Public\\SimplyAmzing";
	private static final String FILENAME_STORAGE = "\\storage.txt";
	private static final String FILENAME_TODO = "\\todo.txt";
	private static final String FILENAME_DONE = "\\done.txt";
	private static final String FILENAME_TODO_BACKUP = "\\todoBackup.txt";
	private static final String FILENAME_DONE_BACKUP = "\\doneBackup.txt";

	private static final String CHARACTER_SPACE = " ";
	private static final String STRING_EMPTY = "";

	private static final String STRING_TASK_TYPE_EVENT = "events";
	private static final String STRING_TASK_TYPE_DEADLINE = "deadlines";
	private static final String STRING_TASK_TYPE_FLOATING = "tasks";
	private static final String STRING_TASK_TYPE_OVERDUE = "overdue";
	private static final String STRING_TASK_TYPE_DONE = "done";

	private static final int INDEX_START_FOR_ARRAY = 0;

	private static final String MESSAGE_LOCATION_SET = "Storage location of task data has been sucessfully set as %1$s.";
	private static final String MESSAGE_LOCATION_NOT_SET = "Error: Storage location of task data is has not been set. Please enter \"location <directory>\" command to set the storage location.";
	private static final String MESSAGE_NOT_DIRECTORY = "Error: Not a valid directory.";
	private static final String MESSAGE_ADDED = "%1$s has been added.";
	private static final String MESSAGE_RESTORED = "\"%1$s\" command has been successfully undone.";
	private static final String MESSAGE_INVALID_TASK_TYPE = "Unrecognized task type!";
	private static final String MESSAGE_COMPLETED_TASK = "%1$s is a completed task.";
	private static final String MESSAGE_DELETED = "%1$s has been successfully deleted.";
	private static final String MESSAGE_MARKED_DONE = "%1$s has been marked as done.";
	private static final String MESSAGE_UPDATED = "%1$s has been successfully updated.";

	private static final String MESSAGE_LOG_DIRECTORY_CREATED = "Directory for storage file is created successfully.";
	private static final String MESSAGE_LOG_STORAGE_FILE_CREATED = "Storage file is setup successfully.";
	private static final String MESSAGE_LOG_TASK_DATA_FILE_SETUP = "Task data file is setup successfully.";
	private static final String MESSAGE_LOG_DONE_TASKS_FILE_SETUP = "Task data file for completed tasks is setup successfully.";
	private static final String MESSAGE_LOG_TASK_DATA_BACKUP_FILE_SETUP = "Task data backup file is setup successfully.";
	private static final String MESSAGE_LOG_DONE_TASKS_BACKUP_FILE_SETUP = "Task data backup file for completed tasks is setup successfully.";
	private static final String MESSAGE_LOG_TASK_DATA_BACKUP_FILE_UPDATED = "Task data backup file is successfully updated";
	private static final String MESSAGE_LOG_COMPLETED_TASK_DATA_BACKUP_FILE_UPDATED = "Task data backup file for completed tasks is successfully updated";
	private static final String MESSAGE_LOG_TASK_LIST_UPDATED = "Task data is successfully loaded into the task list.";
	private static final String MESSAGE_LOG_TASK_DATA_READABLE = "Content is readable from task data file.";
	private static final String MESSAGE_LOG_TASK_DATA_WRITTEN_TO_FILE = "Task list is successfully imported into the task data file.";

	private static Logger logger = Logger.getLogger("Storage");

	private static boolean isEditing = false;

	private File storage, todo, done, todoBackup, doneBackup;

	private FileManager fileManager;
	private TaskList taskList;

	public Storage() {
		fileManager = new FileManager();

		fileManager.createDirectory(DIRECTORY_SYSTEM);
		logger.log(Level.CONFIG, MESSAGE_LOG_DIRECTORY_CREATED);

		storage = fileManager.createFile((DIRECTORY_SYSTEM+FILENAME_STORAGE));
		logger.log(Level.CONFIG, MESSAGE_LOG_STORAGE_FILE_CREATED);

		taskList = new TaskList();
	}

	public FileManager getFileManager() {
		return fileManager;
	}

	public TaskList getTaskList() {
		return taskList;
	}

	private boolean isLocationSet() {
		return !fileManager.isEmptyFile(storage);
	}

	public String setLocation(String location) throws Exception {
		if(!fileManager.isDirectory(location)) {
			logger.log(Level.WARNING, MESSAGE_NOT_DIRECTORY);
			throw new Exception(MESSAGE_NOT_DIRECTORY);
		} else {	
			if (!fileManager.isFileExisting(storage)) {
				fileManager.createNewFile(storage);
			}
			if(isLocationSet()) { // When storage location has been set before
				setupFiles();

				File todoNew = fileManager.createFile(location+FILENAME_TODO);
				fileManager.createBackup(todo, todoNew);
				todo.delete();
				todo = todoNew;

				File doneNew = fileManager.createFile(location+FILENAME_DONE);
				fileManager.createBackup(done, doneNew);
				done.delete();
				done = doneNew;

				fileManager.cleanFile(storage);
			}
			fileManager.writeToFile(storage, location);

			String feedback = String.format(MESSAGE_LOCATION_SET, location);
			logger.log(Level.INFO, feedback);
			return feedback;
		}
	}

	public String getLocation() throws Exception {
		if(!isLocationSet()) {
			fileManager.writeToFile(storage, DIRECTORY_SYSTEM);
		} 
		String location = fileManager.readFile(storage).get(INDEX_START_FOR_ARRAY);
		return location;
	}

	public String addTask(Task task) throws Exception {
		setupFiles();
		if(!isEditing) {
			fileManager.createBackup(todo, todoBackup);
			logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_BACKUP_FILE_UPDATED);
		}
		updateTaskData();

		taskList.addTaskToList(task, taskList.getTasks());

		int lineCountBeforeAdding = fileManager.getLineCount(todo);
		fileManager.importListToFile(taskList.getTasks(), todo);
		int lineCountAfterAdding = fileManager.getLineCount(todo);
		assert(lineCountAfterAdding == lineCountBeforeAdding + 1);
		logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_WRITTEN_TO_FILE);

		String feedback = String.format(MESSAGE_ADDED, task.toFilteredString());
		logger.log(Level.INFO, feedback);
		return feedback;
	}

	private void setupFiles() throws Exception {
		todo = fileManager.createFile(getLocation()+FILENAME_TODO);	
		if (!fileManager.isFileExisting(todo)) {
			fileManager.createNewFile(todo);
		}
		logger.log(Level.CONFIG, MESSAGE_LOG_TASK_DATA_FILE_SETUP);

		todoBackup = fileManager.createFile(DIRECTORY_SYSTEM+FILENAME_TODO_BACKUP);
		if (!fileManager.isFileExisting(todoBackup)) {
			fileManager.createNewFile(todoBackup);
		}
		logger.log(Level.CONFIG, MESSAGE_LOG_TASK_DATA_BACKUP_FILE_SETUP);

		done = fileManager.createFile(getLocation()+FILENAME_DONE);
		if (!fileManager.isFileExisting(done)) {
			fileManager.createNewFile(done);
		}
		logger.log(Level.CONFIG, MESSAGE_LOG_DONE_TASKS_FILE_SETUP);

		doneBackup = fileManager.createFile(DIRECTORY_SYSTEM+FILENAME_DONE_BACKUP);
		if (!fileManager.isFileExisting(doneBackup)) {
			fileManager.createNewFile(doneBackup);
		}
		logger.log(Level.CONFIG, MESSAGE_LOG_DONE_TASKS_BACKUP_FILE_SETUP);
	}

	private void updateTaskData() throws Exception {
		if(!fileManager.isEmptyFile(todo)) {
			ArrayList<String> taskData = fileManager.readFile(todo);
			logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_READABLE);
			taskList.updateTaskList(taskData, taskList.getTasks());
			assert(taskList.getTasks().size() > 0);
			logger.log(Level.INFO, MESSAGE_LOG_TASK_LIST_UPDATED);
		}
		if(!fileManager.isEmptyFile(done)) {
			ArrayList<String> completedTaskData = fileManager.readFile(done);
			logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_READABLE);
			taskList.updateTaskList(completedTaskData, taskList.getCompletedTasks());
			assert(taskList.getCompletedTasks().size() > 0);
			logger.log(Level.INFO, MESSAGE_LOG_TASK_LIST_UPDATED);
		}
	}

	public String editTask(Task task, Task editedTask) throws Exception {

		isEditing = true;			
		throwExceptionIfCompletedTask(task);

		deleteTask(task);

		if (!task.getDescription().matches(editedTask.getDescription()) && !editedTask.getDescription().matches(CHARACTER_SPACE)) {
			task.setDescription(editedTask.getDescription());
		}
		if (task.getStartTime().compareTo(editedTask.getStartTime()) != 0 && editedTask.getStartTime().compareTo(Task.DEFAULT_DATE_VALUE) != 0) {
			task.setStartTime(editedTask.getStartTime());
		}
		if (task.getEndTime().compareTo(editedTask.getEndTime()) != 0 && editedTask.getEndTime().compareTo(Task.DEFAULT_DATE_VALUE) != 0) {
			task.setEndTime(editedTask.getEndTime());
		}
		if (task.getPriority() != editedTask.getPriority()) {
			task.setPriority(editedTask.getPriority());
		}

		addTask(task);

		String feedback = String.format(MESSAGE_UPDATED, task.toFilteredString());
		logger.log(Level.INFO, feedback);
		isEditing = false;
		return feedback;
	}

	private void throwExceptionIfCompletedTask(Task task) throws Exception {
		if(taskList.getCompletedTasks().contains(task)) {
			String exceptionMessage = String.format(MESSAGE_COMPLETED_TASK, task.toFilteredString());
			logger.log(Level.WARNING, exceptionMessage);
			throw new Exception(exceptionMessage);
		}
	}

	public String deleteTask(Task task) throws Exception {
		setupFiles();

		fileManager.createBackup(todo, todoBackup);
		logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_BACKUP_FILE_UPDATED);

		updateTaskData();

		taskList.removeTaskFromList(task);

		int lineCountBeforeAdding = fileManager.getLineCount(todo);
		fileManager.importListToFile(taskList.getTasks(), todo);
		int lineCountAfterAdding = fileManager.getLineCount(todo);
		assert(lineCountAfterAdding <= lineCountBeforeAdding);

		lineCountBeforeAdding = fileManager.getLineCount(done);
		fileManager.importListToFile(taskList.getCompletedTasks(), done);
		lineCountAfterAdding = fileManager.getLineCount(done);
		assert(lineCountAfterAdding <= lineCountBeforeAdding);

		logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_WRITTEN_TO_FILE);

		String feedback = String.format(MESSAGE_DELETED, task.toFilteredString());
		logger.log(Level.INFO, feedback);
		return feedback;
	}

	public ArrayList<Task> viewTasks(String taskType) throws Exception {

		setupFiles();

		updateTaskData();

		switch(taskType) {
		case STRING_EMPTY :
			return viewTasks();
		case STRING_TASK_TYPE_EVENT :
			return viewEvents();
		case STRING_TASK_TYPE_DEADLINE :
			return viewDeadlines();
		case STRING_TASK_TYPE_FLOATING :
			return viewFloatingTasks();
		case STRING_TASK_TYPE_OVERDUE :
			return viewOverdueTasks();
		case STRING_TASK_TYPE_DONE :
			return viewCompletedTasks();
		default :
			throw new Exception(MESSAGE_INVALID_TASK_TYPE);
		}
	}

	private ArrayList<Task> viewTasks() {
		ArrayList<Task> tasks = taskList.getTasks();
		ArrayList<Task> currentTasks = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			Task task = tasks.get(i);
			Date now = new Date();
			Date startTime = task.getStartTime();
			Date endTime = task.getEndTime();
			if ((startTime.after(now) || startTime == Task.DEFAULT_DATE_VALUE) && (endTime.after(now) || endTime == Task.DEFAULT_DATE_VALUE)) {
				currentTasks.add(task);
			}
		}
		return currentTasks;
	}

	private ArrayList<Task> viewEvents() {
		ArrayList<Task> tasks = taskList.getTasks();
		ArrayList<Task> currentEvents = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			Task task = tasks.get(i);
			Date now = new Date();
			Date startTime = task.getStartTime();
			Date endTime = task.getEndTime();
			if ((startTime.after(now) && endTime.after(now)) && startTime != Task.DEFAULT_DATE_VALUE) {
				currentEvents.add(task);
			}
		}
		return currentEvents;
	}

	private ArrayList<Task> viewDeadlines() {
		ArrayList<Task> tasks = taskList.getTasks();
		ArrayList<Task> currentDeadlines = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			Task task = tasks.get(i);
			Date now = new Date();
			Date startTime = task.getStartTime();
			Date endTime = task.getEndTime();
			if (endTime.after(now) && startTime == Task.DEFAULT_DATE_VALUE) {
				currentDeadlines.add(task);
			}
		}
		return currentDeadlines;
	}

	private ArrayList<Task> viewFloatingTasks() {
		ArrayList<Task> tasks = taskList.getTasks();
		ArrayList<Task> currentFloatingTasks = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			Task task = tasks.get(i);
			Date startTime = task.getStartTime();
			Date endTime = task.getEndTime();
			if (startTime == Task.DEFAULT_DATE_VALUE && endTime == Task.DEFAULT_DATE_VALUE) {
				currentFloatingTasks.add(task);
			}
		}
		return currentFloatingTasks;
	}

	private ArrayList<Task> viewOverdueTasks() {
		ArrayList<Task> tasks = taskList.getTasks();
		ArrayList<Task> overdueTasks = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			Task task = tasks.get(i);
			Date now = new Date();
			Date endTime = task.getEndTime();
			if (endTime.before(now) && endTime != Task.DEFAULT_DATE_VALUE) {
				overdueTasks.add(task);
			}
		}
		return overdueTasks;		
	}

	private ArrayList<Task> viewCompletedTasks() {
		return taskList.getCompletedTasks();
	}

	public ArrayList<Task> searchTasks(String keyword) throws Exception {
		keyword = keyword.toLowerCase();
		ArrayList<Task> tasks = viewTasks(STRING_EMPTY);
		assert(tasks != null);
		tasks.addAll(taskList.getCompletedTasks());

		ArrayList<Task> filteredTasks = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).toString().contains(keyword)) {
				filteredTasks.add(tasks.get(i));
			}
		}
		String[] keywords = keyword.split(CHARACTER_SPACE);
		for (int i = 0; i < tasks.size(); i++) {
			for (int j = 0; j < keywords.length; j++) {
				if (tasks.get(i).toString().contains(keywords[j]) && !filteredTasks.contains(tasks.get(i))) {
					filteredTasks.add(tasks.get(i));
				}
			}
		}
		return filteredTasks;
	}
	
	public ArrayList<Task> searchTasksByDate(Date date) throws Exception {
		String[] datetimes = Task.convertDateToString(date, Task.TIME_FORMAT).split(CHARACTER_SPACE);
		String dateString = datetimes[1] + CHARACTER_SPACE + datetimes[2] + CHARACTER_SPACE + datetimes[3];
		ArrayList<Task> tasks = viewTasks(STRING_EMPTY);
		assert(tasks != null);
		tasks.addAll(taskList.getCompletedTasks());

		ArrayList<Task> filteredTasks = new ArrayList<Task>();
		// put the tasks with the exact match of the specified date first
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).toString().contains(dateString)) { 
				filteredTasks.add(tasks.get(i));
			}	
		}
		
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getEndTime().compareTo(date) == 0 && !filteredTasks.contains(tasks.get(i))) { 
				filteredTasks.add(tasks.get(i));
			}	
		}
		
		// put the tasks which has end time after the specified date
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getStartTime().before(date) && tasks.get(i).getEndTime().after(date) && tasks.get(i).getEndTime() != Task.DEFAULT_DATE_VALUE && !filteredTasks.contains(tasks.get(i))) {
				filteredTasks.add(tasks.get(i));
			}
		}
		return filteredTasks;
	}

	public String markTaskDone(Task task) throws Exception {
		throwExceptionIfCompletedTask(task);

		deleteTask(task);
		task.setDone(true);
		moveToDoneFile(task);

		String feedback = String.format(MESSAGE_MARKED_DONE, task.toFilteredString());
		logger.log(Level.INFO, feedback);
		return feedback;
	}

	private void moveToDoneFile(Task task) throws Exception {
		fileManager.createBackup(done, doneBackup);
		logger.log(Level.INFO, MESSAGE_LOG_COMPLETED_TASK_DATA_BACKUP_FILE_UPDATED);

		taskList.addTaskToList(task, taskList.getCompletedTasks());

		int lineCountBeforeAdding = fileManager.getLineCount(done);
		fileManager.importListToFile(taskList.getCompletedTasks(), done);
		int lineCountAfterAdding = fileManager.getLineCount(done);
		assert(lineCountAfterAdding == lineCountBeforeAdding + 1);
		logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_WRITTEN_TO_FILE);
	}

	public String restore(String previousCommand) throws Exception {
		setupFiles();

		if(!fileManager.isEmptyFile(todoBackup) || !fileManager.isEmptyFile(todo)) {
			fileManager.restoreFromBackup(todo, todoBackup);
			taskList.resetTaskList();
			assert(taskList.getTasks().size() == 0);
			updateTaskData();
		}
		if(!fileManager.isEmptyFile(doneBackup) || !fileManager.isEmptyFile(done)) {
			fileManager.restoreFromBackup(done, doneBackup);
			taskList.resetCompletedTaskList();
			assert(taskList.getCompletedTasks().size() == 0);
			updateTaskData();
		}
		String feedback = String.format(MESSAGE_RESTORED, previousCommand);
		logger.log(Level.INFO, feedback);
		return feedback;
	}
}
```
###### simplyamazing\storage\WriteManager.java
``` java
package simplyamazing.storage;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;

public class WriteManager {
	
	private static final String CHARACTER_NEW_LINE = System.lineSeparator();
	
	public void write(File file, String content) throws Exception {
		FileWriter fileWriter = new FileWriter(file, true);
		fileWriter.write(content);
		fileWriter.write(CHARACTER_NEW_LINE);
		fileWriter.close();	
	}
	
	public void writeEmptyFile(File file) throws Exception {
		FileOutputStream writer = new FileOutputStream(file);
		writer.close();
	}
}
```
###### simplyamazing\ui\CommandBarController.java
``` java
package simplyamazing.ui;

import java.awt.Color;
import java.awt.Font;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

import javax.swing.JTextField;

public class CommandBarController {
	private static JTextField commandBar;
	
	public CommandBarController() {
		commandBar = new JTextField();
		commandBar.setForeground(Color.BLACK);
		commandBar.setToolTipText("Type your command here.");
		commandBar.setFont(new Font("Tahoma", Font.PLAIN, 14));
		commandBar.setColumns(10);
	}
	
	public void handleKeyPressedEvent(final UI ui) {
		commandBar.addKeyListener(new KeyAdapter() {
			@Override
			public void keyPressed(KeyEvent e) {
				if(e.isActionKey()) {
					if(e.getKeyCode() == KeyEvent.VK_UP) {
						ui.getUserCommand();
					}
				} else {
					if(e.getKeyCode() == KeyEvent.VK_ENTER) {
						ui.executeUserCommand();
						clear();
					} 
				}
			}
		});
	}
	
	public void handleKeyPressedEvent(final ResizableUI ui) {
		commandBar.addKeyListener(new KeyAdapter() {
			@Override
			public void keyPressed(KeyEvent e) {
				if(e.isActionKey()) {
					if(e.getKeyCode() == KeyEvent.VK_UP) {
						ui.getUserCommand();
					}
				} else {
					if(e.getKeyCode() == KeyEvent.VK_ENTER) {
						ui.executeUserCommand();
						clear();
					} 
				}
			}
		});
	}
	
	public void handleKeyPressedEvent(final FixedSizedUI ui) {
		commandBar.addKeyListener(new KeyAdapter() {
			@Override
			public void keyPressed(KeyEvent e) {
				if(e.isActionKey()) {
					if(e.getKeyCode() == KeyEvent.VK_UP) {
						ui.getUserCommand();
					}
				} else {
					if(e.getKeyCode() == KeyEvent.VK_ENTER) {
						ui.executeUserCommand();
						clear();
					} 
				}
			}
		});
	}

	public JTextField getCommandBar() {
		return commandBar;
	}

	public String getCommand() {
		return commandBar.getText();
	}
	
	public void setCommand(String command) {
		commandBar.setText(command);
	}
	
	public void clear() {
		commandBar.setText("");
	}
}
```
###### simplyamazing\ui\FeedbackArea.java
``` java
package simplyamazing.ui;

import java.awt.Color;

import javax.swing.JTextArea;

public class FeedbackArea {
	private final String STRING_NULL = "";
	
	private JTextArea feedbackArea;
	
	public FeedbackArea() {
		feedbackArea = new JTextArea();
		feedbackArea.setEditable(false);
	}

	public JTextArea getFeedbackArea() {		
		return feedbackArea;
	}

	public void setFeedback(String feedback) {
		feedbackArea.setText(feedback);
	}
	
	public void clear() {
		feedbackArea.setText(STRING_NULL);
	}
	
	public void colorCodeFeedback(Color color) {
		feedbackArea.setForeground(color);
	}
}
```
###### simplyamazing\ui\FixedSizedUI.java
``` java
package simplyamazing.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.SystemColor;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JTextArea;

import simplyamazing.logic.Logic;

public class FixedSizedUI {
	private static final String MESSAGE_LOG_USER_COMMAND_EXECUTED = "user command is successfully executed.";
	private static final String MESSAGE_EMPTY_LIST = "List is empty";
	
	private static final Color COLOR_DARK_GREEN = new Color(0, 128, 0);

	private static final String CHARACTER_NEW_LINE = "\n";
	public static final String FIELD_SEPARATOR = ",";
	private static final String STRING_ERROR = "Error";
	
	private static Logger logger = Logger.getLogger("UI");
	
	private JFrame frame;
	private JSeparator separator, separator_1;
	private JTextArea txtrHeader;
	private JScrollPane scrollPane;
	
	private static Logic logic;
	private static CommandBarController commandBarController;
	private static TaskDataPanel taskDataPanel;
	private static FeedbackArea feedbackArea;
	private static InstructionPanel instructionPanel;

	/**
	 * Launch the application.
	 */
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					FixedSizedUI window = new FixedSizedUI();
					window.frame.setVisible(true);
					commandBarController.getCommandBar().requestFocusInWindow();
					logic = new Logic();
					String taskDataString = window.getTaskData();
					if (taskDataString.contains(CHARACTER_NEW_LINE)) {
						window.updateTaskTable();
					} else {
						window.scrollPane.setVisible(false);
						feedbackArea.colorCodeFeedback(COLOR_DARK_GREEN);
						feedbackArea.setFeedback(taskDataString);
						logger.log(Level.INFO, taskDataString);
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}
	
	private static String getErrorMessage(Exception e) {
		return e.getMessage();
	}

	/**
	 * Create the application.
	 * @throws Exception 
	 */
	public FixedSizedUI() {
		initialize();
		addUIComponentsToFrame();
	}

	/**
	 * Initialize the contents of the frame.
	 */
	private void initialize() {
		setupFrame();
		setupAppLogo();
		setupFeedbackArea();
		setupCommandBar();
		setupScrollPane();
		setupSeparators();
	}

	private void setupScrollPane() {
		scrollPane = new JScrollPane();
		scrollPane.setFont(new Font("Times New Roman", Font.PLAIN, 16));
		scrollPane.setBorder(BorderFactory.createEmptyBorder());
		scrollPane.setBounds(10, 57, 744, 278);
	}

	private void addUIComponentsToFrame() {
		frame.getContentPane().add(txtrHeader);
		frame.getContentPane().add(separator_1);
		frame.getContentPane().add(scrollPane);
		frame.getContentPane().add(separator);
		frame.getContentPane().add(feedbackArea.getFeedbackArea());
		frame.getContentPane().add(commandBarController.getCommandBar());
	}

	private void setupFeedbackArea() {
		feedbackArea = new FeedbackArea();
		feedbackArea.getFeedbackArea().setBounds(10, 346, 744, 22);
	}

	private void setupInstructionPanel() {
		instructionPanel = new InstructionPanel();
		instructionPanel.getInstrctionPanel().setBounds(10, 57, 744, 311);
	}
	
	private void setupTaskDataPanel(Object[][] taskData) {
		taskDataPanel = new TaskDataPanel(taskData);
	}

	private void setupAppLogo() {
		txtrHeader = new JTextArea();
		txtrHeader.setFont(new Font("Lucida Calligraphy", Font.BOLD, 18));
		txtrHeader.setEditable(false);
		txtrHeader.setText("Welcome to SimplyAmazing!");
		txtrHeader.setBounds(227, 6, 310, 27);
	}

	private void setupSeparators() {
		separator = new JSeparator();
		separator.setBounds(10, 379, 744, 4);
		separator_1 = new JSeparator();
		separator_1.setBounds(10, 44, 744, 4);
	}

	private void setupCommandBar() {
		commandBarController = new CommandBarController();
		commandBarController.getCommandBar().setFont(new Font("Tahoma", Font.BOLD | Font.ITALIC, 16));
		commandBarController.getCommandBar().setBounds(10, 392, 744, 33);
		commandBarController.handleKeyPressedEvent(this);
	}

	private void setupFrame() {
		frame = new JFrame();
		frame.setResizable(false);
		frame.setForeground(new Color(255, 255, 255));
		frame.getContentPane().setBackground(SystemColor.window);
		frame.setBounds(100, 100, 770, 475);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.getContentPane().setLayout(null);
	}

	public void executeUserCommand() {
		String feedback = null;
		String command = commandBarController.getCommand();
		feedbackArea.clear();
		try {
			feedback = logic.executeCommand(command);
			logger.log(Level.INFO, MESSAGE_LOG_USER_COMMAND_EXECUTED);
			
			if (feedback.contains(CHARACTER_NEW_LINE)) {
				String[] tasks = feedback.split(CHARACTER_NEW_LINE);
				
				if (tasks[0].split(FIELD_SEPARATOR).length == 6) {
					String[][] taskData = new String[tasks.length][6];
					for (int i = 0; i < tasks.length; i++) {
						taskData[i] = tasks[i].split(FIELD_SEPARATOR);
					}
					scrollPane.setVisible(true);
					setupTaskDataPanel(taskData); 
					scrollPane.setViewportView(taskDataPanel.getTaskDataPanel());
					scrollPane.getViewport().setBackground(Color.WHITE);
				} else {
					setupInstructionPanel();
					scrollPane.setVisible(true);
					scrollPane.setViewportView(instructionPanel.getInstrctionPanel());
					instructionPanel.setInstruction(feedback);
				}
			} else { // only feedback
				if (getTaskData().contains(CHARACTER_NEW_LINE)) {
					updateTaskTable();
				} 
				if (feedback.contains(STRING_ERROR)) {
					feedbackArea.colorCodeFeedback(Color.RED);
					logger.log(Level.WARNING, feedback);
				} else {
					if (feedback.matches(MESSAGE_EMPTY_LIST)) {
						scrollPane.setVisible(false);
					}
					feedbackArea.colorCodeFeedback(COLOR_DARK_GREEN);
					logger.log(Level.INFO, feedback);
				}
				feedbackArea.setFeedback(feedback);
			}
			commandBarController.clear(); 
		} catch (Exception e1) {
			feedback = getErrorMessage(e1);
			logger.log(Level.WARNING, feedback);
			feedbackArea.colorCodeFeedback(Color.RED);
			feedbackArea.setFeedback(feedback);
		}
	}
	
	private void updateTaskTable() throws Exception {
		String[] tasks = getTaskData().split(CHARACTER_NEW_LINE);
		
		String[][] taskData = new String[tasks.length][6];
		for (int i = 0; i < tasks.length; i++) {
			taskData[i] = tasks[i].split(FIELD_SEPARATOR);
		}
		setupTaskDataPanel(taskData); 
		scrollPane.setVisible(true);
		scrollPane.setViewportView(taskDataPanel.getTaskDataPanel());
		scrollPane.getViewport().setBackground(Color.WHITE);
	}

	private String getTaskData() throws Exception {
		String taskDataString = logic.getView();
		return taskDataString;
	}

	public void getUserCommand() {
		String command = logic.getPreviousCommand();
		commandBarController.setCommand(command);
	}
}
```
###### simplyamazing\ui\InstructionPanel.java
``` java
package simplyamazing.ui;

import java.awt.Color;
import java.awt.Font;

import javax.swing.JScrollPane;
import javax.swing.JTextPane;

public class InstructionPanel {
	private static final String STRING_NULL = "";
	private JTextPane instructionPanel;
	
	public InstructionPanel() {
		instructionPanel = new JTextPane();
		instructionPanel.setForeground(Color.BLACK);
		instructionPanel.setFont(new Font("Tahoma", Font.PLAIN, 16));
		instructionPanel.setEditable(false);
	}
	
	public JTextPane getInstrctionPanel() {
		return instructionPanel;
	}
	
	public void setInstruction(String instruction) {
		instructionPanel.setText(instruction);
	}
	
	public void clear() {
		instructionPanel.setText(STRING_NULL);
	}
}
```
###### simplyamazing\ui\ResizableUI.java
``` java
package simplyamazing.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JTextArea;

import simplyamazing.logic.Logic;

public class ResizableUI {
	private static final String MESSAGE_LOG_USER_COMMAND_EXECUTED = "user command is successfully executed.";
	private static final String MESSAGE_EMPTY_LIST = "List is empty";
	
	private static final Color COLOR_DARK_GREEN = new Color(0, 128, 0);

	private static final String CHARACTER_NEW_LINE = "\n";
	public static final String FIELD_SEPARATOR = ",";
	private static final String STRING_ERROR = "Error";
	
	private static Logger logger = Logger.getLogger("UI");
	
	private JFrame frame;
	private JPanel panel;
	private JSeparator separator, separator_1;
	private JTextArea txtrHeader;
	private JScrollPane scrollPane;
	private GridBagConstraints gbc;
	
	private static Logic logic;
	private static CommandBarController commandBarController;
	private static TaskDataPanel taskDataPanel;
	private static FeedbackArea feedbackArea;
	private static InstructionPanel instructionPanel;

	/**
	 * Launch the application.
	 */
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					ResizableUI window = new ResizableUI();
					window.frame.setVisible(true);
					commandBarController.getCommandBar().requestFocusInWindow();
					logic = new Logic();
					String taskDataString = window.getTaskData();
					if (taskDataString.contains(CHARACTER_NEW_LINE)) {
						window.updateTaskTable();
					} else {
						window.scrollPane.setVisible(false);
						feedbackArea.colorCodeFeedback(COLOR_DARK_GREEN);
						feedbackArea.setFeedback(taskDataString);
						logger.log(Level.INFO, taskDataString);
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}
	
	private static String getErrorMessage(Exception e) {
		return e.getMessage();
	}

	/**
	 * Create the application.
	 * @throws Exception 
	 */
	public ResizableUI() {
		initialize();
		addUIComponentsToFrame();
	}

	/**
	 * Initialize the contents of the frame.
	 */
	private void initialize() {
		setupFrame();
		setupPanels();
		setupAppLogo();
		setupFeedbackArea();
		setupCommandBar();
		setupScrollPane();
		setupSeparators();
	}

	private void setupScrollPane() {
		scrollPane = new JScrollPane();
		scrollPane.setBorder(BorderFactory.createEmptyBorder());
		//scrollPane.setBounds(10, 57, 664, 278);
	}

	private void addUIComponentsToFrame() {
		frame.getContentPane().add(panel, BorderLayout.CENTER);
		
		GridBagConstraints gbc_header = gbc;
		gbc_header.insets = new Insets(10,10,0,10);
		panel.add(txtrHeader, gbc_header);
		
		gbc.gridy++;
		gbc.insets = new Insets(10,10,0,10);
		panel.add(separator_1, gbc);
		
		gbc.gridy++;
		panel.add(scrollPane, gbc);
		
		gbc.gridy++;
		panel.add(separator, gbc);
		
		gbc.gridy++;
		panel.add(feedbackArea.getFeedbackArea(), gbc);
		
		gbc.gridy++;
		gbc.insets = new Insets(10,10,10,10);
		panel.add(commandBarController.getCommandBar(), gbc);
	}

	private void setupFeedbackArea() {
		feedbackArea = new FeedbackArea();
		feedbackArea.getFeedbackArea().setFont(new Font("Times New Roman", Font.PLAIN, 14));
	}

	private void setupInstructionPanel() {
		instructionPanel = new InstructionPanel();
	}
	
	private void setupTaskDataPanel(Object[][] taskData) {
		taskDataPanel = new TaskDataPanel(taskData);
	}

	private void setupAppLogo() {
		txtrHeader = new JTextArea();
		txtrHeader.setFont(new Font("Lucida Calligraphy", Font.BOLD, 16));
		txtrHeader.setEditable(false);
		txtrHeader.setText("Welcome to SimplyAmazing!");
		txtrHeader.setAlignmentX(Component.CENTER_ALIGNMENT);
		//txtrHeader.setBounds(203, 11, 278, 22);
	}

	private void setupSeparators() {
		separator = new JSeparator();
		//separator.setBounds(10, 379, 664, 2);
		separator_1 = new JSeparator();
		//separator_1.setBounds(10, 44, 664, 2);
	}

	private void setupCommandBar() {
		commandBarController = new CommandBarController();
		commandBarController.getCommandBar().setFont(new Font("Tahoma", Font.PLAIN, 16));
		commandBarController.handleKeyPressedEvent(this);
	}

	private void setupFrame() {
		frame = new JFrame();
		//frame.setBackground(Color.WHITE);
		frame.setForeground(Color.WHITE);
		frame.setBounds(100, 100, 683, 600);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
	
	private void setupPanels() {
		panel = new JPanel(new GridBagLayout());
		panel.setForeground(Color.WHITE);
		panel.setBackground(Color.WHITE);
		//panel.setPreferredSize(frame.getContentPane().getSize());
		
		gbc = new GridBagConstraints();
		gbc.gridx = 0;
		gbc.gridy = 0;
		gbc.weighty = 1;
		gbc.weightx = 1;
		gbc.fill = GridBagConstraints.BOTH;
	}

	public void executeUserCommand() {
		String feedback = null;
		String command = commandBarController.getCommand();
		feedbackArea.clear();
		try {
			feedback = logic.executeCommand(command);
			logger.log(Level.INFO, MESSAGE_LOG_USER_COMMAND_EXECUTED);
			if (feedback.contains(CHARACTER_NEW_LINE)) {
				String[] tasks = feedback.split(CHARACTER_NEW_LINE);
				
				if (tasks[0].split(FIELD_SEPARATOR).length == 6) {
					String[][] taskData = new String[tasks.length][6];
					for (int i = 0; i < tasks.length; i++) {
						taskData[i] = tasks[i].split(FIELD_SEPARATOR);
					}
					scrollPane.setVisible(true);
					setupTaskDataPanel(taskData); 
					scrollPane.setViewportView(taskDataPanel.getTaskDataPanel());
					scrollPane.getViewport().setBackground(Color.WHITE);
				} else {
					setupInstructionPanel();
					scrollPane.setVisible(true);
					scrollPane.setViewportView(instructionPanel.getInstrctionPanel());
					instructionPanel.setInstruction(feedback);
				}
			} else { // only feedback
				if (getTaskData().contains(CHARACTER_NEW_LINE)) {
					updateTaskTable();
				} 
				if (feedback.contains(STRING_ERROR)) {
					feedbackArea.colorCodeFeedback(Color.RED);
					logger.log(Level.WARNING, feedback);
				} else {
					if (feedback.matches(MESSAGE_EMPTY_LIST)) {
						scrollPane.setVisible(false);
					}
					feedbackArea.colorCodeFeedback(COLOR_DARK_GREEN);
					logger.log(Level.INFO, feedback);
				}
				feedbackArea.setFeedback(feedback);
			}
			commandBarController.clear(); 
		} catch (Exception e1) {
			feedback = getErrorMessage(e1);
			logger.log(Level.WARNING, feedback);
			feedbackArea.colorCodeFeedback(Color.RED);
			feedbackArea.setFeedback(feedback);
		}
	}
	
	private void updateTaskTable() throws Exception {
		String[] tasks = getTaskData().split(CHARACTER_NEW_LINE);
		
		String[][] taskData = new String[tasks.length][6];
		for (int i = 0; i < tasks.length; i++) {
			taskData[i] = tasks[i].split(FIELD_SEPARATOR);
		}
		setupTaskDataPanel(taskData); 
		scrollPane.setVisible(true);
		scrollPane.setViewportView(taskDataPanel.getTaskDataPanel());
		scrollPane.getViewport().setBackground(Color.WHITE);
	}

	private String getTaskData() throws Exception {
		String taskDataString = logic.getView();
		return taskDataString;
	}

	public void getUserCommand() {
		String command = logic.getPreviousCommand();
		commandBarController.setCommand(command);
	}
}
```
###### simplyamazing\ui\TaskDataPanel.java
``` java
package simplyamazing.ui;

import java.awt.Color;
import java.awt.Font;

import javax.swing.BorderFactory;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumnModel;

public class TaskDataPanel {
	private JTable taskDataTable;
	
	private Object columnNames[] = { "#", "Description", "Start time", "End time", "Priority", "Status"};
	
	public TaskDataPanel(Object[][] rowData) {
		DefaultTableModel model = new DefaultTableModel(rowData, columnNames);
		taskDataTable = new JTable(model);
		taskDataTable.setToolTipText("Task Data will be shown here.");
		taskDataTable.setBackground(Color.WHITE);
		taskDataTable.setForeground(Color.BLACK);
		taskDataTable.setRowHeight(30);
		taskDataTable.setFont(new Font("Tahoma", Font.PLAIN, 16));
		taskDataTable.setEnabled(false);
		taskDataTable.getTableHeader().setBackground(Color.WHITE);
		taskDataTable.getTableHeader().setBorder(BorderFactory.createEtchedBorder());
		taskDataTable.getTableHeader().setFont(new Font("Times New Roman", Font.BOLD, 15));
		taskDataTable.setBorder(BorderFactory.createEtchedBorder());
		taskDataTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		TableColumnModel columnModel = taskDataTable.getColumnModel();
		columnModel.getColumn(0).setPreferredWidth(29);
		columnModel.getColumn(1).setPreferredWidth(220);
		columnModel.getColumn(2).setPreferredWidth(150);
		columnModel.getColumn(3).setPreferredWidth(150);
		columnModel.getColumn(4).setPreferredWidth(60);
		columnModel.getColumn(5).setPreferredWidth(50);
	}
	
	public JTable getTaskDataPanel() {
		return taskDataTable;
	}
	
	public void clear() {
		taskDataTable.setVisible(false);
	}
}
```
###### simplyamazing\ui\UI.java
``` java
package simplyamazing.ui;

import java.awt.Color;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.SystemColor;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JTextArea;

import simplyamazing.logic.Logic;

public class UI {
	private static final String MESSAGE_LOG_USER_COMMAND_EXECUTED = "user command is successfully executed.";
	private static final String MESSAGE_EMPTY_LIST = "List is empty";
	
	private static final Color COLOR_DARK_GREEN = new Color(0, 128, 0);

	private static final String CHARACTER_NEW_LINE = "\n";
	public static final String FIELD_SEPARATOR = ",";
	private static final String STRING_ERROR = "Error";
	
	private static Logger logger = Logger.getLogger("UI");
	
	private JFrame frame;
	private JSeparator separator, separator_1;
	private JTextArea txtrHeader;
	private JScrollPane scrollPane;
	
	private static Logic logic;
	private static CommandBarController commandBarController;
	private static TaskDataPanel taskDataPanel;
	private static FeedbackArea feedbackArea;
	private static InstructionPanel instructionPanel;

	/**
	 * Launch the application.
	 */
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					UI window = new UI();
					window.frame.setVisible(true);
					commandBarController.getCommandBar().requestFocusInWindow();
					logic = new Logic();
					String taskDataString = window.getTaskData();
					if (taskDataString.contains(CHARACTER_NEW_LINE)) {
						window.updateTaskTable();
					} else {
						window.scrollPane.setVisible(false);
						feedbackArea.colorCodeFeedback(COLOR_DARK_GREEN);
						feedbackArea.setFeedback(taskDataString);
						logger.log(Level.INFO, taskDataString);
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}
	
	private static String getErrorMessage(Exception e) {
		return e.getMessage();
	}

	/**
	 * Create the application.
	 * @throws Exception 
	 */
	public UI() {
		initialize();
		addUIComponentsToFrame();
	}

	/**
	 * Initialize the contents of the frame.
	 */
	private void initialize() {
		setupFrame();
		setupAppLogo();
		setupFeedbackArea();
		setupCommandBar();
		setupScrollPane();
		setupSeparators();
	}

	private void setupScrollPane() {
		scrollPane = new JScrollPane();
		scrollPane.setBorder(BorderFactory.createEmptyBorder());
		scrollPane.setBounds(10, 57, 664, 278);
	}

	private void addUIComponentsToFrame() {
		frame.getContentPane().add(txtrHeader);
		frame.getContentPane().add(separator_1);
		frame.getContentPane().add(scrollPane);
		frame.getContentPane().add(separator);
		frame.getContentPane().add(feedbackArea.getFeedbackArea());
		frame.getContentPane().add(commandBarController.getCommandBar());
	}

	private void setupFeedbackArea() {
		feedbackArea = new FeedbackArea();
		feedbackArea.getFeedbackArea().setBounds(10, 346, 664, 22);
	}

	private void setupInstructionPanel() {
		instructionPanel = new InstructionPanel();
		instructionPanel.getInstrctionPanel().setBounds(10, 57, 664, 311);
	}
	
	private void setupTaskDataPanel(Object[][] taskData) {
		taskDataPanel = new TaskDataPanel(taskData);
	}

	private void setupAppLogo() {
		txtrHeader = new JTextArea();
		txtrHeader.setFont(new Font("Lucida Calligraphy", Font.BOLD, 16));
		txtrHeader.setEditable(false);
		txtrHeader.setText("Welcome to SimplyAmazing!");
		txtrHeader.setBounds(208, 11, 278, 22);
	}

	private void setupSeparators() {
		separator = new JSeparator();
		separator.setBounds(10, 379, 664, 2);
		separator_1 = new JSeparator();
		separator_1.setBounds(10, 44, 664, 2);
	}

	private void setupCommandBar() {
		commandBarController = new CommandBarController();
		commandBarController.getCommandBar().setBounds(10, 392, 664, 33);
		commandBarController.handleKeyPressedEvent(this);
	}

	private void setupFrame() {
		frame = new JFrame();
		frame.setResizable(false);
		frame.setForeground(new Color(255, 255, 255));
		frame.getContentPane().setBackground(SystemColor.window);
		frame.setBounds(100, 100, 700, 475);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.getContentPane().setLayout(null);
	}

	public void executeUserCommand() {
		String feedback = null;
		String command = commandBarController.getCommand();
		feedbackArea.clear();
		try {
			feedback = logic.executeCommand(command);
			logger.log(Level.INFO, MESSAGE_LOG_USER_COMMAND_EXECUTED);
			
			if (feedback.contains(CHARACTER_NEW_LINE)) {
				String[] tasks = feedback.split(CHARACTER_NEW_LINE);
				
				if (tasks[0].split(FIELD_SEPARATOR).length == 6) {
					String[][] taskData = new String[tasks.length][6];
					for (int i = 0; i < tasks.length; i++) {
						taskData[i] = tasks[i].split(FIELD_SEPARATOR);
					}
					scrollPane.setVisible(true);
					setupTaskDataPanel(taskData); 
					scrollPane.setViewportView(taskDataPanel.getTaskDataPanel());
					scrollPane.getViewport().setBackground(Color.WHITE);
				} else {
					setupInstructionPanel();
					scrollPane.setVisible(true);
					scrollPane.setViewportView(instructionPanel.getInstrctionPanel());
					instructionPanel.setInstruction(feedback);
				}
			} else { // only feedback
				if (getTaskData().contains(CHARACTER_NEW_LINE)) {
					updateTaskTable();
				} 
				if (feedback.contains(STRING_ERROR)) {
					feedbackArea.colorCodeFeedback(Color.RED);
					logger.log(Level.WARNING, feedback);
				} else {
					if (feedback.matches(MESSAGE_EMPTY_LIST)) {
						scrollPane.setVisible(false);
					}
					feedbackArea.colorCodeFeedback(COLOR_DARK_GREEN);
					logger.log(Level.INFO, feedback);
				}
				feedbackArea.setFeedback(feedback);
			}
			commandBarController.clear(); 
		} catch (Exception e1) {
			feedback = getErrorMessage(e1);
			logger.log(Level.WARNING, feedback);
			feedbackArea.colorCodeFeedback(Color.RED);
			feedbackArea.setFeedback(feedback);
		}
	}
	
	private void updateTaskTable() throws Exception {
		String[] tasks = getTaskData().split(CHARACTER_NEW_LINE);
		
		String[][] taskData = new String[tasks.length][6];
		for (int i = 0; i < tasks.length; i++) {
			taskData[i] = tasks[i].split(FIELD_SEPARATOR);
		}
		setupTaskDataPanel(taskData); 
		scrollPane.setVisible(true);
		scrollPane.setViewportView(taskDataPanel.getTaskDataPanel());
		scrollPane.getViewport().setBackground(Color.WHITE);
	}

	private String getTaskData() throws Exception {
		String taskDataString = logic.getView();
		return taskDataString;
	}

	public void getUserCommand() {
		String command = logic.getPreviousCommand();
		commandBarController.setCommand(command);
	}
}
```
###### test\StorageTest.java
``` java
package test;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.util.Date;

import org.junit.Test;

import simplyamazing.data.Task;
import simplyamazing.storage.Storage;

public class StorageTest {
	
	private static final String DIRECTORY_SYSTEM = "C:\\Users\\Public\\SimplyAmzing";
	private static final String FILENAME_STORAGE = "\\storage.txt";
	private static final String FILENAME_TODO = "\\todo.txt";
	private static final String FILENAME_DONE = "\\done.txt";
	private static final String FILENAME_TODO_BACKUP = "\\todoBackup.txt";
	private static final String FILENAME_DONE_BACKUP = "\\doneBackup.txt";
	
	private static final String PARAM_DESCRIPTION1 = "go gym";
	private static final String PARAM_DESCRIPTION = "go swimming";
	private static final String PARAM_PRIORITY = "high";
	private static final String PARAM_END_TIME = "15:00 16 May 2016";
	private static final String PARAM_END_TIME1 = "15:00 20 May 2016";
	private static final String PARAM_END_TIME2 = "15:00 27 May 2016";
	private static final String PARAM_END_TIME3 = "15:00 31 May 2016";
	private static final String PARAM_START_TIME = "13:00 16 May 2016";
	private static final String PARAM_START_TIME1 = "13:00 20 May 2016";
	private static final String PARAM_SET_LOCATION_NULL = null;
	private static final String PARAM_SET_LOCATION_EMPTY = "";
	private static final String PARAM_SET_LOCATION_NOT_DIRECTORY = "C:\\Users\\Public\\Documents\\SimplyAmazing";
	private static final String PARAM_SET_LOCATION_DIRECTORY = "C:\\Users\\Public\\Documents";
	private static final String PARAM_VIEW_TASKS_NULL = null;
	private static final String PARAM_VIEW_TASKS_EMPTY = "";
	private static final String PARAM_VIEW_TASKS_EVENTS = "events";
	private static final String PARAM_VIEW_TASKS_DEADLINES = "deadlines";
	private static final String PARAM_VIEW_TASKS_FLOATING = "tasks";
	private static final String PARAM_VIEW_TASKS_OVERDUE = "overdue";
	private static final String PARAM_VIEW_TASKS_DONE = "done";
	private static final String PARAM_VIEW_TASKS_OTHERS = "other";
	private static final String PARAM_SEARCH_TASKS_NULL = null;
	private static final String PARAM_SEARCH_TASKS_EMPTY = "";
	private static final String PARAM_SEARCH_TASKS_KEYWORD = "gym";
	private static final String PARAM_SEARCH_TASKS_MORE_KEYWORD = "go gym";
	private static final String PARAM_RESTORE_NULL = null;
	private static final String PARAM_RESTORE_EMPTY = "";
	private static final String PARAM_RESTORE_COMMAND = "done 1";
	
	private static final String FEEDBACK_LOCATION_SET = "Storage location of task data has been sucessfully set as %1$s.";
	private static final String FEEDBACK_ADDED = "%1$s has been added.";
	private static final String FEEDBACK_UPDATED = "%1$s has been successfully updated.";
	private static final String FEEDBACK_MARKED_DONE = "%1$s has been marked as done.";
	private static final String FEEDBACK_DELETED = "%1$s has been successfully deleted.";
	private static final String FEEDBACK_RESTORED = "\"%1$s\" command has been successfully undone.";
	
	/*
	 * Operation to test: setLocation(String location): String
	 * Equivalence partition: 
	 * location: [null] [not null] [not a valid directory] [a valid directory] 
	 * Boundary values: Empty String, a String of some length
	 */	
	@Test(expected = Exception.class) 
	public void testSetLocationMethodForException() throws Exception {
		Storage storage = new Storage();
		
		/* This is for the first launch of program where user hasn't set the storage location */
		File location = new File(DIRECTORY_SYSTEM+FILENAME_STORAGE);
		storage.getFileManager().createNewFile(location);
		
		/* This is for the not a valid directory partition */
		storage.setLocation(PARAM_SET_LOCATION_NOT_DIRECTORY);
	}
	
	@Test(expected = Exception.class) 
	public void testSetLocationMethodForAssertionError() throws Exception {
		Storage storage = new Storage();
		
		/* This is for the first launch of program where user hasn't set the storage location */
		File location = new File(DIRECTORY_SYSTEM+FILENAME_STORAGE);
		storage.getFileManager().createNewFile(location);
		
		/* This is for the null partition */
		storage.setLocation(PARAM_SET_LOCATION_NULL);
			
		/* This is a boundary case for the not null partition */
		storage.setLocation(PARAM_SET_LOCATION_EMPTY);
	}
	
	@Test
	public void testSetLocationMethod() throws Exception {
		Storage storage = new Storage();
		
		/* This is for the first launch of program where user hasn't set the storage location */
		File location = new File(DIRECTORY_SYSTEM+FILENAME_STORAGE);
		if (storage.getFileManager().isFileExisting(location)) {
			location.delete();
		}
		assertEquals(false, storage.getFileManager().isFileExisting(location));
		
		/* This is for the a valid directory partition */
		assertEquals(String.format(FEEDBACK_LOCATION_SET, PARAM_SET_LOCATION_DIRECTORY), storage.setLocation(PARAM_SET_LOCATION_DIRECTORY));
		assertEquals(PARAM_SET_LOCATION_DIRECTORY, storage.getLocation());
		assertEquals(1, storage.getFileManager().getLineCount(location));
	}
	
	/*
	 * Operation to test: addTask(Task task): String
	 * Equivalence partition: 
	 * task: [null] [not null] 
	 */	
	@Test(expected = Exception.class) 
	public void testAddTaskMethodForException() throws Exception {
		Storage storage = new Storage();
		
		/* This is for the successive launch of program where user has set the storage location before */
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = null;
		
		try {	
			/* This is for the null partition */
			storage.addTask(task);
		} catch (AssertionError ae) {
			throw new Exception();
		}
	}
	
	@Test
	public void testAddTaskMethod() throws Exception {
		Storage storage = new Storage();
		
		/* This is for the first launch of program where user hasn't set the storage location */
		File location = new File(DIRECTORY_SYSTEM+FILENAME_STORAGE);
		storage.getFileManager().createNewFile(location);
		
		File todo = new File(DIRECTORY_SYSTEM+FILENAME_TODO);
		File done = new File(DIRECTORY_SYSTEM+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = new Task(PARAM_DESCRIPTION);
		
		/* This is for the not null partition */
		assertEquals(0, storage.getTaskList().getTasks().size());
		assertEquals(0, storage.getFileManager().getLineCount(todo));
		assertEquals(String.format(FEEDBACK_ADDED, task.toFilteredString()), storage.addTask(task));
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(1, storage.getFileManager().getLineCount(todo));
	}

	/*
	 * Operation to test: editTask(Task task, Task editedTask): String
	 * Equivalence partition: 
	 * task: [null] [not null] 
	 * editedTask: [null] [not null]
	 */	
	@Test(expected = Exception.class) 
	public void testEditTaskMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = null, editedTask = null;
		try {	
			/* This is for the task_null partition */
			storage.editTask(task, editedTask);
			
			task = new Task(PARAM_DESCRIPTION);
			
			/* This is for the editedTask_null partition */
			storage.editTask(task, editedTask);	
		} catch (AssertionError ae) {
			throw new Exception();
		}
	}
	
	@Test
	public void testEditTaskMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		
		/* This is for program run where user hasn't added any task */
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		todo.delete();
		done.delete();
		storage.addTask(new Task(PARAM_DESCRIPTION));
		Task task = new Task(PARAM_DESCRIPTION), editedTask = new Task(PARAM_DESCRIPTION1, PARAM_START_TIME, PARAM_END_TIME);
		editedTask.setPriority(PARAM_PRIORITY);
		
		// This is for the not null partition 
		assertEquals(String.format(FEEDBACK_UPDATED, editedTask.toFilteredString()), storage.editTask(task, editedTask));
	}
	
	/*
	 * Operation to test: viewTasks(String taskType): ArrayList<Task>
	 * Equivalence partition: 
	 * taskType: [null] [empty String] ["events"] ["deadlines"] ["tasks"] ["overdue"] ["done"] [any other string] 
	 */	
	@Test(expected = Exception.class) 
	public void testViewTasksMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		/* This is for the null partition */
		storage.viewTasks(PARAM_VIEW_TASKS_NULL);
		
		/* This is for the any other String partition */
		storage.viewTasks(PARAM_VIEW_TASKS_OTHERS);
	}
	
	@Test
	public void testViewTasksMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		storage.addTask(new Task(PARAM_DESCRIPTION1)); // floating task
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME)); // deadline
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_START_TIME, PARAM_END_TIME)); // event
		storage.addTask(new Task(PARAM_DESCRIPTION1, Task.convertDateToString(new Date(), Task.TIME_FORMAT), Task.convertDateToString(new Date(), Task.TIME_FORMAT))); // overdue
		assertEquals(4, storage.getFileManager().getLineCount(todo));
		assertEquals(4, storage.getTaskList().getTasks().size());
		
		// This is for the empty String partition 
		assertEquals(3, storage.viewTasks(PARAM_VIEW_TASKS_EMPTY).size());	
		
		// This is for the events partition 
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_EVENTS).size());
		
		// This is for the deadlines partition 
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_DEADLINES).size());
		
		// This is for the tasks partition 
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_FLOATING).size());	
		
		// This is for the overdue partition 
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_OVERDUE).size());
		
		// This is for the done partition 
		assertEquals(0, storage.viewTasks(PARAM_VIEW_TASKS_DONE).size());		
	}
	
	/*
	 * Operation to test: searchTasks(String keyword): ArrayList<Task>
	 * Equivalence partition: 
	 * keyword: [null] [not null]
	 * Boundary values: Empty String, a String of some length
	 */	
	@Test(expected = Exception.class) 
	public void testSearchTasksMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		try {
			/* This is for the null partition */
			storage.searchTasks(PARAM_SEARCH_TASKS_NULL);
		} catch(AssertionError ae) {
			throw new Exception();
		}
	}
	
	@Test
	public void testSearchTasksMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		storage.addTask(new Task(PARAM_DESCRIPTION));
		storage.addTask(new Task(PARAM_DESCRIPTION1));
		assertEquals(2, storage.getTaskList().getTasks().size());
		assertEquals(2, storage.getFileManager().getLineCount(todo));
		
		// This is a boundary case for the not null partition 
		assertEquals(2, storage.searchTasks(PARAM_SEARCH_TASKS_EMPTY).size());
		
		// These are for the not null partition 
		assertEquals(1, storage.searchTasks(PARAM_SEARCH_TASKS_KEYWORD).size());
		assertEquals(2, storage.searchTasks(PARAM_SEARCH_TASKS_MORE_KEYWORD).size());
	}
	
	@Test
	public void testSearchTasksByDateMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME2)); // deadline
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME3)); // deadline
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_START_TIME, PARAM_END_TIME)); // event
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_START_TIME1, PARAM_END_TIME1)); // event
		assertEquals(4, storage.getTaskList().getTasks().size());
		assertEquals(4, storage.getFileManager().getLineCount(todo));
		
		// These are for the not null partition 
		assertEquals(4, storage.searchTasksByDate(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME).getEndTime()).size());
		assertEquals(3, storage.searchTasksByDate(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME1).getEndTime()).size());
		assertEquals(2, storage.searchTasksByDate(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME2).getEndTime()).size());
		assertEquals(1, storage.searchTasksByDate(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME3).getEndTime()).size());
	}
	
	/*
	 * Operation to test: markTaskDone(Task task): String
	 * Equivalence partition: 
	 * task: [null] [not null] [already done] 
	 */	
	@Test(expected = Exception.class) 
	public void testMarkTaskDoneMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = null;
		
		// This is for the null partition 
		storage.markTaskDone(task);
	}
	
	@Test(expected = Exception.class) 
	public void testMarkTaskDoneMethodForDoneTaskException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		storage.addTask(new Task(PARAM_DESCRIPTION1));
		Task task = new Task(PARAM_DESCRIPTION1);
		
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		assertEquals(0, storage.getFileManager().getLineCount(done));
		storage.markTaskDone(task);
		
		// This is for the already done partition 
		storage.markTaskDone(task);
	}
	
	@Test
	public void testMarkTaskDoneMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		storage.addTask(new Task(PARAM_DESCRIPTION));
		Task task = new Task(PARAM_DESCRIPTION);
		
		// This is for the not null partition
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		assertEquals(0, storage.getTaskList().getCompletedTasks().size());
		assertEquals(0, storage.getFileManager().getLineCount(done));
		assertEquals(String.format(FEEDBACK_MARKED_DONE, task.toFilteredString()), storage.markTaskDone(task));	
		assertEquals(1, storage.getFileManager().getLineCount(done));
		
		task = new Task(PARAM_DESCRIPTION1);
		storage.addTask(new Task(PARAM_DESCRIPTION1));
		assertEquals(String.format(FEEDBACK_MARKED_DONE, task.toFilteredString()), storage.markTaskDone(task));	
		assertEquals(2, storage.getFileManager().getLineCount(done));
	}
	
	/*
	 * Operation to test: deleteTask(Task task): String
	 * Equivalence partition: 
	 * task: [null] [not null]
	 */	
	@Test(expected = Exception.class) 
	public void testDeleteTaskMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = null;
		
		/* This is for the 'null' partition */
		storage.deleteTask(task);
	}	
	
	@Test
	public void testDeleteTaskMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		File todoBackup = new File(DIRECTORY_SYSTEM+FILENAME_TODO_BACKUP);
		File doneBackup = new File(DIRECTORY_SYSTEM+FILENAME_DONE_BACKUP);
		todoBackup.delete();
		doneBackup.delete();
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		storage.addTask(new Task(PARAM_DESCRIPTION));
		Task task = new Task(PARAM_DESCRIPTION);
		
		// This is for the 'not null' partition 
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(String.format(FEEDBACK_DELETED, task.toFilteredString()), storage.deleteTask(task));
		assertEquals(0, storage.getTaskList().getCompletedTasks().size());
	}
	
	/*
	 * Operation to test: restore(String previousCommand): String
	 * Equivalence partition: 
	 * previousCommand: [null] [not null] 
	 * Boundary values: Empty String, a String of some length
	 */	
	@Test(expected = Exception.class) 
	public void testRestoreMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		try {
			/* This is for the null partition */
			storage.restore(PARAM_RESTORE_NULL);
			
			/* This is a boundary case for the not null partition */
			storage.restore(PARAM_RESTORE_EMPTY);
		} catch (AssertionError ae) {
			throw new Exception();
		}
		
		/* This is for the not a valid directory partition */
		storage.setLocation(PARAM_SET_LOCATION_NOT_DIRECTORY);
	}
	
	@Test
	public void testRestoreMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = new Task(PARAM_DESCRIPTION);
		
		assertEquals(0, storage.getTaskList().getTasks().size());
		assertEquals(0, storage.getFileManager().getLineCount(todo));
		assertEquals(0, storage.getFileManager().getLineCount(done));
		storage.addTask(task);
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		assertEquals(0, storage.getFileManager().getLineCount(done));
		
		
		storage.markTaskDone(task);	
		assertEquals(0, storage.getFileManager().getLineCount(todo));
		assertEquals(1, storage.getFileManager().getLineCount(done));
		
		assertEquals(String.format(FEEDBACK_RESTORED, PARAM_RESTORE_COMMAND), storage.restore(PARAM_RESTORE_COMMAND));
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		assertEquals(0, storage.getFileManager().getLineCount(done));
	}
}
```
###### test\SystemTest.java
``` java
package test;

import static org.junit.Assert.*;

import java.io.File;
import java.util.Date;

import org.junit.Test;

import simplyamazing.data.Task;
import simplyamazing.logic.Logic;
import simplyamazing.parser.Parser;
import simplyamazing.storage.Storage;

public class SystemTest {

	private static final String DIRECTORY_SYSTEM = "C:\\Users\\Public\\SimplyAmzing";
	private static final String FILENAME_STORAGE = "\\storage.txt";
	private static final String FILENAME_TODO = "\\todo.txt";
	private static final String FILENAME_DONE = "\\done.txt";
	
	private static final String CHARACTER_SPACE = " ";
	
	private static final String COMMAND_NULL = null;
	private static final String COMMAND_EMPTY = "";
	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_DELETE = "delete";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_VIEW = "view";
	private static final String COMMAND_SEARCH = "search";
	private static final String COMMAND_HELP = "help";
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_SET_LOCATION = "location";
	private static final String COMMAND_MARK_AS_DONE = "done";
	private static final String COMMAND_EXIT = "exit";
	private static final String COMMAND_INVALID = "abcd";
	
	private static final String TASK_TYPE_EVENTS = "events";
	private static final String TASK_TYPE_DEADLINES = "deadlines";
	private static final String TASK_TYPE_FLOATING = "tasks";
	private static final String TASK_TYPE_OVERDUE = "overdue";
	private static final String TASK_TYPE_DONE = "done";
	private static final String TASK_TYPE_OTHER = "other";
	
	private static final String COMMAND_SET_LOCATION_EMPTY = COMMAND_SET_LOCATION;
	private static final String COMMAND_SET_LOCATION_NOT_DIRECTORY = COMMAND_SET_LOCATION + CHARACTER_SPACE + "C:\\Users\\Public\\Documents\\SimplyAmazing";
	private static final String COMMAND_SET_LOCATION_DIRECTORY = COMMAND_SET_LOCATION + CHARACTER_SPACE + "C:\\Users\\Public\\Documents";
	private static final String COMMAND_ADD_TASK_EMPTY = COMMAND_ADD;
	private static final String COMMAND_ADD_TASK_WITH_PASSED_DEADLINE = COMMAND_ADD + CHARACTER_SPACE + "sleep by 3:00 24 Mar 2016";;
	private static final String COMMAND_ADD_TASK_WITH_STARTIME_ONLY = COMMAND_ADD + CHARACTER_SPACE + "sleep from 13:00 24 May 2017";
	private static final String COMMAND_ADD_TASK_WITH_STARTIME_AFTER_ENDTIME = COMMAND_ADD + CHARACTER_SPACE + "sleep from 10:00 24 May 2017 to 8:00 24 May 2017";
	private static final String COMMAND_ADD_FLOATING_TASK = COMMAND_ADD + CHARACTER_SPACE + "hello world";
	private static final String COMMAND_ADD_FLOATING_TASK_WITH_KEYWORDS = COMMAND_ADD + CHARACTER_SPACE + "drop by post office to deliver parcel received from Lndon";
	private static final String COMMAND_ADD_DEADLINE = COMMAND_ADD + CHARACTER_SPACE + "cs2103 peer review by 23:59 25 May 2017";
	private static final String COMMAND_ADD_DEADLINE_WITH_KEYWORDS = COMMAND_ADD + CHARACTER_SPACE + "drop by post office to deliver parcel received from Landon by 23:59 25 May 2017";
	private static final String COMMAND_ADD_EVENT = COMMAND_ADD + CHARACTER_SPACE + "hackathon in SOC from 09:30 26 May 2017 to 10:00 27 May 2017";
	private static final String COMMAND_ADD_EVENT_WITH_KEYWORDS = COMMAND_ADD + CHARACTER_SPACE + "drop by post office to deliver parcel received from Landon from 09:30 26 May 2017 to 10:00 27 May 2017";
	private static final String COMMAND_VIEW_TASKS_EMPTY = COMMAND_VIEW;
	private static final String COMMAND_VIEW_TASKS_EVENTS = COMMAND_VIEW + CHARACTER_SPACE + TASK_TYPE_EVENTS;
	private static final String COMMAND_VIEW_TASKS_DEADLINES = COMMAND_VIEW + CHARACTER_SPACE + TASK_TYPE_DEADLINES;
	private static final String COMMAND_VIEW_TASKS_FLOATING = COMMAND_VIEW + CHARACTER_SPACE + TASK_TYPE_FLOATING;
	private static final String COMMAND_VIEW_TASKS_OVERDUE = COMMAND_VIEW + CHARACTER_SPACE + TASK_TYPE_OVERDUE;
	private static final String COMMAND_VIEW_TASKS_DONE = COMMAND_VIEW + CHARACTER_SPACE + TASK_TYPE_DONE;
	private static final String COMMAND_VIEW_TASKS_OTHERS = COMMAND_VIEW + CHARACTER_SPACE + "other";
	private static final String COMMAND_SEARCH_TASKS_EMPTY = COMMAND_SEARCH;
	private static final String COMMAND_SEARCH_TASKS_KEYWORD =  COMMAND_SEARCH + CHARACTER_SPACE + "hello";
	private static final String COMMAND_SEARCH_TASKS_OTHER_KEYWORD =  COMMAND_SEARCH + CHARACTER_SPACE + "other";
	private static final String COMMAND_RESTORE_EMPTY = "";
	private static final String COMMAND_RESTORE = "restore";
	
	private static final String PARAM_SET_LOCATION_DIRECTORY = "C:\\Users\\Public\\Documents";
	private static final String PARAM_DESCRIPTION = "go swimming";
	private static final String PARAM_VIEW_TASKS_EMPTY = "";
	private static final String PARAM_VIEW_TASKS_EVENTS = "events";
	private static final String PARAM_VIEW_TASKS_DEADLINES = "deadlines";
	private static final String PARAM_VIEW_TASKS_FLOATING = "tasks";
	private static final String PARAM_VIEW_TASKS_OVERDUE = "overdue";
	private static final String PARAM_VIEW_TASKS_DONE = "done";
	private static final String PARAM_VIEW_TASKS_OTHERS = "other";
	private static final String PARAM_SEARCH_TASKS_EMPTY = "";
	private static final String PARAM_SEARCH_TASKS_KEYWORD = "gym";
	private static final String PARAM_RESTORE_EMPTY = "";
	private static final String PARAM_RESTORE_COMMAND = "delete 1";
	
	private static final String FEEDBACK_LOCATION_SET = "Storage location of task data has been sucessfully set as %1$s.";
	private static final String FEEDBACK_LOCATION_INVALID = "Error: Location provided is invalid";
	private static final String FEEDBACK_LOCATION_NOT_DIRECTORY = "Error: Not a valid directory.";
	private static final String FEEDBACK_ADDED = "%1$s has been added.";
	private static final String FEEDBACK_ADD_TASK_FIELDS_NOT_CORRECT = "Error: Please ensure the fields are correct";
	private static final String FEEDBACK_ADD_TASK_TIME_FORMAT_INVALID ="Error: Please ensure the time format is valid. Please use the \"help\"command to view the format";
	private static final String FEEDBACK_ADD_TASK_START_AFTER_END ="Error: Start date and time cannot be after the End date and time";
	private static final String FEEDBACK_ADD_TASK_DATE_BEFORE_CURRENT ="Error: Time provided must be after the current time";
	private static final String FEEDBACK_UPDATED = "%1$s has been successfully updated.";
	private static final String FEEDBACK_MARKED_DONE = "%1$s has been marked as done.";
	private static final String FEEDBACK_DELETED = "%1$s has been successfully deleted.";
	private static final String FEEDBACK_RESTORED = "\"%1$s\" command has been successfully undone.";
	private static final Object FEEDBACK_EMPTY_LIST = "List is empty";
	private static final Object FEEDBACK_NO_TASK_FOUND = "Error: There are no tasks containing the given keyword";
	
	
	/*
	 * Operation to test: executeCommand(String command): String
	 * Equivalence partition: 
	 * command: [null] [not null] [valid] [not valid]
	 * Boundary values: Empty String, a String of some length
	 */	
	@Test(expected = Exception.class) 
	public void testInvalidCommandsForException() throws Exception {
		Logic logic = new Logic();
		try {
			/* This is for the null partition */
			logic.executeCommand(COMMAND_NULL);
		} catch (AssertionError ae) {
			throw new Exception();
		}
		
		try {
			/* This is a boundary case for the not null partition */
			logic.executeCommand(COMMAND_EMPTY);
		} catch (AssertionError ae) {
			throw new Exception();
		}
		
		/* This is for the not valid partition */
		logic.executeCommand(COMMAND_INVALID);
	}
	
	@Test
	public void testSetLocationCommand() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		/* This is for the not valid partition */
		assertEquals(true, parser.getHandler(COMMAND_SET_LOCATION_EMPTY).getHasError());
		assertEquals(COMMAND_SET_LOCATION, parser.getHandler(COMMAND_SET_LOCATION_EMPTY).getCommandType());
		assertEquals(FEEDBACK_LOCATION_INVALID, logic.executeCommand(COMMAND_SET_LOCATION_EMPTY));
		
		/* This is for the not valid partition */
		assertEquals(COMMAND_SET_LOCATION, parser.getHandler(COMMAND_SET_LOCATION_NOT_DIRECTORY).getCommandType());
		assertEquals(FEEDBACK_LOCATION_NOT_DIRECTORY, logic.executeCommand(COMMAND_SET_LOCATION_NOT_DIRECTORY));
		
		/* This is for the valid partition */
		assertEquals(false, parser.getHandler(COMMAND_SET_LOCATION_DIRECTORY).getHasError());
		assertEquals(COMMAND_SET_LOCATION, parser.getHandler(COMMAND_SET_LOCATION_DIRECTORY).getCommandType());
		assertEquals(String.format(FEEDBACK_LOCATION_SET, PARAM_SET_LOCATION_DIRECTORY), logic.executeCommand(COMMAND_SET_LOCATION_DIRECTORY));
		assertEquals(PARAM_SET_LOCATION_DIRECTORY, storage.getLocation());
	}
	
	@Test
	public void testAddTaskCommand() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		/* This is for the first launch of program where user hasn't set the storage location */
		File location = new File(DIRECTORY_SYSTEM+FILENAME_STORAGE);
		storage.getFileManager().createNewFile(location);
		File todo = new File(DIRECTORY_SYSTEM+FILENAME_TODO);
		File done = new File(DIRECTORY_SYSTEM+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		assertEquals(0, storage.getFileManager().getLineCount(todo));
		
		/* These are for the invalid partition */
		assertEquals(true, parser.getHandler(COMMAND_ADD_TASK_EMPTY).getHasError());
		assertEquals(FEEDBACK_ADD_TASK_FIELDS_NOT_CORRECT, logic.executeCommand(COMMAND_ADD_TASK_EMPTY));
		
		assertEquals(true, parser.getHandler(COMMAND_ADD_TASK_WITH_PASSED_DEADLINE).getHasError());
		assertEquals(FEEDBACK_ADD_TASK_DATE_BEFORE_CURRENT, logic.executeCommand(COMMAND_ADD_TASK_WITH_PASSED_DEADLINE));
		
		assertEquals(true, parser.getHandler(COMMAND_ADD_TASK_WITH_STARTIME_ONLY).getHasError());
		assertEquals(FEEDBACK_ADD_TASK_FIELDS_NOT_CORRECT, logic.executeCommand(COMMAND_ADD_TASK_WITH_STARTIME_ONLY));
		
		assertEquals(true, parser.getHandler(COMMAND_ADD_TASK_WITH_STARTIME_AFTER_ENDTIME).getHasError());
		assertEquals(FEEDBACK_ADD_TASK_START_AFTER_END, logic.executeCommand(COMMAND_ADD_TASK_WITH_STARTIME_AFTER_ENDTIME));
		
		/* These are for the valid partition */
		assertEquals(false, parser.getHandler(COMMAND_ADD_FLOATING_TASK).getHasError());
		assertEquals(COMMAND_ADD, parser.getHandler(COMMAND_ADD_FLOATING_TASK).getCommandType());
		assertEquals(String.format(FEEDBACK_ADDED, parser.getHandler(COMMAND_ADD_FLOATING_TASK).getTask().toFilteredString()), logic.executeCommand(COMMAND_ADD_FLOATING_TASK));
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		
		assertEquals(false, parser.getHandler(COMMAND_ADD_FLOATING_TASK_WITH_KEYWORDS).getHasError());
		assertEquals(COMMAND_ADD, parser.getHandler(COMMAND_ADD_FLOATING_TASK_WITH_KEYWORDS).getCommandType());
		assertEquals(String.format(FEEDBACK_ADDED, parser.getHandler(COMMAND_ADD_FLOATING_TASK_WITH_KEYWORDS).getTask().toFilteredString()), logic.executeCommand(COMMAND_ADD_FLOATING_TASK_WITH_KEYWORDS));
		assertEquals(2, storage.getFileManager().getLineCount(todo));
		
		assertEquals(false, parser.getHandler(COMMAND_ADD_DEADLINE).getHasError());
		assertEquals(COMMAND_ADD, parser.getHandler(COMMAND_ADD_DEADLINE).getCommandType());
		assertEquals(String.format(FEEDBACK_ADDED, parser.getHandler(COMMAND_ADD_DEADLINE).getTask().toFilteredString()), logic.executeCommand(COMMAND_ADD_DEADLINE));
		assertEquals(3, storage.getFileManager().getLineCount(todo));
		
		assertEquals(false, parser.getHandler(COMMAND_ADD_DEADLINE_WITH_KEYWORDS).getHasError());
		assertEquals(COMMAND_ADD, parser.getHandler(COMMAND_ADD_DEADLINE_WITH_KEYWORDS).getCommandType());
		assertEquals(String.format(FEEDBACK_ADDED, parser.getHandler(COMMAND_ADD_DEADLINE_WITH_KEYWORDS).getTask().toFilteredString()), logic.executeCommand(COMMAND_ADD_DEADLINE_WITH_KEYWORDS));
		assertEquals(4, storage.getFileManager().getLineCount(todo));
		
		assertEquals(false, parser.getHandler(COMMAND_ADD_EVENT).getHasError());
		assertEquals(COMMAND_ADD, parser.getHandler(COMMAND_ADD_EVENT).getCommandType());
		assertEquals(String.format(FEEDBACK_ADDED, parser.getHandler(COMMAND_ADD_EVENT).getTask().toFilteredString()), logic.executeCommand(COMMAND_ADD_EVENT));
		assertEquals(5, storage.getFileManager().getLineCount(todo));
		
		assertEquals(false, parser.getHandler(COMMAND_ADD_EVENT_WITH_KEYWORDS).getHasError());
		assertEquals(String.format(FEEDBACK_ADDED, parser.getHandler(COMMAND_ADD_EVENT_WITH_KEYWORDS).getTask().toFilteredString()), logic.executeCommand(COMMAND_ADD_EVENT_WITH_KEYWORDS));
		assertEquals(6, storage.getFileManager().getLineCount(todo));
	}
	
	@Test
	public void testViewTasksMethod() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		logic.executeCommand(COMMAND_SET_LOCATION_DIRECTORY);
		
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		logic.executeCommand(COMMAND_ADD_FLOATING_TASK); // add floating task
		logic.executeCommand(COMMAND_ADD_DEADLINE); // add deadline
		logic.executeCommand(COMMAND_ADD_EVENT); // add event
		assertEquals(3, storage.getFileManager().getLineCount(todo));
		
		/* This is for the invalid partition */
		assertEquals(true, parser.getHandler(COMMAND_VIEW_TASKS_OTHERS).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_OTHERS).getCommandType());
		assertEquals(parser.getHandler(COMMAND_VIEW_TASKS_OTHERS).getFeedBack(), logic.executeCommand(COMMAND_VIEW_TASKS_OTHERS));
		
		// These are for the valid partition 
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_EMPTY).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_EMPTY).getCommandType());
		assertEquals("1,"+parser.getHandler(COMMAND_ADD_DEADLINE).getTask().toString()+"\n"
				+"2,"+parser.getHandler(COMMAND_ADD_EVENT).getTask().toString()+"\n"
				+"3,"+parser.getHandler(COMMAND_ADD_FLOATING_TASK).getTask().toString()+"\n", logic.executeCommand(COMMAND_VIEW_TASKS_EMPTY));	
		assertEquals(3, storage.viewTasks(PARAM_VIEW_TASKS_EMPTY).size());	
		
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_EVENTS).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_EVENTS).getCommandType());
		assertEquals("1,"+parser.getHandler(COMMAND_ADD_EVENT).getTask().toString()+"\n", logic.executeCommand(COMMAND_VIEW_TASKS_EVENTS));
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_EVENTS).size());
		
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_DEADLINES).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_DEADLINES).getCommandType());
		assertEquals("1,"+parser.getHandler(COMMAND_ADD_DEADLINE).getTask().toString()+"\n", logic.executeCommand(COMMAND_VIEW_TASKS_DEADLINES));
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_DEADLINES).size());
		
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_FLOATING).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_FLOATING).getCommandType());
		assertEquals("1,"+parser.getHandler(COMMAND_ADD_FLOATING_TASK).getTask().toString()+"\n", logic.executeCommand(COMMAND_VIEW_TASKS_FLOATING));	
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_FLOATING).size());
		
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_OVERDUE).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_OVERDUE).getCommandType());
		assertEquals(FEEDBACK_EMPTY_LIST, logic.executeCommand(COMMAND_VIEW_TASKS_OVERDUE));
		assertEquals(0, storage.viewTasks(PARAM_VIEW_TASKS_OVERDUE).size());
		
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_DONE).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_DONE).getCommandType());
		assertEquals(FEEDBACK_EMPTY_LIST, logic.executeCommand(COMMAND_VIEW_TASKS_DONE));	
		assertEquals(0, storage.viewTasks(PARAM_VIEW_TASKS_DONE).size());	
	}
	
	@Test
	public void testSearchTasksMethod() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		logic.executeCommand(COMMAND_SET_LOCATION_DIRECTORY);
		
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		logic.executeCommand(COMMAND_ADD_FLOATING_TASK); // add floating task
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		
		// These are for the valid partition 
		assertEquals(false, parser.getHandler(COMMAND_SEARCH_TASKS_EMPTY).getHasError());
		assertEquals(COMMAND_SEARCH, parser.getHandler(COMMAND_SEARCH_TASKS_EMPTY).getCommandType());
		assertEquals("1,"+parser.getHandler(COMMAND_ADD_FLOATING_TASK).getTask().toString()+"\n", logic.executeCommand(COMMAND_SEARCH_TASKS_EMPTY));
		
		assertEquals(false, parser.getHandler(COMMAND_SEARCH_TASKS_KEYWORD).getHasError());
		assertEquals(COMMAND_SEARCH, parser.getHandler(COMMAND_SEARCH_TASKS_KEYWORD).getCommandType());
		assertEquals("1,"+parser.getHandler(COMMAND_ADD_FLOATING_TASK).getTask().toString()+"\n", logic.executeCommand(COMMAND_SEARCH_TASKS_KEYWORD));
	
		assertEquals(false, parser.getHandler(COMMAND_SEARCH_TASKS_OTHER_KEYWORD).getHasError());
		assertEquals(COMMAND_SEARCH, parser.getHandler(COMMAND_SEARCH_TASKS_OTHER_KEYWORD).getCommandType());
		assertEquals(FEEDBACK_NO_TASK_FOUND, logic.executeCommand(COMMAND_SEARCH_TASKS_OTHER_KEYWORD));
	}
}
```
###### test\TaskTest.java
``` java
package test;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

import simplyamazing.data.Task;

public class TaskTest {

	@Test
	public void testFloatingTaskCreation() {
		Task task = new Task("go swimming");
		assertEquals("go swimming, , , , ", task.toString());
	}
	
	@Test(expected = Exception.class) 
	public void testDeadlineCreation() throws Exception {
		Task task = new Task("go swimming", "17:30 28 Feb");
		task = new Task("go swimming", "17:30 28 Feb 2016");
		assertEquals("go swimming,,17:30 28 Feb 2016, , ", task.toString());
	}
	
	@Test(expected = Exception.class) 
	public void testEventCreation() throws Exception {
		Task task = new Task("go swimming", "15:30 28 Feb", "17:30 28 Feb");
		task = new Task("go swimming", "15:30 28 Feb 2016", "17:30 28 Feb 2016");
		assertEquals("go swimming,15:30 28 Feb 2016,17:30 28 Feb 2016, , ", task.toString());
	}

	@Test
	public void testSetDescriptionMethod() {
		Task task = new Task("go swimming");
		task.setDescription("study for exam");
		assertEquals("study for exam, , , , ", task.toString());
	}
	
	@Test(expected = Exception.class)
	public void testSetStartTimeMethod() throws Exception {
		Task task = new Task("go swimming");
		task.setStartTime("15:30 28 Feb");
		task.setStartTime("15:30 28 Feb 2016"); 
		assertEquals("go swimming,15:30 28 Feb 2016, , , ", task.toString());
	}
	
	@Test(expected = Exception.class)
	public void testSetEndTimeMethod() throws Exception {
		Task task = new Task("go swimming");
		task.setEndTime("17:30 28 Feb");
		task.setEndTime("17:30 28 Feb 2016"); 
		assertEquals("go swimming,,17:30 28 Feb 2016, , ", task.toString());
	}
	
	@Test(expected = Exception.class)
	public void testSetPriorityMethod() throws Exception {
		Task task = new Task("study for exam");
		task.setPriority("very high");
		task.setPriority("high");
		assertEquals("study for exam, , ,high, ", task.toString());
	}
	
	@Test
	public void testSetDoneMethod() {
		Task task = new Task("go swimming");
		task.setDone(true);
		assertEquals("go swimming, , , ,done", task.toString());
		task.setDone(false);
		assertEquals("go swimming, , , , ", task.toString());
	}
	
}
```
