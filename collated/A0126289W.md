# A0126289W
###### simplyamazing\data\Task.java
``` java
package simplyamazing.data;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

public class Task implements Comparable<Task> {
	
	private static final String KEYWORD_PRIORITY = " priority";
	private static final String KEYWORD_DEADLINE = " by ";
	private static final String KEYWORD_END_TIME = " to ";
	private static final String KEYWORD_START_TIME = " from ";
	
	private static final int DEFAULT_PRIORITY_LEVEL = 0;
	private static final int DEFAULT_PRIORITY_LEVEL_LOW = 1;
	private static final int DEFAULT_PRIORITY_LEVEL_MEDIUM = 2;
	private static final int DEFAULT_PRIORITY_LEVEL_HIGH = 3;
	
	private static final int DEFAULT_TASK_TYPE = 1;
	private static final int DEFAULT_TASK_TYPE_FOR_EVENTS = 2;
	private static final int DEFAULT_TASK_TYPE_FOR_DEADLINES = 3;
	
	public static final Date DEFAULT_DATE_VALUE = new Date(0);
	public static final Date DEFAULT_DATE_VALUE_FOR_NULL = new Date(1);

	public static final String TIME_FORMAT = "HH:mm dd MMM yyyy";
	
	public static final String FIELD_SEPARATOR = ",";
	
	private static final String CHARACTER_SPACE = " ";
	
	private static final String STRING_CONNECTOR_FOR_PRIORITY = " with ";
	private static final String STRING_OBJECT_NAME = "Task [";
	private static final String STRING_END = "]";
	
	private static final String STRING_HIGH_PRIORITY = "high";
	private static final String STRING_MEDIUM_PRIORITY = "medium";
	private static final String STRING_LOW_PRIORITY = "low";
	private static final String STRING_NO_PRIORITY = "none";
	private static final String STRING_STATUS_INCOMPLETE = "incomplete";
	private static final String STRING_STATUS_OVERDUE = "overdue";
	public static final String STRING_STATUS_DONE = "done";
	
	public static final int NUM_FIELDS_STORED = 5;
	
	public static final int ARRAY_POSITION_FOR_DESCRIPTION = 0;
	public static final int ARRAY_POSITION_FOR_START_TIME = 1;
	public static final int ARRAY_POSITION_FOR_END_TIME = 2;
	public static final int ARRAY_POSITION_FOR_PRIORITY = 3;
	public static final int ARRAY_POSITION_FOR_STATUS = 4;
	
	private static final int INDEX_FIRST = 0;
	private static final int INDEX_SECOND = 1;
	private static final int INDEX_FOURTH = 3;
	
	public static final int INDEX_TIME = 0;
	public static final int INDEX_DAY = 1;
	public static final int INDEX_MONTH = 2;
	public static final int INDEX_YEAR = 3;
	
	private static final String MESSAGE_INVALID_PRIORITY_LEVEL = "Priority level can be only high, medium, low "
			+ "or none.";
	
	private String description;
	private Date startTime, endTime;
	private int priority, taskType;
	private boolean done; 

	public Task() {
		this.description = CHARACTER_SPACE;
		this.startTime = DEFAULT_DATE_VALUE;
		this.endTime = DEFAULT_DATE_VALUE;
		this.priority = DEFAULT_PRIORITY_LEVEL;
		this.taskType = DEFAULT_TASK_TYPE;
		this.done = false;
	}
	
	public Task(String description) {
		this.description = description.trim();
		this.startTime = DEFAULT_DATE_VALUE;
		this.endTime = DEFAULT_DATE_VALUE;
		this.priority = DEFAULT_PRIORITY_LEVEL;
		this.taskType = DEFAULT_TASK_TYPE;
		this.done = false;
	}

	public Task(String description, String endTime) throws Exception {
		this.description = description.trim();
		this.startTime = DEFAULT_DATE_VALUE;
		this.endTime = convertStringToDate(endTime.trim(), TIME_FORMAT);
		this.priority = DEFAULT_PRIORITY_LEVEL;
		this.taskType = DEFAULT_TASK_TYPE_FOR_EVENTS;
		this.done = false;
	}

	public Task(String description, String startTime, String endTime) throws Exception {
		this.description = description.trim();
		this.startTime = convertStringToDate(startTime.trim(), TIME_FORMAT);
		this.endTime = convertStringToDate(endTime.trim(), TIME_FORMAT);
		this.priority = DEFAULT_PRIORITY_LEVEL;
		this.taskType = DEFAULT_TASK_TYPE_FOR_DEADLINES;
		this.done = false;
	}

	public static Date convertStringToDate(String timeString, String format) throws Exception {
        SimpleDateFormat formatter = new SimpleDateFormat(format, Locale.ENGLISH);
        Date date = formatter.parse(timeString);
        return date;
    }

	/*
	 * This method converts the given date as a date-time string.
	 * The standard format is "HH:mm dd MMM YYYY" where MMM is a string of length 3, describing the month, 
	 * with first word capitalized.
	 */
    public static String convertDateToString(Date date) {
        String timeString = CHARACTER_SPACE;
        SimpleDateFormat formatter = new SimpleDateFormat(TIME_FORMAT, Locale.ENGLISH);
        timeString = formatter.format(date);
        String[] fields = timeString.split(CHARACTER_SPACE);
        assert(fields.length > 0);
        String monthFirstWord = fields[INDEX_MONTH].toLowerCase().substring(INDEX_FIRST, INDEX_SECOND)
        		.toUpperCase();
        String monthFormatted = monthFirstWord + fields[INDEX_MONTH].substring(INDEX_SECOND,INDEX_FOURTH);
        timeString = fields[INDEX_TIME] + CHARACTER_SPACE + fields[INDEX_DAY] + CHARACTER_SPACE 
        		+ monthFormatted + CHARACTER_SPACE + fields[INDEX_YEAR];
        return timeString;
    }
	
	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description.trim();
	}

	public Date getStartTime() {
		return startTime;
	}

	public void setStartTime(String startTime) throws Exception {
		this.startTime = convertStringToDate(startTime.trim(), TIME_FORMAT);
		this.taskType = DEFAULT_TASK_TYPE_FOR_EVENTS;
	}
	
	public void setStartTime(Date startTime) {
		this.startTime = startTime;
		this.taskType = DEFAULT_TASK_TYPE_FOR_EVENTS;
	}

	public Date getEndTime() {
		return endTime;
	}

	public void setEndTime(String endTime) throws Exception {
		this.endTime = convertStringToDate(endTime.trim(), TIME_FORMAT);
		if (this.startTime == DEFAULT_DATE_VALUE) { // For floating tasks and deadlines
			this.taskType = DEFAULT_TASK_TYPE_FOR_DEADLINES;
		}
	}

	public void setEndTime(Date endTime) {
		this.endTime = endTime;
		if (this.startTime == DEFAULT_DATE_VALUE) { // For floating tasks and deadlines
			this.taskType = DEFAULT_TASK_TYPE_FOR_DEADLINES;
		}
	}

	public int getPriority() {
		return priority;
	}

	/*
	 * This method sets the priority level of a task.
	 * Valid priority levels are high, medium, low and none(default).
	 */
	public void setPriority(String priorityLevel) throws Exception {
		switch (priorityLevel.trim().toLowerCase()) {
		case STRING_HIGH_PRIORITY : 
			this.priority = DEFAULT_PRIORITY_LEVEL_HIGH;
			break;
		case STRING_MEDIUM_PRIORITY : 
			this.priority = DEFAULT_PRIORITY_LEVEL_MEDIUM;
			break;
		case STRING_LOW_PRIORITY : 
			this.priority = DEFAULT_PRIORITY_LEVEL_LOW;
			break;
		case STRING_NO_PRIORITY : 
			this.priority = DEFAULT_PRIORITY_LEVEL;
			break;
		default : 
			throw new Exception(MESSAGE_INVALID_PRIORITY_LEVEL);
		}
	}

	public void setPriority(int priority) {
		this.priority = priority;
	}
	
	public int getTaskType() {
		return taskType;
	}

	public boolean isDone() {
		return done;
	}

	public void setDone(boolean done) {
		this.done = done;
	}
	
	/*
	 * This method is to be used by Collections.sort(List<T>).
	 * Tasks are sorted by priority, end time, start time and lexicographical order of their descriptions.
	 * Because default date-time value is 00:00 1 Jan 1970, 
	 * floating tasks will be on top since their start and end times are set to default values
	 * To fix that, this method checks if the end times or start times of the tasks are set as default value first 
	 * when they are of different values.
	 * If one of them is with default date-time value, sort them by task type, 
	 * deadline first, followed by event and floating task.
	 */
	@Override
	public int compareTo(Task task) {
		if (task.getPriority() == this.priority) { // Same priority
			if (task.getEndTime().compareTo(this.endTime) == 0) { // Same end time 
				if (task.getStartTime().compareTo(this.startTime) == 0) { // Same start time
					return this.description.compareToIgnoreCase(task.getDescription());
				} 
				return this.startTime.compareTo(task.getStartTime());	
			} else { // Different end time
				if (this.endTime.compareTo(DEFAULT_DATE_VALUE) == 0 
						|| task.getEndTime().compareTo(DEFAULT_DATE_VALUE) == 0) { 
					// One floating task and other event/deadline
					return task.getTaskType() - this.taskType;
				}
				return this.endTime.compareTo(task.getEndTime());		
			} 
		}
		return task.getPriority() - this.priority;
	}
	
	/*
	 * This method is to be used by Storage component to write to the file.
	 * The format is description,startTime,endTime,priority,status.
	 * If any of the fields is default value, it will be indicated by a space.
	 * Status is "done" for tasks marked as completed, "overdue" when its end time was already passed, 
	 * and the rest regarded as "incomplete".
	 */
	@Override
	public String toString() {
		String startTimeString = CHARACTER_SPACE;
		String endTimeString = CHARACTER_SPACE;
		String priorityLevel = CHARACTER_SPACE;
		String status = STRING_STATUS_INCOMPLETE;
		
		if (this.startTime.compareTo(DEFAULT_DATE_VALUE) != 0) {
			startTimeString = convertDateToString(this.startTime);
			assert(!startTimeString.matches(CHARACTER_SPACE));
		}
		
		if (this.endTime.compareTo(DEFAULT_DATE_VALUE) != 0) {
			endTimeString = convertDateToString(this.endTime);
			assert(!endTimeString.matches(CHARACTER_SPACE));
		}
		
		switch (this.priority) {
		case DEFAULT_PRIORITY_LEVEL_HIGH : 
			priorityLevel = STRING_HIGH_PRIORITY;
			break;
		case DEFAULT_PRIORITY_LEVEL_MEDIUM : 
			priorityLevel = STRING_MEDIUM_PRIORITY;
			break;
		case DEFAULT_PRIORITY_LEVEL_LOW : 
			priorityLevel = STRING_LOW_PRIORITY;
			break;
		default : 
			priorityLevel = CHARACTER_SPACE;
			break;
		}
		
		Date now = new Date();
		Date endTime = this.getEndTime();
		if (endTime.before(now) && endTime != Task.DEFAULT_DATE_VALUE) {
			status = STRING_STATUS_OVERDUE;
			assert (!status.matches(STRING_STATUS_INCOMPLETE));
		}
		if (this.isDone()) {
			status = STRING_STATUS_DONE;
			assert (!status.matches(STRING_STATUS_INCOMPLETE));
		}
		
		return this.description.trim() + FIELD_SEPARATOR + startTimeString + FIELD_SEPARATOR 
				+ endTimeString + FIELD_SEPARATOR + priorityLevel + FIELD_SEPARATOR + status;
	}
	
	/*
	 * This method converts the description of the task into more user readable format.
	 * Events are shown by "from" and "to" keywords.
	 * Deadlines are shown by "by" keyword.
	 * If there is any priority set, it will be shown by keyword "with" followed by the priority level.
	 */
	public String toFilteredString() {
		String[] fields = this.toString().split(FIELD_SEPARATOR);
		assert(fields.length == NUM_FIELDS_STORED);
		String filteredString = STRING_OBJECT_NAME;
		for (int i = 0; i < ARRAY_POSITION_FOR_STATUS; i++) {
			if (!fields[ARRAY_POSITION_FOR_START_TIME].matches(CHARACTER_SPACE)) {
				if (i == ARRAY_POSITION_FOR_START_TIME) {
					filteredString += KEYWORD_START_TIME;
				}
				if (i == ARRAY_POSITION_FOR_END_TIME) {
					filteredString += KEYWORD_END_TIME;
				}
			} else {
				if (!fields[ARRAY_POSITION_FOR_END_TIME].matches(CHARACTER_SPACE) 
						&& i == ARRAY_POSITION_FOR_END_TIME) {
					filteredString += KEYWORD_DEADLINE;
				} 
			}
			if (i == ARRAY_POSITION_FOR_PRIORITY && !fields[i].matches(CHARACTER_SPACE)) {
				filteredString += STRING_CONNECTOR_FOR_PRIORITY + fields[i] + KEYWORD_PRIORITY;
			}
			if (i != ARRAY_POSITION_FOR_PRIORITY) {
				filteredString += fields[i].trim();
			}
		}
		filteredString += STRING_END;
		return filteredString;
	}
}
```
###### simplyamazing\data\TaskList.java
``` java
package simplyamazing.data;

import java.util.ArrayList;
import java.util.Collections;

public class TaskList {

	private static final String CHARACTER_SPACE = " ";

	private static final int SIZE_EMPTY = 0;

	private ArrayList<Task> tasks, completedTasks;
	
	public TaskList() {
		tasks = new ArrayList<Task>();
		completedTasks = new ArrayList<Task>();
	}

	public ArrayList<Task> getTasks() {
		return tasks;
	}

	public ArrayList<Task> getCompletedTasks() {
		return completedTasks;
	}

	public void resetTaskList() {
		tasks = new ArrayList<Task>();
	}

	public void resetCompletedTaskList() {
		completedTasks = new ArrayList<Task>();
	}

	public void updateTaskList(ArrayList<String> lines, ArrayList<Task> taskList) throws Exception {
		if (taskList.size() == SIZE_EMPTY) {
			createTaskList(lines, taskList);
		}
	}

	/*
	 * This method converts the content of the file to an array list of tasks.
	 * The format is description,startTime,endTime,priority,status. If any of
	 * the fields is default value, it will be indicated by a space. Status is
	 * "done" for tasks marked as completed, "overdue" when its end time was
	 * already passed, and the rest regarded as "incomplete".
	 */
	public void createTaskList(ArrayList<String> lines, ArrayList<Task> taskList) throws Exception {
		for (int i = 0; i < lines.size(); i++) {
			String[] fields = lines.get(i).split(Task.FIELD_SEPARATOR);
			assert (fields.length == Task.NUM_FIELDS_STORED);

			String description = fields[Task.ARRAY_POSITION_FOR_DESCRIPTION];
			String startTimeString = fields[Task.ARRAY_POSITION_FOR_START_TIME];
			String endTimeString = fields[Task.ARRAY_POSITION_FOR_END_TIME];
			String priorityLevel = fields[Task.ARRAY_POSITION_FOR_PRIORITY];
			String status = fields[Task.ARRAY_POSITION_FOR_STATUS];

			Task task = new Task();
			if (!description.matches(CHARACTER_SPACE)) {
				task.setDescription(description);
			}
			if (!startTimeString.matches(CHARACTER_SPACE)) {
				task.setStartTime(startTimeString);
			}
			if (!endTimeString.matches(CHARACTER_SPACE)) {
				task.setEndTime(endTimeString);
			}
			if (!priorityLevel.matches(CHARACTER_SPACE)) {
				task.setPriority(priorityLevel);
			}
			if (status.matches(Task.STRING_STATUS_DONE)) {
				task.setDone(true);
			}
			addTaskToList(task, taskList);
		}
	}

	/*
	 * This method adds the given task to the given task list. After adding, it
	 * ensures tasks are sorted in order.
	 */
	public void addTaskToList(Task task, ArrayList<Task> taskList) throws Exception {
		int taskListSizeBeforeAdding = taskList.size();
		taskList.add(task);
		int taskListSizeAfterAdding = taskList.size();
		assert (taskListSizeAfterAdding == taskListSizeBeforeAdding + 1);
		Collections.sort(taskList);
	}

	/*
	 * This method removes the given task from either to-do list or completed
	 * task list. After removing, it ensures tasks are sorted in order.
	 */
	public void removeTaskFromList(Task task) throws Exception {
		int taskListSizeBeforeRemoving = 0, taskListSizeAfterRemoving = 0;

		if (tasks.contains(task)) {
			taskListSizeBeforeRemoving = tasks.size();
			tasks.remove(task);
			taskListSizeAfterRemoving = tasks.size();
			Collections.sort(tasks);
		} else {
			taskListSizeBeforeRemoving = completedTasks.size();
			completedTasks.remove(task);
			taskListSizeAfterRemoving = completedTasks.size();
			Collections.sort(completedTasks);
		}
		assert (taskListSizeAfterRemoving == taskListSizeBeforeRemoving - 1);
	}
}
```
###### simplyamazing\storage\FileBuilder.java
``` java
package simplyamazing.storage;

import java.io.File;

public class FileBuilder {
	
	public void createDirectory(String directoryName) {
		new File(directoryName).mkdirs();
	}
	
	public void createNewFile(File file) throws Exception {
		file.createNewFile();
	}
	
	public File createFile(String filename) {
		File file = new File(filename);
		return file;
	}
}
```
###### simplyamazing\storage\FileCopier.java
``` java
package simplyamazing.storage;

import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;

import java.io.File;
import java.nio.file.Files;

public class FileCopier {
	
	public void copy(File source, File destination) throws Exception {
		Files.copy(source.toPath(), destination.toPath(), REPLACE_EXISTING);
	}
}
```
###### simplyamazing\storage\FileManager.java
``` java
package simplyamazing.storage;

import java.io.File;
import java.util.ArrayList;

import simplyamazing.data.Task;

public class FileManager {
	
	private static final String DIRECTORY_CURRENT_USER = "user.home";
	private static String absolutePath = null;
	
	private static FileBuilder fileBuilder;
	private static FileVerifier fileVerifier;
	private static FileCopier fileCopier;
	private static ReadManager readManager;
	private static WriteManager writeManager;
	
	public FileManager() {
		fileBuilder = new FileBuilder();
		fileVerifier = new FileVerifier();
		fileCopier = new FileCopier();
		readManager = new ReadManager();
		writeManager = new WriteManager();
	}
	
	public void createDirectory(String directoryName) {
		fileBuilder.createDirectory(directoryName);
	}
	
	public void createNewFile(File file) throws Exception {
		if (fileVerifier.isFileExisting(file)) {
			file.delete();
		}
		fileBuilder.createNewFile(file);
	}
	
	public File createFile(String filename) {
		return fileBuilder.createFile(filename);
	}
	
	public File createTempFile(File file, String tempFilePath) throws Exception {
		File tempFile = createFile(tempFilePath);
		createNewFile(tempFile);
		createBackup(file, tempFile);
		file.delete();
		file = tempFile;
		return file;
	}
	
	public boolean isAbsolutePath(String location) {
		return fileVerifier.isAbsolutePath(location);
	}
	
	public boolean isValidDirectory(String location) {
		return fileVerifier.isFileExisting(new File(location));
	}

	public String getAbsolutePath(String location) {
		absolutePath = System.getProperty(DIRECTORY_CURRENT_USER)+ File.separator + location;
		return absolutePath;
	}
	
	public boolean isEmptyFile(File file) {
		return fileVerifier.isEmptyFile(file);
	}
	
	public boolean isFileExisting(File file) {
		return fileVerifier.isFileExisting(file);
	}
	
	public int getLineCount(File file) throws Exception {
		return readManager.read(file).size();
	}
	
	public void importListToFile(ArrayList<Task> tasks, File file) throws Exception {
		if (!fileVerifier.isEmptyFile(file)) { 
			cleanFile(file);
		}
		for (int i = 0; i < tasks.size(); i++) {
			writeToFile(file, tasks.get(i).toString());
		}	
	}
	
	public void writeToFile(File file, String text) throws Exception {
		writeManager.write(file, text);
	}
	
	public ArrayList<String> readFile(File file) throws Exception {
		return readManager.read(file);
	}
	
	public void cleanFile(File file) throws Exception {
		writeManager.writeEmptyFile(file);
	}
	
	public void createBackup(File file, File backupFile) throws Exception {
		fileCopier.copy(file, backupFile);
	}
	
	public void restoreFromBackup(File file, File backupFile) throws Exception {
		fileCopier.copy(backupFile, file);
	}
}
```
###### simplyamazing\storage\FileVerifier.java
``` java
package simplyamazing.storage;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;

public class FileVerifier {
	
	private static final int SIZE_EMPTY = 0;
	
	public boolean isAbsolutePath(String location) {
		return new File(location).isDirectory();
	}
	
	public boolean isEmptyFile(File file) {
		return file.length() == SIZE_EMPTY;
	}
	
	public boolean isFileExisting(File file) {
		return file.exists();
	}
}
```
###### simplyamazing\storage\ReadManager.java
``` java
package simplyamazing.storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class ReadManager {
	
	public ArrayList<String> read(File file) throws Exception {
		FileInputStream fileInputStream = new FileInputStream(file);
		InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream);
		BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
		
		String line = null;
		ArrayList<String> lines = new ArrayList<String>();
		
		while ((line = bufferedReader.readLine()) != null) {	
			lines.add(line);
		}
		bufferedReader.close();
		return lines;	 
	}
}
```
###### simplyamazing\storage\Storage.java
``` java
package simplyamazing.storage;

import java.io.File;
import java.util.ArrayList;
import java.util.Date;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import simplyamazing.data.Task;
import simplyamazing.data.TaskList;

public class Storage {
	
	private static final String DIRECTORY_SYSTEM = "C:\\Users\\Public\\SimplyAmazing";
	private static final String FILENAME_STORAGE = "\\storage.txt";
	private static final String FILENAME_TODO = "\\todo.txt";
	private static final String FILENAME_DONE = "\\done.txt";
	private static final String FILENAME_TEMP = "\\temp.txt";
	private static final String FILENAME_TODO_BACKUP = "\\todoBackup.txt";
	private static final String FILENAME_DONE_BACKUP = "\\doneBackup.txt";
	private static final String FILENAME_LOGGER = "\\logFile.txt";
	
	private static final String LOGGER_NAME = "simplyamazing";
	
	private static final String CHARACTER_SPACE = " ";
	private static final String STRING_EMPTY = "";

	private static final String STRING_TASK_TYPE_EVENT = "events";
	private static final String STRING_TASK_TYPE_DEADLINE = "deadlines";
	private static final String STRING_TASK_TYPE_FLOATING = "tasks";
	private static final String STRING_TASK_TYPE_OVERDUE = "overdue";
	private static final String STRING_TASK_TYPE_DONE = "done";

	private static final int INDEX_START_FOR_ARRAY = 0;

	private static final String MESSAGE_LOGGER_FILE_CREATION_FAILED = "Logger creation failed";
	private static final String MESSAGE_LOCATION_SET = "Storage location of task data "
			+ "has been sucessfully set as %1$s.";
	private static final String MESSAGE_NOT_DIRECTORY = "Error: Not a valid directory.";
	private static final String MESSAGE_ADDED = "%1$s has been added.";
	private static final String MESSAGE_RESTORED = "\"%1$s\" command has been successfully undone.";
	private static final String MESSAGE_INVALID_TASK_TYPE = "Unrecognized task type!";
	private static final String MESSAGE_COMPLETED_TASK = "%1$s is a completed task.";
	private static final String MESSAGE_INCOMPLETE_TASK = "%1$s is an incomplete task.";
	private static final String MESSAGE_DELETED = "%1$s has been successfully deleted.";
	private static final String MESSAGE_DELETED_MULTIPLE = "Provided tasks have been successfully deleted.";
	private static final String MESSAGE_MARKED_DONE = "%1$s has been marked as done.";
	private static final String MESSAGE_MARKED_UNDONE = "%1$s has been marked as incomplete.";
	private static final String MESSAGE_MARKED_DONE_MULTIPLE = "Provided tasks have been marked as done.";
	private static final String MESSAGE_MARKED_UNDONE_MULTIPLE = "Provided tasks have been marked as incomplete.";
	private static final String MESSAGE_UPDATED = "%1$s has been successfully updated.";

	private static final String MESSAGE_LOG_DIRECTORY_CREATED = "Directory for storage file "
			+ "is created successfully.";
	private static final String MESSAGE_LOG_STORAGE_FILE_CREATED = "Storage file is setup successfully.";
	private static final String MESSAGE_LOG_TASK_DATA_FILE_SETUP = "Task data file is setup successfully.";
	private static final String MESSAGE_LOG_DONE_TASKS_FILE_SETUP = "Task data file for completed tasks "
			+ "is setup successfully.";
	private static final String MESSAGE_LOG_TASK_DATA_BACKUP_FILE_SETUP = "Task data backup file "
			+ "is setup successfully.";
	private static final String MESSAGE_LOG_DONE_TASKS_BACKUP_FILE_SETUP = "Task data backup file "
			+ "for completed tasks is setup successfully.";
	private static final String MESSAGE_LOG_TASK_DATA_BACKUP_FILE_UPDATED = "Task data backup file "
			+ "is successfully updated";
	private static final String MESSAGE_LOG_COMPLETED_TASK_DATA_BACKUP_FILE_UPDATED = "Task data backup file "
			+ "for completed tasks is successfully updated";
	private static final String MESSAGE_LOG_TASK_LIST_UPDATED = "Task data is successfully loaded "
			+ "into the task list.";
	private static final String MESSAGE_LOG_TASK_DATA_WRITTEN_TO_FILE = "Task list is successfully imported "
			+ "into the task data file.";
	
	private static Logger logger  = Logger.getLogger("simplyamazing");

	private static boolean isEditing = false;

	private File storage, todo, done, todoBackup, doneBackup;

	private FileManager fileManager;
	private TaskList taskList;

	public Storage() {
		createLogger();
		
		fileManager = new FileManager();
		
		// create system directory if not exist
		fileManager.createDirectory(DIRECTORY_SYSTEM); 
		logger.log(Level.CONFIG, MESSAGE_LOG_DIRECTORY_CREATED);
		
		storage = fileManager.createFile((DIRECTORY_SYSTEM + FILENAME_STORAGE));
		logger.log(Level.CONFIG, MESSAGE_LOG_STORAGE_FILE_CREATED);
		
		taskList = new TaskList();
	}

	private void createLogger() {
		logger = Logger.getLogger(LOGGER_NAME);
		try {
			FileHandler fh = new FileHandler(DIRECTORY_SYSTEM + FILENAME_LOGGER, true);
			logger.addHandler(fh);
			SimpleFormatter formatter = new SimpleFormatter();  
			fh.setFormatter(formatter);
		} catch (Exception e){
			System.out.println(MESSAGE_LOGGER_FILE_CREATION_FAILED);
		}
	}
	
	public FileManager getFileManager() {
		return fileManager;
	}

	public TaskList getTaskList() {
		return taskList;
	}

	private boolean isLocationSet() {
		return !fileManager.isEmptyFile(storage);
	}

	/*
	 * This method sets the storage location of the task data.
	 * It checks the given location is an absolute path.
	 * If it is not, it converts it into an absolute path and checks if it is a valid directory (i.e. exists).
	 * If it is invalid, return an error message.
	 * Otherwise, write to the storage.txt file.
	 * Pre-condition: location is a non-empty string
	 */
	public String setLocation(String location) throws Exception {
		if (!fileManager.isAbsolutePath(location)) {
			location = fileManager.getAbsolutePath(location);
			if (!fileManager.isValidDirectory(location)) {
				logger.log(Level.WARNING, MESSAGE_NOT_DIRECTORY);
				throw new Exception(MESSAGE_NOT_DIRECTORY);
			}
		}
		
		if (!fileManager.isFileExisting(storage)) {
			fileManager.createNewFile(storage);
		}
		
		// When storage location has been set before
		if (isLocationSet()) { 
			setupFiles();

			todo = fileManager.createTempFile(todo, location + FILENAME_TODO);
			done = fileManager.createTempFile(done, location + FILENAME_DONE);

			fileManager.cleanFile(storage);
		}
		fileManager.writeToFile(storage, location);

		String feedback = String.format(MESSAGE_LOCATION_SET, location);
		logger.log(Level.INFO, feedback);
		return feedback;
	}

	public String getLocation() throws Exception {
		// set to default location if not set before
		if (!isLocationSet()) {
			setLocation(DIRECTORY_SYSTEM); 
		} 
		String location = fileManager.readFile(storage).get(INDEX_START_FOR_ARRAY);
		return location;
	}

	/*
	 * This method adds the given task to the to-do list.
	 * Before adding, setup files and update the list if required and create backup file.
	 * Pre-condition: task is not null
	 */
	public String addTask(Task task) throws Exception {
		setupFiles();
		if (!isEditing) {
			fileManager.createBackup(todo, todoBackup);
			logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_BACKUP_FILE_UPDATED);
		}
		updateTaskData();

		taskList.addTaskToList(task, taskList.getTasks());

		int lineCountBeforeAdding = fileManager.getLineCount(todo);
		fileManager.importListToFile(taskList.getTasks(), todo);
		int lineCountAfterAdding = fileManager.getLineCount(todo);
		assert  (lineCountAfterAdding == lineCountBeforeAdding + 1);
		logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_WRITTEN_TO_FILE);

		String feedback = String.format(MESSAGE_ADDED, task.toFilteredString());
		logger.log(Level.INFO, feedback);
		return feedback;
	}

	private void setupFiles() throws Exception {
		todo = fileManager.createFile(getLocation() + FILENAME_TODO);	
		if (!fileManager.isFileExisting(todo)) {
			fileManager.createNewFile(todo);
		}
		logger.log(Level.CONFIG, MESSAGE_LOG_TASK_DATA_FILE_SETUP);

		todoBackup = fileManager.createFile(DIRECTORY_SYSTEM + FILENAME_TODO_BACKUP);
		if (!fileManager.isFileExisting(todoBackup)) {
			fileManager.createNewFile(todoBackup);
		}
		logger.log(Level.CONFIG, MESSAGE_LOG_TASK_DATA_BACKUP_FILE_SETUP);

		done = fileManager.createFile(getLocation() + FILENAME_DONE);
		if (!fileManager.isFileExisting(done)) {
			fileManager.createNewFile(done);
		}
		logger.log(Level.CONFIG, MESSAGE_LOG_DONE_TASKS_FILE_SETUP);

		doneBackup = fileManager.createFile(DIRECTORY_SYSTEM + FILENAME_DONE_BACKUP);
		if (!fileManager.isFileExisting(doneBackup)) {
			fileManager.createNewFile(doneBackup);
		}
		logger.log(Level.CONFIG, MESSAGE_LOG_DONE_TASKS_BACKUP_FILE_SETUP);
	}

	private void updateTaskData() throws Exception {
		if (!fileManager.isEmptyFile(todo)) {
			ArrayList<String> taskData = fileManager.readFile(todo);
			taskList.updateTaskList(taskData, taskList.getTasks());
			assert (taskList.getTasks().size() > 0);
		}
		if (!fileManager.isEmptyFile(done)) {
			ArrayList<String> completedTaskData = fileManager.readFile(done);
			taskList.updateTaskList(completedTaskData, taskList.getCompletedTasks());
			assert (taskList.getCompletedTasks().size() > 0);
		}
		logger.log(Level.INFO, MESSAGE_LOG_TASK_LIST_UPDATED);
	}

	/*
	 * This method edits the task by comparing the differences between the given task and edited task.
	 * Before editing, setup files and update the list if required and create backup file.
	 * Pre-condition: task and editedTask are not null
	 */
	public String editTask(Task task, Task editedTask) throws Exception {
		isEditing = true;	
		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task);
		throwExceptionIfCompletedTask(tasks);

		deleteTask(task);

		if (!task.getDescription().matches(editedTask.getDescription()) 
				&& !editedTask.getDescription().matches(CHARACTER_SPACE)) {
			task.setDescription(editedTask.getDescription());
		}
		
		if (editedTask.getStartTime().compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) == 0) { 
			task.setStartTime(Task.DEFAULT_DATE_VALUE);
		} else if (task.getStartTime().compareTo(editedTask.getStartTime()) != 0 
				&& editedTask.getStartTime().compareTo(Task.DEFAULT_DATE_VALUE) != 0) {
			task.setStartTime(editedTask.getStartTime());
		}
		
		if (editedTask.getEndTime().compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) == 0) { 
			task.setEndTime(Task.DEFAULT_DATE_VALUE);
		} else if (task.getEndTime().compareTo(editedTask.getEndTime()) != 0 
				&& editedTask.getEndTime().compareTo(Task.DEFAULT_DATE_VALUE) != 0) {
			task.setEndTime(editedTask.getEndTime());
		}
		
		if (task.getPriority() != editedTask.getPriority()) {
			task.setPriority(editedTask.getPriority());
		}

		addTask(task);

		String feedback = String.format(MESSAGE_UPDATED, task.toFilteredString());
		logger.log(Level.INFO, feedback);
		isEditing = false;
		return feedback;
	}

	private void throwExceptionIfCompletedTask(ArrayList<Task> tasks) throws Exception {
		for (int i = 0; i < tasks.size(); i++) {
			if (taskList.getCompletedTasks().contains(tasks.get(i))) {
				String exceptionMessage = String.format(MESSAGE_COMPLETED_TASK, tasks.get(i).toFilteredString());
				logger.log(Level.WARNING, exceptionMessage);
				throw new Exception(exceptionMessage);
			}
		}
	}

	/*
	 * This method deletes the given task from either to-do list or completed task list.
	 * Before deleting, setup files and update the list if required and create backup file.
	 * Pre-condition: task is not null
	 */
	public String deleteTask(Task task) throws Exception {
		setupFiles();

		fileManager.createBackup(todo, todoBackup);
		logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_BACKUP_FILE_UPDATED);
		
		fileManager.createBackup(done, doneBackup);
		logger.log(Level.INFO, MESSAGE_LOG_COMPLETED_TASK_DATA_BACKUP_FILE_UPDATED);

		updateTaskData();

		taskList.removeTaskFromList(task);

		int lineCountBeforeAdding = fileManager.getLineCount(todo);
		fileManager.importListToFile(taskList.getTasks(), todo);
		int lineCountAfterAdding = fileManager.getLineCount(todo);
		assert (lineCountAfterAdding <= lineCountBeforeAdding);

		lineCountBeforeAdding = fileManager.getLineCount(done);
		fileManager.importListToFile(taskList.getCompletedTasks(), done);
		lineCountAfterAdding = fileManager.getLineCount(done);
		assert (lineCountAfterAdding <= lineCountBeforeAdding);

		logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_WRITTEN_TO_FILE);

		String feedback = String.format(MESSAGE_DELETED, task.toFilteredString());
		logger.log(Level.INFO, feedback);
		return feedback;
	}
	
	/*
	 * This method deletes the given tasks from either to-do list or completed task list.
	 * Before deleting, setup files and update the list if required and create backup file.
	 * Pre-condition: tasks are not null
	 */
	public String deleteMultipleTasks(ArrayList<Task> tasks) throws Exception {
		setupFiles();

		fileManager.createBackup(todo, todoBackup);
		logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_BACKUP_FILE_UPDATED);
		
		fileManager.createBackup(done, doneBackup);
		logger.log(Level.INFO, MESSAGE_LOG_COMPLETED_TASK_DATA_BACKUP_FILE_UPDATED);

		updateTaskData();
		
		for (int i = 0; i < tasks.size(); i++) {
			taskList.removeTaskFromList(tasks.get(i));
	
			String feedback = String.format(MESSAGE_DELETED, tasks.get(i).toFilteredString());
			logger.log(Level.INFO, feedback);
		}
		
		int lineCountBeforeAdding = fileManager.getLineCount(todo);
		fileManager.importListToFile(taskList.getTasks(), todo);
		int lineCountAfterAdding = fileManager.getLineCount(todo);
		assert (lineCountAfterAdding <= lineCountBeforeAdding);

		lineCountBeforeAdding = fileManager.getLineCount(done);
		fileManager.importListToFile(taskList.getCompletedTasks(), done);
		lineCountAfterAdding = fileManager.getLineCount(done);
		assert (lineCountAfterAdding <= lineCountBeforeAdding);

		logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_WRITTEN_TO_FILE);
		return MESSAGE_DELETED_MULTIPLE;
	}

	/*
	 * This method retrieves tasks according to the given task type.
	 * Pre-condition: taskType is not null
	 */
	public ArrayList<Task> viewTasks(String taskType) throws Exception {

		setupFiles();

		updateTaskData();

		switch (taskType) {
		case STRING_EMPTY : 
			return viewTasks();
		case STRING_TASK_TYPE_EVENT : 
			return viewEvents();
		case STRING_TASK_TYPE_DEADLINE : 
			return viewDeadlines();
		case STRING_TASK_TYPE_FLOATING : 
			return viewFloatingTasks();
		case STRING_TASK_TYPE_OVERDUE : 
			return viewOverdueTasks();
		case STRING_TASK_TYPE_DONE : 
			return viewCompletedTasks();
		default : 
			throw new Exception(MESSAGE_INVALID_TASK_TYPE);
		}
	}

	/*
	 * This method retrieves all pending tasks.
	 */
	private ArrayList<Task> viewTasks() {
		ArrayList<Task> tasks = taskList.getTasks();
		ArrayList<Task> overdueTasks = viewOverdueTasks();
		ArrayList<Task> currentTasks = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			Task task = tasks.get(i);
			if (!overdueTasks.contains(task)) {
				currentTasks.add(task);
			}
		}
		return currentTasks;
	}

	private ArrayList<Task> viewEvents() {
		ArrayList<Task> tasks = taskList.getTasks();
		ArrayList<Task> overdueTasks = viewOverdueTasks();
		ArrayList<Task> currentEvents = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			Task task = tasks.get(i);
			Date startTime = task.getStartTime();
			if (!overdueTasks.contains(task) && startTime != Task.DEFAULT_DATE_VALUE) {
				currentEvents.add(task);
			}
		}
		return currentEvents;
	}

	private ArrayList<Task> viewDeadlines() {
		ArrayList<Task> tasks = taskList.getTasks();
		ArrayList<Task> overdueTasks = viewOverdueTasks();
		ArrayList<Task> currentDeadlines = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			Task task = tasks.get(i);
			Date startTime = task.getStartTime();
			Date endTime = task.getEndTime();
			if (!overdueTasks.contains(task) && startTime == Task.DEFAULT_DATE_VALUE 
					&& endTime != Task.DEFAULT_DATE_VALUE) {
				currentDeadlines.add(task);
			}
		}
		return currentDeadlines;
	}

	private ArrayList<Task> viewFloatingTasks() {
		ArrayList<Task> tasks = taskList.getTasks();
		ArrayList<Task> currentFloatingTasks = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			Task task = tasks.get(i);
			Date startTime = task.getStartTime();
			Date endTime = task.getEndTime();
			if (startTime == Task.DEFAULT_DATE_VALUE && endTime == Task.DEFAULT_DATE_VALUE) {
				currentFloatingTasks.add(task);
			}
		}
		return currentFloatingTasks;
	}
	
	/*
	 * This method retrieves all tasks with end time already passed.
	 */
	private ArrayList<Task> viewOverdueTasks() {
		ArrayList<Task> tasks = taskList.getTasks();
		ArrayList<Task> overdueTasks = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			Task task = tasks.get(i);
			Date now = new Date();
			Date endTime = task.getEndTime();
			if (endTime.before(now) && endTime != Task.DEFAULT_DATE_VALUE) {
				overdueTasks.add(task);
			}
		}
		return overdueTasks;		
	}

	private ArrayList<Task> viewCompletedTasks() {
		return taskList.getCompletedTasks();
	}

	/*
	 * This method retrieves all tasks having the given keyword.
	 * If there is more than one keyword, returns the result for the exact match (AND) 
	 * followed by partial match (OR).
	 * Pre-condition: keyword is not null
	 */
	public ArrayList<Task> searchTasks(String keyword) throws Exception {
		keyword = keyword.toLowerCase();
		ArrayList<Task> tasks = viewTasks(STRING_EMPTY);
		assert (tasks != null);
		tasks.addAll(viewCompletedTasks());
		
		ArrayList<Task> filteredTasks = new ArrayList<Task>();
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).toString().toLowerCase().contains(keyword)) {
				filteredTasks.add(tasks.get(i));
			}
		}
		String[] keywords = keyword.split(CHARACTER_SPACE);
		for (int i = 0; i < tasks.size(); i++) {
			for (int j = 0; j < keywords.length; j++) {
				if (tasks.get(i).toString().toLowerCase().contains(keywords[j]) 
						&& !filteredTasks.contains(tasks.get(i))) {
					filteredTasks.add(tasks.get(i));
				}
			}
		}
		return filteredTasks;
	}
	
	/*
	 * This method retrieves all tasks that can be done on the given date.
	 * When the user provides only the month and/or year, it will give the same result as searchByKeyword 
	 * Time provided will be ignored.
	 * Pre-condition: date is not null
	 */
	public ArrayList<Task> searchTasksByDate(Date date) throws Exception {
		String[] datetimes = Task.convertDateToString(date).split(CHARACTER_SPACE);
		String dateString = datetimes[1] + CHARACTER_SPACE + datetimes[2] + CHARACTER_SPACE + datetimes[3];
		ArrayList<Task> tasks = viewTasks(STRING_EMPTY);
		assert (tasks != null);

		ArrayList<Task> filteredTasks = new ArrayList<Task>();
		
		// put the tasks with the exact match of the specified date first
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).toString().contains(dateString)) { 
				filteredTasks.add(tasks.get(i));
			}	
		}
		
		// put the tasks which has end time after the specified date
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getStartTime().before(date) && tasks.get(i).getEndTime().after(date) 
					&& !filteredTasks.contains(tasks.get(i))) {
				filteredTasks.add(tasks.get(i));
			}
		}
		
		// put floating tasks lastly
		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).getStartTime() == Task.DEFAULT_DATE_VALUE 
					&& tasks.get(i).getEndTime() == Task.DEFAULT_DATE_VALUE 
					&& !filteredTasks.contains(tasks.get(i))) {
				filteredTasks.add(tasks.get(i));
			}
		}
		return filteredTasks;
	}

	/*
	 * This method moves the given task from to-do list to completed task list.
	 * Pre-condition: task is not null
	 */
	public String markTaskDone(Task task) throws Exception {
		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task);
		
		throwExceptionIfCompletedTask(tasks);
		
		deleteTask(task);
		
		task.setDone(true);
		moveToDoneFile(task);

		String feedback = String.format(MESSAGE_MARKED_DONE, task.toFilteredString());
		logger.log(Level.INFO, feedback);
		return feedback;
	}
	
	private void moveToDoneFile(Task task) throws Exception {
		taskList.addTaskToList(task, taskList.getCompletedTasks());

		int lineCountBeforeAdding = fileManager.getLineCount(done);
		fileManager.importListToFile(taskList.getCompletedTasks(), done);
		int lineCountAfterAdding = fileManager.getLineCount(done);
		assert (lineCountAfterAdding == lineCountBeforeAdding + 1);
		logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_WRITTEN_TO_FILE);
	}
	
	/*
	 * This method moves the given tasks from completed task list to to-do list.
	 * Pre-condition: tasks are not null
	 */
	public String markTaskUndone(Task task) throws Exception {
		ArrayList<Task> tasks = new ArrayList<Task>();
		tasks.add(task);
		
		throwExceptionIfNotCompletedTask(tasks);
		
		deleteTask(task);
		
		task.setDone(false);
		moveToToDoFile(task);

		String feedback = String.format(MESSAGE_MARKED_UNDONE, task.toFilteredString());
		logger.log(Level.INFO, feedback);
		return feedback;
	}
	
	private void moveToToDoFile(Task task) throws Exception {
		taskList.addTaskToList(task, taskList.getTasks());

		int lineCountBeforeAdding = fileManager.getLineCount(todo);
		fileManager.importListToFile(taskList.getTasks(), todo);
		int lineCountAfterAdding = fileManager.getLineCount(todo);
		assert (lineCountAfterAdding == lineCountBeforeAdding + 1);
		logger.log(Level.INFO, MESSAGE_LOG_TASK_DATA_WRITTEN_TO_FILE);
	}
	
	private void throwExceptionIfNotCompletedTask(ArrayList<Task> tasks) throws Exception {
		for (int i = 0; i < tasks.size(); i++) {
			if (taskList.getTasks().contains(tasks.get(i))) {
				String exceptionMessage = String.format(MESSAGE_INCOMPLETE_TASK, 
						tasks.get(i).toFilteredString());
				logger.log(Level.WARNING, exceptionMessage);
				throw new Exception(exceptionMessage);
			}
		}
	}

	/*
	 * This method moves the given tasks from to-do list to completed task list.
	 * Pre-condition: tasks are not null
	 */
	public String markMultipleTasksDone(ArrayList<Task> tasks) throws Exception {
		
		throwExceptionIfCompletedTask(tasks);

		deleteMultipleTasks(tasks);
		
		for (int i = 0; i < tasks.size(); i++) {
			tasks.get(i).setDone(true);
			moveToDoneFile(tasks.get(i));
	
			String feedback = String.format(MESSAGE_MARKED_DONE, tasks.get(i).toFilteredString());
			logger.log(Level.INFO, feedback);
		}
		return MESSAGE_MARKED_DONE_MULTIPLE;
	}
	
	/*
	 * This method moves the given tasks from completed task list to to-do list.
	 * Pre-condition: tasks are not null
	 */
	public String markMultipleTasksUndone(ArrayList<Task> tasks) throws Exception {
		
		throwExceptionIfNotCompletedTask(tasks);
		
		deleteMultipleTasks(tasks);
		
		for (int i = 0; i < tasks.size(); i++) {
			tasks.get(i).setDone(false);
			moveToToDoFile(tasks.get(i));
	
			String feedback = String.format(MESSAGE_MARKED_UNDONE, tasks.get(i).toFilteredString());
			logger.log(Level.INFO, feedback);
		}
		return MESSAGE_MARKED_UNDONE_MULTIPLE;
	}

	public String restore(String previousCommand) throws Exception {
		setupFiles();

		if (!fileManager.isEmptyFile(todoBackup) || !fileManager.isEmptyFile(todo)) {
			File temp = fileManager.createTempFile(todo, DIRECTORY_SYSTEM+FILENAME_TEMP);	
			fileManager.restoreFromBackup(todo, todoBackup);
			fileManager.restoreFromBackup(todoBackup, temp);
			temp.delete();
			taskList.resetTaskList();
			assert (taskList.getTasks().size() == 0);
			updateTaskData();
		}
		if (!fileManager.isEmptyFile(doneBackup) || !fileManager.isEmptyFile(done)) {
			File temp = fileManager.createTempFile(done, DIRECTORY_SYSTEM+FILENAME_TEMP);;
			fileManager.restoreFromBackup(done, doneBackup);
			fileManager.restoreFromBackup(doneBackup, temp);
			temp.delete();
			taskList.resetCompletedTaskList();
			assert (taskList.getCompletedTasks().size() == 0);
			updateTaskData();
		}
		String feedback = String.format(MESSAGE_RESTORED, previousCommand);
		logger.log(Level.INFO, feedback);
		return feedback;
	}
}
```
###### simplyamazing\storage\WriteManager.java
``` java
package simplyamazing.storage;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;

public class WriteManager {
	
	private static final String CHARACTER_NEW_LINE = System.lineSeparator();
	
	public void write(File file, String content) throws Exception {
		FileWriter fileWriter = new FileWriter(file, true);
		fileWriter.write(content);
		fileWriter.write(CHARACTER_NEW_LINE);
		fileWriter.close();	
	}
	
	public void writeEmptyFile(File file) throws Exception {
		FileOutputStream writer = new FileOutputStream(file);
		writer.close();
	}
}
```
###### simplyamazing\ui\CommandBarController.java
``` java
package simplyamazing.ui;

import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

import javax.swing.JTextField;

public class CommandBarController {
	
	private static final String STRING_NULL = "";

	public void handleKeyPressedEvent(final UI ui, final JTextField commandBar) {
		commandBar.addKeyListener(new KeyAdapter() {
			@Override
			public void keyPressed(KeyEvent e) {
				if (e.isActionKey()) {				
					// "Up" key used to get previous command
					if (e.getKeyCode() == KeyEvent.VK_UP) { 
						commandBar.setText(ui.getPreviousUserCommand());
					}
				} else {				
					// "Enter" key used to execute command
					if (e.getKeyCode() == KeyEvent.VK_ENTER) { 
						ui.executeUserCommand();
					} 
				}
			}
		});
	}
	
	public void clearCommand(final JTextField commandBar) {
		commandBar.setText(STRING_NULL);
	}
}
```
###### simplyamazing\ui\InstructionPanel.java
``` java
package simplyamazing.ui;

import java.awt.Color;
import java.awt.Font;

import javax.swing.JTextPane;

public class InstructionPanel {
	
	private static final int FONT_SIZE_DEFAULT = 16;
	private static final String FONT_DEFAULT = "Tahoma";
	
	private static final String STRING_NULL = "";
	
	private JTextPane instructionPanel;
	
	public InstructionPanel() {
		instructionPanel = new JTextPane();
		instructionPanel.setForeground(Color.BLACK);
		instructionPanel.setFont(new Font(FONT_DEFAULT, Font.PLAIN, FONT_SIZE_DEFAULT));
		instructionPanel.setEditable(false);
	}
	
	public JTextPane getInstrctionPanel() {
		return instructionPanel;
	}
	
	public void setInstruction(String instruction) {
		instructionPanel.setText(instruction);
	}
	
	public void clear() {
		instructionPanel.setText(STRING_NULL);
	}
}
```
###### simplyamazing\ui\TaskDataPanel.java
``` java
package simplyamazing.ui;

import java.awt.Color;
import java.awt.Font;

import javax.swing.BorderFactory;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumnModel;

public class TaskDataPanel {
	
	private static final int WIDTH_COLUMN_STATUS = 99;
	private static final int WIDTH_COLUMN_PRIORITY = 64;
	private static final int WIDTH_COLUMN_END_TIME = 150;
	private static final int WIDTH_COLUMN_START_TIME = 150;
	private static final int WIDTH_COLUMN_DESCRIPTION = 300;
	private static final int WIDTH_COLUMN_INDEX = 40;
	
	private static final int COLUMN_STATUS = 5;
	private static final int COLUMN_PRIORITY = 4;
	private static final int COLUMN_END_TIME = 3;
	private static final int COLUMN_START_TIME = 2;
	private static final int COLUMN_DESCRIPTION = 1;
	private static final int COLUMN_INDEX = 0;
	
	private static final String TEXT_TIP = "Task Data will be shown here.";
	
	private static final int HEIGHT_ROW = 30;
	
	private static final int FONT_SIZE_HEADER = 15;
	private static final String FONT_HEADER = "Times New Roman";
	private static final String FONT_DEFAULT = "Tahoma";
	private static final int FONT_SIZE_DEFAULT = 16;
	
	private Object columnNames[] = { "#", "Description", "Start time", "End time", "Priority", "Status"};
	
	private JTable taskDataTable;
	
	public TaskDataPanel(Object[][] rowData) {
		DefaultTableModel model = new DefaultTableModel(rowData, columnNames);
		taskDataTable = new JTable(model);
		taskDataTable.setToolTipText(TEXT_TIP);
		taskDataTable.setBackground(Color.WHITE);
		taskDataTable.setForeground(Color.BLACK);
		taskDataTable.setRowHeight(HEIGHT_ROW);
		taskDataTable.setFont(new Font(FONT_DEFAULT, Font.PLAIN, FONT_SIZE_DEFAULT));
		taskDataTable.setEnabled(false);
		taskDataTable.getTableHeader().setBackground(Color.WHITE);
		taskDataTable.getTableHeader().setBorder(BorderFactory.createEtchedBorder());
		taskDataTable.getTableHeader().setFont(new Font(FONT_HEADER, Font.BOLD, FONT_SIZE_HEADER));
		taskDataTable.setBorder(BorderFactory.createEtchedBorder());
		TableColumnModel columnModel = taskDataTable.getColumnModel();
		taskDataTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		columnModel.getColumn(COLUMN_INDEX).setPreferredWidth(WIDTH_COLUMN_INDEX);
		columnModel.getColumn(COLUMN_DESCRIPTION).setPreferredWidth(WIDTH_COLUMN_DESCRIPTION);
		columnModel.getColumn(COLUMN_START_TIME).setPreferredWidth(WIDTH_COLUMN_START_TIME);
		columnModel.getColumn(COLUMN_END_TIME).setPreferredWidth(WIDTH_COLUMN_END_TIME);
		columnModel.getColumn(COLUMN_PRIORITY).setPreferredWidth(WIDTH_COLUMN_PRIORITY);
		columnModel.getColumn(COLUMN_STATUS).setPreferredWidth(WIDTH_COLUMN_STATUS);
	}
	
	public JTable getTaskDataPanel() {
		return taskDataTable;
	}
	
	public void clear() {
		taskDataTable.setVisible(false);
	}
}
```
###### simplyamazing\ui\UI.java
``` java
package simplyamazing.ui;

import java.awt.Color;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.SystemColor;
import java.io.File;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JTextArea;
import javax.swing.JTextField;

import simplyamazing.data.Task;
import simplyamazing.logic.Logic;

public class UI {
	
	private static final int X_POSITION_FRAME = 100;
	private static final int X_POSITION_APP_LOGO = 273;

	private static final int Y_POSITION_INSTRUCTION_PANEL = 57;
	private static final int Y_POSITION_COMMAND_BAR = 575;
	private static final int Y_POSITION_FEEDBACK_AREA = 542;
	private static final int Y_POSITION_SEPARATOR1 = 54;
	private static final int Y_POSITION_SCROLL_PANE = 67;
	private static final int Y_POSITION_SEPARATOR = 529;
	private static final int Y_POSITION_FRAME = 100;
	
	private static final int HEIGHT_SEPARATOR = 2;
	private static final int HEIGHT_FEEDBACK_AREA = 22;
	private static final int HEIGHT_COMMAND_BAR = 33;
	private static final int HEIGHT_INSTRUCTION_PANEL = 539;
	private static final int HEIGHT_SCROLL_PANE = 442;
	private static final int HEIGHT_APP_LOGO = 33;
	private static final int HEIGHT_FRAME = 657;

	private static final int WIDTH = 804;
	private static final int WIDTH_INSTRUCTION_PANEL = 676;
	private static final int WIDTH_APP_LOGO = 278;
	private static final int WIDTH_FRAME = 830;
	
	private static final int FONT_SIZE_COMMAND_BAR = 14;
	private static final int FONT_SIZE_DEFAULT = 16;
	private static final String FONT_APP_LOGO = "Lucida Calligraphy";
	private static final String FONT_DEFAULT = "Tahoma";
	
	private static final int OFFSET = 10;

	private static final int NUM_TASK_FIELDS = 6;

	private static final String LOGGER_NAME = "simplyamazing";
	private static final String FILENAME_LOGGER = "\\logFile.txt";

	private static final String DIRECTORY_SYSTEM = "C:\\Users\\Public\\SimplyAmazing";
	
	private static final String TEXT_APP_LOGO = "Welcome to SimplyAmazing!";
	private static final String TEXT_TIP = "Type your command here.";
	
	private static final String MESSAGE_LOGGER_FILE_CREATION_FAILED = "Logger creation failed";
	private static final String MESSAGE_WELCOME = "Please enter \"help\" to learn about available commands "
			+ "and their formats";
	private static final String MESSAGE_EMPTY_LIST = "List is empty";
	private static final String MESSAGE_NO_TASKS_FOUND = "There are no tasks containing the given keyword";

	private static final Color COLOR_DARK_GREEN = new Color(0, 128, 0);

	private static final String CHARACTER_NEW_LINE = "\n";
	private static final String STRING_NULL = "";
	private static final String STRING_ERROR = "Error";

	private static final String MESSAGE_LOG_WELCOME = "Ready to use the system";
	private static final String MESSAGE_LOG_COMPONENTS_INIITIALIZED = "UI components are initialized";
	private static final String MESSAGE_LOG_COMPONENTS_ADDED = "UI components are added to the frame";
	private static final String MESSAGE_LOG_USER_COMMAND_EXECUTED = "User command is successfully executed.";
	
	public String feedback = null;

	private JFrame frame;
	private JSeparator separator, separator_1;
	private JTextArea appLogo;
	private JScrollPane scrollPane;
	public JTextField commandBar;	
	public JTextArea feedbackArea;

	private static Logic logic;
	private static CommandBarController commandBarController;
	public static TaskDataPanel taskDataPanel;
	public static InstructionPanel instructionPanel;
	private static Logger logger;

	/*
	 * Launch the application.
	 */
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					UI window = new UI();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}

	private static String getErrorMessage(Exception e) {
		return e.getMessage();
	}

	public UI() {
		createLogger();
		
		initialize();
		addUIComponentsToFrame();
		frame.setVisible(true);
		commandBar.requestFocusInWindow();
		
		logic = new Logic();
		
		try {
			String taskDataString = getTaskData();
			if (taskDataString.contains(CHARACTER_NEW_LINE)) {
				updateTaskDataTable(taskDataString);
			} else {
				scrollPane.setVisible(false); // Hide table if no task
			}
			setFeedback(MESSAGE_WELCOME, Color.BLACK);
			logger.log(Level.INFO, MESSAGE_LOG_WELCOME);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	private void createLogger() {
		logger = Logger.getLogger(LOGGER_NAME);
		new File(DIRECTORY_SYSTEM).mkdir(); // create system directory if not exist
		try {
			FileHandler fh = new FileHandler(DIRECTORY_SYSTEM + FILENAME_LOGGER, true);
			logger.addHandler(fh);
			SimpleFormatter formatter = new SimpleFormatter();  
			fh.setFormatter(formatter);
		} catch (Exception e){
			System.out.println(MESSAGE_LOGGER_FILE_CREATION_FAILED);
		}
	}
	
	private String getTaskData() throws Exception {
		String taskDataString = Logic.getView();
		return taskDataString;
	}
	
	private void updateTaskDataTable(String taskDataString) throws Exception {
		String[] tasks = taskDataString.split(CHARACTER_NEW_LINE);

		String[][] taskData = new String[tasks.length][NUM_TASK_FIELDS];
		for (int i = 0; i < tasks.length; i++) {
			taskData[i] = tasks[i].split(Task.FIELD_SEPARATOR);
		}
		setupTaskDataPanel(taskData); 
		scrollPane.setVisible(true);
		scrollPane.setViewportView(taskDataPanel.getTaskDataPanel());
		scrollPane.getViewport().setBackground(Color.WHITE);
	}

	private void initialize() {
		setupFrame();
		setupAppLogo();
		setupScrollPane();
		setupSeparators();
		setupFeedbackArea();
		setupCommandBar();
		logger.log(Level.INFO, MESSAGE_LOG_COMPONENTS_INIITIALIZED);
	}
	
	private void setupFrame() {
		frame = new JFrame();
		frame.setResizable(false);
		frame.setBounds(X_POSITION_FRAME, Y_POSITION_FRAME, WIDTH_FRAME, HEIGHT_FRAME);
		frame.setForeground(Color.BLACK);
		frame.getContentPane().setBackground(SystemColor.window);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.getContentPane().setLayout(null);
	}
	
	private void setupAppLogo() {
		appLogo = new JTextArea();
		appLogo.setFont(new Font(FONT_APP_LOGO, Font.BOLD, FONT_SIZE_DEFAULT));
		appLogo.setEditable(false);
		appLogo.setText(TEXT_APP_LOGO);
		appLogo.setBounds(X_POSITION_APP_LOGO, OFFSET, WIDTH_APP_LOGO, HEIGHT_APP_LOGO);
	}

	private void setupScrollPane() {
		scrollPane = new JScrollPane();
		scrollPane.setBorder(BorderFactory.createEmptyBorder());
		scrollPane.setBounds(OFFSET, Y_POSITION_SCROLL_PANE, WIDTH, HEIGHT_SCROLL_PANE);
	}

	private void setupSeparators() {
		separator = new JSeparator();
		separator.setBounds(OFFSET, Y_POSITION_SEPARATOR, WIDTH, HEIGHT_SEPARATOR);
		separator_1 = new JSeparator();
		separator_1.setBounds(OFFSET, Y_POSITION_SEPARATOR1, WIDTH, HEIGHT_SEPARATOR);
	}

	private void setupFeedbackArea() {
		feedbackArea = new JTextArea();
		feedbackArea.setEditable(false);
		feedbackArea.setBounds(OFFSET, Y_POSITION_FEEDBACK_AREA, WIDTH, HEIGHT_FEEDBACK_AREA);
	}

	private void setupCommandBar() {
		commandBar = new JTextField();
		commandBar.setForeground(Color.BLACK);
		commandBar.setToolTipText(TEXT_TIP);
		commandBar.setFont(new Font(FONT_DEFAULT, Font.PLAIN, FONT_SIZE_COMMAND_BAR));
		commandBar.setColumns(OFFSET);
		commandBar.setBounds(OFFSET, Y_POSITION_COMMAND_BAR, WIDTH, HEIGHT_COMMAND_BAR);
		commandBarController = new CommandBarController();
		commandBarController.handleKeyPressedEvent(this, commandBar);
	}
	
	private void addUIComponentsToFrame() {
		frame.getContentPane().add(appLogo);
		frame.getContentPane().add(separator_1);
		frame.getContentPane().add(scrollPane);
		frame.getContentPane().add(separator);
		frame.getContentPane().add(feedbackArea);
		frame.getContentPane().add(commandBar);
		logger.log(Level.INFO, MESSAGE_LOG_COMPONENTS_ADDED);
	}

	public void executeUserCommand() {
		String command = commandBar.getText();
		commandBarController.clearCommand(commandBar);
		feedbackArea.setText(STRING_NULL);
		try {
			feedback = logic.executeCommand(command);
			logger.log(Level.INFO, MESSAGE_LOG_USER_COMMAND_EXECUTED);

			if (feedback.contains(CHARACTER_NEW_LINE)) {
				String[] tasks = feedback.split(CHARACTER_NEW_LINE);

				if (tasks[0].split(Task.FIELD_SEPARATOR).length == NUM_TASK_FIELDS) {
					updateTaskDataTable(feedback);
				} else {
					setupInstructionPanel();
					scrollPane.setVisible(true);
					scrollPane.setViewportView(instructionPanel.getInstrctionPanel());
					instructionPanel.setInstruction(feedback);
				}
			} else { // only feedback
				String taskDataString = getTaskData();
				if (taskDataString.contains(CHARACTER_NEW_LINE)) {
					updateTaskDataTable(taskDataString);
				} else {
					scrollPane.setVisible(false); // Hide table if no task
				}
				
				if (feedback.contains(STRING_ERROR)) {
					setFeedback(feedback, Color.RED);
					logger.log(Level.WARNING, feedback);
				} else  {
					if (feedback.matches(MESSAGE_EMPTY_LIST) || feedback.matches(MESSAGE_NO_TASKS_FOUND)) {
						scrollPane.setVisible(false); // Hide table if no task
					}	
					setFeedback(feedback, COLOR_DARK_GREEN);
					logger.log(Level.INFO, feedback);
				}
			} 
		} catch (Exception e1) {
			feedback = getErrorMessage(e1);
			logger.log(Level.WARNING, feedback);
			feedbackArea.setForeground(Color.RED);
			feedbackArea.setText(feedback);
		}
	}

	private void setupInstructionPanel() {
		instructionPanel = new InstructionPanel();
		instructionPanel.getInstrctionPanel().setBounds(OFFSET, Y_POSITION_INSTRUCTION_PANEL, 
				WIDTH_INSTRUCTION_PANEL, HEIGHT_INSTRUCTION_PANEL);
	}

	private void setupTaskDataPanel(Object[][] taskData) {
		taskDataPanel = new TaskDataPanel(taskData);
	}
	
	private void setFeedback(String feedback, Color color) {
		feedbackArea.setForeground(color);
		feedbackArea.setText(feedback);
	}

	public String getPreviousUserCommand() {
		String command = logic.getPreviousCommand();
		return command;
	}
}
```
###### test\StorageTest.java
``` java
package test;

import static org.junit.Assert.assertEquals;

import java.io.File;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import simplyamazing.data.Task;
import simplyamazing.storage.Storage;

public class StorageTest {
	
	private static final String DIRECTORY_SYSTEM = "C:\\Users\\Public\\SimplyAmazing";
	private static final String FILENAME_STORAGE = "\\storage.txt";
	private static final String FILENAME_TODO = "\\todo.txt";
	private static final String FILENAME_DONE = "\\done.txt";
	private static final String FILENAME_TODO_BACKUP = "\\todoBackup.txt";
	private static final String FILENAME_DONE_BACKUP = "\\doneBackup.txt";
	
	private static final String PARAM_DESCRIPTION1 = "go gym";
	private static final String PARAM_DESCRIPTION = "go swimming";
	private static final String PARAM_DESCRIPTION2 = "go camping";
	private static final String PARAM_PRIORITY = "high";
	private static final String PARAM_END_TIME = "15:00 16 May 2016";
	private static final String PARAM_END_TIME1 = "15:00 20 May 2016";
	private static final String PARAM_END_TIME2 = "15:00 27 May 2016";
	private static final String PARAM_END_TIME3 = "15:00 31 May 2016";
	private static final String PARAM_START_TIME = "13:00 16 May 2016";
	private static final String PARAM_START_TIME1 = "13:00 20 May 2016";
	private static final String PARAM_SET_LOCATION_NULL = null;
	private static final String PARAM_SET_LOCATION_EMPTY = "";
	private static final String PARAM_SET_LOCATION_NOT_DIRECTORY = "C:\\Users\\Public\\Documents\\Invalid Directory";
	private static final String PARAM_SET_LOCATION_DIRECTORY = "C:\\Users\\Public\\Documents";
	private static final String PARAM_VIEW_TASKS_NULL = null;
	private static final String PARAM_VIEW_TASKS_EMPTY = "";
	private static final String PARAM_VIEW_TASKS_EVENTS = "events";
	private static final String PARAM_VIEW_TASKS_DEADLINES = "deadlines";
	private static final String PARAM_VIEW_TASKS_FLOATING = "tasks";
	private static final String PARAM_VIEW_TASKS_OVERDUE = "overdue";
	private static final String PARAM_VIEW_TASKS_DONE = "done";
	private static final String PARAM_VIEW_TASKS_OTHERS = "other";
	private static final String PARAM_SEARCH_TASKS_NULL = null;
	private static final String PARAM_SEARCH_TASKS_EMPTY = "";
	private static final String PARAM_SEARCH_TASKS_KEYWORD = "gym";
	private static final String PARAM_SEARCH_TASKS_MORE_KEYWORD = "go gym";
	private static final String PARAM_RESTORE_NULL = null;
	private static final String PARAM_RESTORE_EMPTY = "";
	private static final String PARAM_RESTORE_COMMAND = "delete 1";
	
	private static final String FEEDBACK_LOCATION_SET = "Storage location of task data has been sucessfully set as %1$s.";
	private static final String FEEDBACK_ADDED = "%1$s has been added.";
	private static final String FEEDBACK_UPDATED = "%1$s has been successfully updated.";
	private static final String FEEDBACK_COMPLETED_TASK = "%1$s is a completed task.";
	private static final String FEEDBACK_MARKED_DONE = "%1$s has been marked as done.";
	private static final String FEEDBACK_INCOMPLETE_TASK = "%1$s is an incomplete task.";
	private static final String FEEDBACK_MARKED_UNDONE = "%1$s has been marked as incomplete.";
	private static final String FEEDBACK_MARKED_DONE_MULTIPLE = "Provided tasks have been marked as done.";
	private static final String FEEDBACK_MARKED_UNDONE_MULTIPLE = "Provided tasks have been marked as incomplete.";
	private static final String FEEDBACK_DELETED_MULTIPLE = "Provided tasks have been successfully deleted.";
	private static final String FEEDBACK_DELETED = "%1$s has been successfully deleted.";
	private static final String FEEDBACK_RESTORED = "\"%1$s\" command has been successfully undone.";
	
	/*
	 * Operation to test: setLocation(String location): String
	 * Equivalence partition: 
	 * location: [null] [not null] [not a valid directory] [a valid directory] 
	 * Boundary values: Empty String, a String of some length
	 */	
	@Test(expected = Exception.class) 
	public void testSetLocationMethodForException() throws Exception {
		Storage storage = new Storage();
		
		/* This is for the first launch of program where user hasn't set the storage location */
		File location = new File(DIRECTORY_SYSTEM+FILENAME_STORAGE);
		storage.getFileManager().createNewFile(location);
		
		/* This is for the not a valid directory partition */
		storage.setLocation(PARAM_SET_LOCATION_NOT_DIRECTORY);
	}
	
	@Test(expected = Exception.class) 
	public void testSetLocationMethodForAssertionError() throws Exception {
		Storage storage = new Storage();
		
		/* This is for the first launch of program where user hasn't set the storage location */
		File location = new File(DIRECTORY_SYSTEM+FILENAME_STORAGE);
		storage.getFileManager().createNewFile(location);
		
		/* This is for the null partition */
		storage.setLocation(PARAM_SET_LOCATION_NULL);
			
		/* This is a boundary case for the not null partition */
		storage.setLocation(PARAM_SET_LOCATION_EMPTY);
	}
	
	@Test
	public void testSetLocationMethod() throws Exception {
		Storage storage = new Storage();
		
		/* This is for the first launch of program where user hasn't set the storage location */
		File location = new File(DIRECTORY_SYSTEM+FILENAME_STORAGE);
		if (storage.getFileManager().isFileExisting(location)) {
			location.delete();
		}
		assertEquals(false, storage.getFileManager().isFileExisting(location));
		
		/* This is for the a valid directory partition */
		assertEquals(String.format(FEEDBACK_LOCATION_SET, PARAM_SET_LOCATION_DIRECTORY), storage.setLocation(PARAM_SET_LOCATION_DIRECTORY));
		assertEquals(PARAM_SET_LOCATION_DIRECTORY, storage.getLocation());
		assertEquals(1, storage.getFileManager().getLineCount(location));
	}
	
	/*
	 * Operation to test: addTask(Task task): String
	 * Equivalence partition: 
	 * task: [null] [not null] 
	 */	
	@Test(expected = Exception.class) 
	public void testAddTaskMethodForException() throws Exception {
		Storage storage = new Storage();
		
		/* This is for the successive launch of program where user has set the storage location before */
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = null;
		
		try {	
			/* This is for the null partition */
			storage.addTask(task);
		} catch (AssertionError ae) {
			throw new Exception();
		}
	}
	
	@Test
	public void testAddTaskMethod() throws Exception {
		Storage storage = new Storage();
		
		/* This is for the first launch of program where user hasn't set the storage location */
		File location = new File(DIRECTORY_SYSTEM+FILENAME_STORAGE);
		storage.getFileManager().createNewFile(location);
		
		File todo = new File(DIRECTORY_SYSTEM+FILENAME_TODO);
		File done = new File(DIRECTORY_SYSTEM+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = new Task(PARAM_DESCRIPTION);
		
		/* This is for the not null partition */
		assertEquals(0, storage.getTaskList().getTasks().size());
		assertEquals(0, storage.getFileManager().getLineCount(todo));
		assertEquals(String.format(FEEDBACK_ADDED, task.toFilteredString()), storage.addTask(task));
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(1, storage.getFileManager().getLineCount(todo));
	}

	/*
	 * Operation to test: editTask(Task task, Task editedTask): String
	 * Equivalence partition: 
	 * task: [null] [not null] 
	 * editedTask: [null] [not null]
	 */	
	@Test(expected = Exception.class) 
	public void testEditTaskMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = null, editedTask = null;
		try {	
			/* This is for the task_null partition */
			storage.editTask(task, editedTask);
			
			task = new Task(PARAM_DESCRIPTION);
			
			/* This is for the editedTask_null partition */
			storage.editTask(task, editedTask);	
		} catch (AssertionError ae) {
			throw new Exception();
		}
	}
	
	@Test
	public void testEditTaskMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		
		/* This is for program run where user hasn't added any task */
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		todo.delete();
		done.delete();
		Task task = new Task(PARAM_DESCRIPTION), editedTask = new Task(PARAM_DESCRIPTION1, PARAM_START_TIME, PARAM_END_TIME);
		editedTask.setPriority(PARAM_PRIORITY);
		storage.addTask(task);
		
		// These are for the not null partition 
		assertEquals(String.format(FEEDBACK_UPDATED, editedTask.toFilteredString()), storage.editTask(task, editedTask));
		
		task = new Task(PARAM_DESCRIPTION, PARAM_START_TIME, PARAM_END_TIME);
		editedTask = new Task(PARAM_DESCRIPTION1);
		editedTask.setStartTime(Task.DEFAULT_DATE_VALUE_FOR_NULL);
		editedTask.setEndTime(Task.DEFAULT_DATE_VALUE_FOR_NULL);
		assertEquals(String.format(FEEDBACK_UPDATED, new Task(PARAM_DESCRIPTION1).toFilteredString()), storage.editTask(task, editedTask));
		storage.getFileManager().cleanFile(todo);
	}
	
	/*
	 * Operation to test: viewTasks(String taskType): ArrayList<Task>
	 * Equivalence partition: 
	 * taskType: [null] [empty String] ["events"] ["deadlines"] ["tasks"] ["overdue"] ["done"] [any other string] 
	 */	
	@Test(expected = Exception.class) 
	public void testViewTasksMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		/* This is for the null partition */
		storage.viewTasks(PARAM_VIEW_TASKS_NULL);
		
		/* This is for the any other String partition */
		storage.viewTasks(PARAM_VIEW_TASKS_OTHERS);
	}
	
	@Test
	public void testViewTasksMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		storage.addTask(new Task(PARAM_DESCRIPTION1)); // floating task
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME)); // deadline
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_START_TIME, PARAM_END_TIME)); // event
		storage.addTask(new Task(PARAM_DESCRIPTION1, Task.convertDateToString(new Date()), Task.convertDateToString(new Date()))); // overdue
		assertEquals(4, storage.getFileManager().getLineCount(todo));
		assertEquals(4, storage.getTaskList().getTasks().size());
		
		// This is for the empty String partition 
		assertEquals(3, storage.viewTasks(PARAM_VIEW_TASKS_EMPTY).size());	
		
		// This is for the events partition 
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_EVENTS).size());
		
		// This is for the deadlines partition 
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_DEADLINES).size());
		
		// This is for the tasks partition 
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_FLOATING).size());	
		
		// This is for the overdue partition 
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_OVERDUE).size());
		
		// This is for the done partition 
		assertEquals(0, storage.viewTasks(PARAM_VIEW_TASKS_DONE).size());	
		
		storage.getFileManager().cleanFile(todo);
	}
	
	/*
	 * Operation to test: searchTasks(String keyword): ArrayList<Task>
	 * Equivalence partition: 
	 * keyword: [null] [not null]
	 * Boundary values: Empty String, a String of some length
	 */	
	@Test(expected = Exception.class) 
	public void testSearchTasksMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		try {
			/* This is for the null partition */
			storage.searchTasks(PARAM_SEARCH_TASKS_NULL);
		} catch(AssertionError ae) {
			throw new Exception();
		}
	}
	
	@Test
	public void testSearchTasksMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		storage.addTask(new Task(PARAM_DESCRIPTION));
		storage.addTask(new Task(PARAM_DESCRIPTION1));
		assertEquals(2, storage.getTaskList().getTasks().size());
		assertEquals(2, storage.getFileManager().getLineCount(todo));
		
		// This is a boundary case for the not null partition 
		assertEquals(2, storage.searchTasks(PARAM_SEARCH_TASKS_EMPTY).size());
		
		// These are for the not null partition 
		assertEquals(1, storage.searchTasks(PARAM_SEARCH_TASKS_KEYWORD).size());
		assertEquals(2, storage.searchTasks(PARAM_SEARCH_TASKS_MORE_KEYWORD).size());
		
		storage.getFileManager().cleanFile(todo);
	}
	
	/*
	 * Operation to test: searchTasks(String keyword): ArrayList<Task>
	 * Equivalence partition: 
	 * keyword: [null] [not null]
	 */
	@Test(expected = Exception.class) 
	public void testSearchTasksByDateMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		try {
			/* This is for the null partition */
			storage.searchTasksByDate(Task.convertStringToDate(PARAM_SEARCH_TASKS_NULL, Task.TIME_FORMAT));
		} catch(AssertionError ae) {
			throw new Exception();
		}
	}
	
	@Test
	public void testSearchTasksByDateMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME2)); // deadline
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME3)); // deadline
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_START_TIME, PARAM_END_TIME)); // event
		storage.addTask(new Task(PARAM_DESCRIPTION1, PARAM_START_TIME1, PARAM_END_TIME1)); // event
		storage.addTask(new Task(PARAM_DESCRIPTION1)); // floating task
		assertEquals(5, storage.getTaskList().getTasks().size());
		assertEquals(5, storage.getFileManager().getLineCount(todo));
		
		// These are for the not null partition 
		assertEquals(4, storage.searchTasksByDate(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME).getEndTime()).size());
		assertEquals(4, storage.searchTasksByDate(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME1).getEndTime()).size());
		assertEquals(3, storage.searchTasksByDate(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME2).getEndTime()).size());
		assertEquals(2, storage.searchTasksByDate(new Task(PARAM_DESCRIPTION1, PARAM_END_TIME3).getEndTime()).size());
	
		storage.getFileManager().cleanFile(todo);
	}
	
	/*
	 * Operation to test: markTaskDone(Task task): String
	 * Equivalence partition: 
	 * task: [null] [not null] [already done] 
	 */	
	@Test(expected = Exception.class) 
	public void testMarkTaskDoneMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = null;
		
		// This is for the null partition 
		storage.markTaskDone(task);
	}
	
	@Test(expected = Exception.class) 
	public void testMarkTaskDoneMethodForDoneTaskException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = new Task(PARAM_DESCRIPTION1);
		storage.addTask(task);
		
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		assertEquals(0, storage.getFileManager().getLineCount(done));
		storage.markTaskDone(task);
		
		// This is for the already done partition 
		assertEquals(String.format(FEEDBACK_COMPLETED_TASK, task.toFilteredString()), storage.markTaskDone(task));
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
	}
	
	@Test
	public void testMarkTaskDoneMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = new Task(PARAM_DESCRIPTION);
		storage.addTask(task);
			
		// This is for the not null partition
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		assertEquals(0, storage.getTaskList().getCompletedTasks().size());
		assertEquals(0, storage.getFileManager().getLineCount(done));
		assertEquals(String.format(FEEDBACK_MARKED_DONE, task.toFilteredString()), storage.markTaskDone(task));	
		assertEquals(1, storage.getFileManager().getLineCount(done));
		
		task = new Task(PARAM_DESCRIPTION1);
		storage.addTask(task);
		assertEquals(String.format(FEEDBACK_MARKED_DONE, task.toFilteredString()), storage.markTaskDone(task));	
		assertEquals(2, storage.getFileManager().getLineCount(done));
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
	}
	
	/*
	 * Operation to test: markTaskUndone(Task task): String
	 * Equivalence partition: 
	 * task: [null] [not null] [haven't done] 
	 */	
	@Test(expected = Exception.class) 
	public void testMarkTaskUndoneMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = null;
		
		// This is for the null partition 
		storage.markTaskUndone(task);
	}
	
	@Test(expected = Exception.class) 
	public void testMarkTaskUndoneMethodForUndoneTaskException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = new Task(PARAM_DESCRIPTION1);
		storage.addTask(task);
		
		// This is for the haven't done partition 
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		assertEquals(0, storage.getTaskList().getCompletedTasks().size());
		assertEquals(0, storage.getFileManager().getLineCount(done));
		assertEquals(String.format(FEEDBACK_INCOMPLETE_TASK, task.toFilteredString()), storage.markTaskUndone(task));
		
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
	}
	
	@Test
	public void testMarkTaskUndoneMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = new Task(PARAM_DESCRIPTION);
		storage.addTask(task);
		storage.markTaskDone(task);
		
		// This is for the not null partition
		assertEquals(1, storage.getTaskList().getCompletedTasks().size());
		assertEquals(1, storage.getFileManager().getLineCount(done));
		assertEquals(String.format(FEEDBACK_MARKED_UNDONE, task.toFilteredString()), storage.markTaskUndone(task));	
		assertEquals(0, storage.getFileManager().getLineCount(done));
		
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
	}
	
	/*
	 * Operation to test: markMultipleTasksDone(ArrayList<Task> tasks): String
	 * Equivalence partition: 
	 * task: [null] [not null] 
	 */
	@Test(expected = Exception.class) 
	public void testMarkMultipleTasksDoneMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		ArrayList<Task> tasks = null;
		
		// This is for the null partition 
		storage.markMultipleTasksDone(tasks);
	}
	
	@Test
	public void testMarkMultipleTasksDoneMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		ArrayList<Task> tasks = new ArrayList<Task>();
		for (int i = 0; i < 5; i++) {
			storage.addTask(new Task(PARAM_DESCRIPTION));
			if (i < 3) {
				tasks.add(new Task(PARAM_DESCRIPTION));
			}
		}
		
		// This is for the not null partition
		assertEquals(5, storage.getTaskList().getTasks().size());
		assertEquals(5, storage.getFileManager().getLineCount(todo));
		assertEquals(0, storage.getTaskList().getCompletedTasks().size());
		assertEquals(0, storage.getFileManager().getLineCount(done));
		assertEquals(String.format(FEEDBACK_MARKED_DONE_MULTIPLE), storage.markMultipleTasksDone(tasks));	
		assertEquals(3, storage.getFileManager().getLineCount(done));
		
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
	}
	
	/*
	 * Operation to test: markMultipleTasksUndone(ArrayList<Task> tasks): String
	 * Equivalence partition: 
	 * task: [null] [not null] 
	 */
	@Test(expected = Exception.class) 
	public void testMarkMultipleTasksUnoneMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		ArrayList<Task> tasks = null;
		
		// This is for the null partition 
		storage.markMultipleTasksUndone(tasks);
	}
	
	@Test
	public void testMarkMultipleTasksUndoneMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		ArrayList<Task> tasks = new ArrayList<Task>();
		Task task = new Task(PARAM_DESCRIPTION), doneTask1 = new Task(PARAM_DESCRIPTION1), doneTask2 = new Task(PARAM_DESCRIPTION2);
		storage.addTask(task);
		storage.addTask(doneTask1);
		storage.addTask(doneTask2);
		storage.markTaskDone(doneTask1);
		storage.markTaskDone(doneTask2);
		tasks.add(doneTask1);
		tasks.add(doneTask2);
		
		// This is for the not null partition
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		assertEquals(2, storage.getTaskList().getCompletedTasks().size());
		assertEquals(2, storage.getFileManager().getLineCount(done));
		assertEquals(String.format(FEEDBACK_MARKED_UNDONE_MULTIPLE), storage.markMultipleTasksUndone(tasks));	
		assertEquals(3, storage.getTaskList().getTasks().size());
		assertEquals(3, storage.getFileManager().getLineCount(todo));
		assertEquals(0, storage.getTaskList().getCompletedTasks().size());
		assertEquals(0, storage.getFileManager().getLineCount(done));
	
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
	}
	
	/*
	 * Operation to test: deleteTask(Task task): String
	 * Equivalence partition: 
	 * task: [null] [not null]
	 */	
	@Test(expected = Exception.class) 
	public void testDeleteTaskMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = null;
		
		/* This is for the 'null' partition */
		storage.deleteTask(task);
	}	
	
	@Test
	public void testDeleteTaskMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		File todoBackup = new File(DIRECTORY_SYSTEM+FILENAME_TODO_BACKUP);
		File doneBackup = new File(DIRECTORY_SYSTEM+FILENAME_DONE_BACKUP);
		todoBackup.delete();
		doneBackup.delete();
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		storage.addTask(new Task(PARAM_DESCRIPTION));
		Task task = new Task(PARAM_DESCRIPTION);
		
		// This is for the 'not null' partition 
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(String.format(FEEDBACK_DELETED, task.toFilteredString()), storage.deleteTask(task));
		assertEquals(0, storage.getTaskList().getCompletedTasks().size());
	
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
	}
	
	/*
	 * Operation to test: deleteMultipleTasks(ArrayList<Task> tasks): String
	 * Equivalence partition: 
	 * task: [null] [not null] 
	 */
	@Test(expected = Exception.class) 
	public void testDeleteMultipleTasksForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		ArrayList<Task> tasks = null;
		
		// This is for the null partition 
		storage.deleteMultipleTasks(tasks);
	}
	
	@Test
	public void testDeleteMultipleTasksMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		ArrayList<Task> tasks = new ArrayList<Task>();
		Task task = new Task(PARAM_DESCRIPTION), doneTask1 = new Task(PARAM_DESCRIPTION1), doneTask2 = new Task(PARAM_DESCRIPTION2);
		storage.addTask(task);
		storage.addTask(doneTask1);
		storage.addTask(doneTask2);
		tasks.add(doneTask1);
		tasks.add(doneTask2);
		
		// This is for the not null partition
		assertEquals(3, storage.getTaskList().getTasks().size());
		assertEquals(3, storage.getFileManager().getLineCount(todo));
		assertEquals(String.format(FEEDBACK_DELETED_MULTIPLE), storage.deleteMultipleTasks(tasks));	
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(1, storage.getFileManager().getLineCount(todo));
	
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
	}
	
	/*
	 * Operation to test: restore(String previousCommand): String
	 * Equivalence partition: 
	 * previousCommand: [null] [not null] 
	 * Boundary values: Empty String, a String of some length
	 */	
	@Test
	public void testRestoreMethodForException() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		/* This is for the null partition */
		storage.restore(PARAM_RESTORE_NULL);
			
		/* This is a boundary case for the not null partition */
		storage.restore(PARAM_RESTORE_EMPTY);
	}
	
	@Test
	public void testRestoreMethod() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		Task task = new Task(PARAM_DESCRIPTION);
		
		/* This is for the 'not null' partition */
		assertEquals(0, storage.getTaskList().getTasks().size());
		assertEquals(0, storage.getFileManager().getLineCount(todo));
		storage.addTask(task);
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		
		storage.deleteTask(task);
		assertEquals(0, storage.getTaskList().getTasks().size());
		assertEquals(0, storage.getFileManager().getLineCount(todo));
		
		assertEquals(String.format(FEEDBACK_RESTORED, PARAM_RESTORE_COMMAND), storage.restore(PARAM_RESTORE_COMMAND));
		assertEquals(1, storage.getTaskList().getTasks().size());
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
	}
}
```
###### test\SystemTest.java
``` java
package test;

import static org.junit.Assert.assertEquals;

import java.io.File;

import org.junit.Test;

import simplyamazing.logic.Logic;
import simplyamazing.parser.Parser;
import simplyamazing.storage.Storage;

public class SystemTest { 

	private static final String INDEX_THREE = "3";
	private static final String INDEX_TWO = "2";
	private static final String CHARACTER_SEPARATOR = ",";
	private static final String INDEX_ONE = "1";
	private static final String CHARACTER_NEW_LINE = "\n";
	private static final String DIRECTORY_SYSTEM = "C:\\Users\\Public\\SimplyAmazing";
	private static final String FILENAME_STORAGE = "\\storage.txt";
	private static final String FILENAME_TODO = "\\todo.txt";
	private static final String FILENAME_DONE = "\\done.txt";
	
	private static final String CHARACTER_SPACE = " ";
	
	private static final String COMMAND_NULL = null;
	private static final String COMMAND_EMPTY = "";
	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_DELETE = "delete";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_VIEW = "view";
	private static final String COMMAND_SEARCH = "search";
	private static final String COMMAND_HELP = "help";
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_REDO = "redo";
	private static final String COMMAND_SET_LOCATION = "location";
	private static final String COMMAND_MARK_AS_DONE = "done";
	private static final String COMMAND_UNMARK = "unmark";
	private static final String COMMAND_EXIT = "exit";
	private static final String COMMAND_INVALID = "abcd";
	
	private static final String TASK_TYPE_EVENTS = "events";
	private static final String TASK_TYPE_DEADLINES = "deadlines";
	private static final String TASK_TYPE_FLOATING = "tasks";
	private static final String TASK_TYPE_OVERDUE = "overdue";
	private static final String TASK_TYPE_DONE = "done";
	
	private static final String COMMAND_SET_LOCATION_EMPTY = COMMAND_SET_LOCATION;
	private static final String COMMAND_SET_LOCATION_NOT_DIRECTORY = COMMAND_SET_LOCATION + CHARACTER_SPACE 
			+ "C:\\Users\\Public\\Documents\\SimplyAmazing";
	private static final String COMMAND_SET_LOCATION_DIRECTORY = COMMAND_SET_LOCATION + CHARACTER_SPACE 
			+ "C:\\Users\\Public\\Documents";
	
	private static final String COMMAND_ADD_TASK_EMPTY = COMMAND_ADD;
	private static final String COMMAND_ADD_TASK_WITH_PASSED_DEADLINE = COMMAND_ADD + CHARACTER_SPACE 
			+ "sleep by 3:00 24 Mar 2016";;
	private static final String COMMAND_ADD_TASK_WITH_STARTIME_ONLY = COMMAND_ADD + CHARACTER_SPACE 
			+ "sleep from 13:00 24 May 2017";
	private static final String COMMAND_ADD_TASK_WITH_STARTIME_AFTER_ENDTIME = COMMAND_ADD + CHARACTER_SPACE 
			+ "sleep from 10:00 24 May 2017 to 8:00 24 May 2017";
	private static final String COMMAND_ADD_FLOATING_TASK = COMMAND_ADD + CHARACTER_SPACE + "hello world";
	private static final String COMMAND_ADD_FLOATING_TASK_WITH_KEYWORDS = COMMAND_ADD + CHARACTER_SPACE 
			+ "drop by post office to deliver parcel received from Lndon";
	private static final String COMMAND_ADD_DEADLINE = COMMAND_ADD + CHARACTER_SPACE 
			+ "cs2103 peer review by 23:59 25 May 2017";
	private static final String COMMAND_ADD_DEADLINE_WITH_KEYWORDS = COMMAND_ADD + CHARACTER_SPACE 
			+ "drop by post office to deliver parcel received from Landon by 23:59 25 May 2017";
	private static final String COMMAND_ADD_EVENT = COMMAND_ADD + CHARACTER_SPACE 
			+ "hackathon in SOC from 09:30 26 May 2017 to 10:00 27 May 2017";
	private static final String COMMAND_ADD_EVENT_WITH_KEYWORDS = COMMAND_ADD + CHARACTER_SPACE 
			+ "drop by post office to deliver parcel received from Landon "
			+ "from 09:30 26 May 2017 to 10:00 27 May 2017";
	
	private static final String COMMAND_VIEW_TASKS_EMPTY = COMMAND_VIEW;
	private static final String COMMAND_VIEW_TASKS_EVENTS = COMMAND_VIEW + CHARACTER_SPACE + TASK_TYPE_EVENTS;
	private static final String COMMAND_VIEW_TASKS_DEADLINES = COMMAND_VIEW + CHARACTER_SPACE 
			+ TASK_TYPE_DEADLINES;
	private static final String COMMAND_VIEW_TASKS_FLOATING = COMMAND_VIEW + CHARACTER_SPACE + TASK_TYPE_FLOATING;
	private static final String COMMAND_VIEW_TASKS_OVERDUE = COMMAND_VIEW + CHARACTER_SPACE + TASK_TYPE_OVERDUE;
	private static final String COMMAND_VIEW_TASKS_DONE = COMMAND_VIEW + CHARACTER_SPACE + TASK_TYPE_DONE;
	private static final String COMMAND_VIEW_TASKS_OTHERS = COMMAND_VIEW + CHARACTER_SPACE + "other";
	
	private static final String COMMAND_SEARCH_TASKS_EMPTY = COMMAND_SEARCH;
	private static final String COMMAND_SEARCH_TASKS_KEYWORD =  COMMAND_SEARCH + CHARACTER_SPACE + "hello";
	private static final String COMMAND_SEARCH_TASKS_OTHER_KEYWORD =  COMMAND_SEARCH + CHARACTER_SPACE + "other";
	
	private static final String COMMAND_HELP_INTEGER = COMMAND_HELP + CHARACTER_SPACE + INDEX_ONE;
	private static final String COMMAND_HELP_INVALID = COMMAND_HELP + CHARACTER_SPACE + COMMAND_INVALID;
	private static final String COMMAND_HELP_ALL = COMMAND_HELP;
	private static final String COMMAND_HELP_LOCATION = COMMAND_HELP + CHARACTER_SPACE + COMMAND_SET_LOCATION;
	private static final String COMMAND_HELP_ADD = COMMAND_HELP + CHARACTER_SPACE + COMMAND_ADD;
	private static final String COMMAND_HELP_VIEW = COMMAND_HELP + CHARACTER_SPACE + COMMAND_VIEW;
	private static final String COMMAND_HELP_EDIT = COMMAND_HELP + CHARACTER_SPACE + COMMAND_EDIT;
	private static final String COMMAND_HELP_DELETE = COMMAND_HELP + CHARACTER_SPACE + COMMAND_DELETE;
	private static final String COMMAND_HELP_UNDO = COMMAND_HELP + CHARACTER_SPACE + COMMAND_UNDO;
	private static final String COMMAND_HELP_MARK = COMMAND_HELP + CHARACTER_SPACE + "mark";
	private static final String COMMAND_HELP_SEARCH = COMMAND_HELP + CHARACTER_SPACE + COMMAND_SEARCH;
	private static final String COMMAND_HELP_EXIT = COMMAND_HELP + CHARACTER_SPACE + COMMAND_EXIT;
	private static final String COMMAND_HELP_REDO = COMMAND_HELP + CHARACTER_SPACE + COMMAND_REDO;
	private static final String COMMAND_HELP_UNMARK = COMMAND_HELP + CHARACTER_SPACE + COMMAND_UNMARK;
	
	private static final String COMMAND_DELETE_NEGATIVE_INDEX = COMMAND_DELETE + CHARACTER_SPACE + "-1";
	private static final String COMMAND_DELETE_ZERO_INDEX = COMMAND_DELETE + CHARACTER_SPACE + "0";
	private static final String COMMAND_DELETE_LARGER_INDEX = COMMAND_DELETE + CHARACTER_SPACE + "4";
	private static final String COMMAND_DELETE_STRING = COMMAND_DELETE + CHARACTER_SPACE + COMMAND_INVALID;
	private static final String COMMAND_DELETE_MULTIPLE_INVALID = COMMAND_DELETE + CHARACTER_SPACE + "1 2 4";
	private static final String COMMAND_DELETE_SINGLE = COMMAND_DELETE + CHARACTER_SPACE + INDEX_ONE;
	private static final String COMMAND_DELETE_MULTIPLE = COMMAND_DELETE + CHARACTER_SPACE + "1 2";
	
	private static final String COMMAND_MARK_NEGATIVE_INDEX = COMMAND_MARK_AS_DONE + CHARACTER_SPACE + "-1";
	private static final String COMMAND_MARK_ZERO_INDEX = COMMAND_MARK_AS_DONE + CHARACTER_SPACE + "0";
	private static final String COMMAND_MARK_LARGER_INDEX = COMMAND_MARK_AS_DONE + CHARACTER_SPACE + "4";
	private static final String COMMAND_MARK_STRING = COMMAND_MARK_AS_DONE + CHARACTER_SPACE + COMMAND_INVALID;
	private static final String COMMAND_MARK_MULTIPLE_INVALID = COMMAND_MARK_AS_DONE + CHARACTER_SPACE + "1 2 4";
	private static final String COMMAND_MARK_SINGLE = COMMAND_MARK_AS_DONE + CHARACTER_SPACE + INDEX_ONE;
	private static final String COMMAND_MARK_MULTIPLE = COMMAND_MARK_AS_DONE + CHARACTER_SPACE + "1 2";
	
	private static final String PARAM_SET_LOCATION_DIRECTORY = "C:\\Users\\Public\\Documents";
	private static final String PARAM_VIEW_TASKS_EMPTY = "";
	private static final String PARAM_VIEW_TASKS_EVENTS = "events";
	private static final String PARAM_VIEW_TASKS_DEADLINES = "deadlines";
	private static final String PARAM_VIEW_TASKS_FLOATING = "tasks";
	private static final String PARAM_VIEW_TASKS_OVERDUE = "overdue";
	private static final String PARAM_VIEW_TASKS_DONE = "done";
	
	private static final String FEEDBACK_LOCATION_SET = "Storage location of task data "
			+ "has been sucessfully set as %1$s.";
	private static final String FEEDBACK_LOCATION_INVALID = "Error: Location provided is invalid";
	private static final String FEEDBACK_LOCATION_NOT_DIRECTORY = "Error: Not a valid directory";
	
	private static final String FEEDBACK_ADDED = "%1$s has been added.";
	private static final String FEEDBACK_ADD_TASK_FIELDS_NOT_CORRECT = "Error: Please ensure the fields "
			+ "are correct";
	private static final String FEEDBACK_ADD_TASK_START_AFTER_END ="Error: Start date and time cannot be "
			+ "after the End date and time";
	private static final String FEEDBACK_ADD_TASK_DATE_BEFORE_CURRENT ="Error: Time provided must be "
			+ "after the current time";
	
	private static final String FEEDBACK_MARKED_DONE = "%1$s has been marked as done.";
	private static final String FEEDBACK_DELETED = "%1$s has been successfully deleted.";
	private static final String FEEDBACK_UNDO = "\"%1$s\" command has been successfully undone.";
	private static final String FEEDBACK_REDO = "\"%1$s\" command has been successfully executed again.";
	private static final Object FEEDBACK_EMPTY_LIST = "List is empty";
	private static final Object FEEDBACK_NO_TASK_FOUND = "There are no tasks containing the given keyword";
	private static final String FEEDBACK_INVALID_INDEX= "Error: The Index entered is invalid";
	private static final String FEEDBACK_INDEX_IS_STRING = "Error: Index provided is not an Integer.";
	private static final String FEEDBACK_MULTIPLE_INVALID = "Error: One of the given indexes is invalid";
	private static final String FEEDBACK_MULTIPLE_DELETE_VALID = "Provided tasks have been successfully deleted.";
	private static final String FEEDBACK_MULTIPLE_DONE_VALID = "Provided tasks have been marked as done.";
	private static final String FEEDBACK_NOTHING_TO_UNDO = "Error: There is no previous command to undo";
	private static final String FEEDBACK_NOTHING_TO_REDO = "Error: There is no previous command to redo";
	
```
###### test\SystemTest.java
``` java
	/*
	 * Operation to test: executeCommand(String command): String
	 * Equivalence partition: 
	 * command: [null] [not null] [valid] [not valid]
	 * Boundary values: Empty String, a String of some length
	 */	
	@Test(expected = Exception.class) 
	public void testInvalidCommandsForException() throws Exception {
		Logic logic = new Logic();
		try {
			/* This is for the null partition */
			logic.executeCommand(COMMAND_NULL);
		} catch (AssertionError ae) {
			throw new Exception();
		}
		
		try {
			/* This is a boundary case for the not null partition */
			logic.executeCommand(COMMAND_EMPTY);
		} catch (AssertionError ae) {
			throw new Exception();
		}
		
		/* This is for the not valid partition */
		logic.executeCommand(COMMAND_INVALID);
	}
	
	@Test
	public void testSetLocationCommand() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		/* These are for the not valid partition */
		assertEquals(true, parser.getHandler(COMMAND_SET_LOCATION_EMPTY).getHasError());
		assertEquals(COMMAND_SET_LOCATION, parser.getHandler(COMMAND_SET_LOCATION_EMPTY).getCommandType());
		assertEquals(FEEDBACK_LOCATION_INVALID, logic.executeCommand(COMMAND_SET_LOCATION_EMPTY));
		
		assertEquals(COMMAND_SET_LOCATION, parser.getHandler(COMMAND_SET_LOCATION_NOT_DIRECTORY).getCommandType());
		assertEquals(FEEDBACK_LOCATION_NOT_DIRECTORY, logic.executeCommand(COMMAND_SET_LOCATION_NOT_DIRECTORY));
		
		/* This is for the valid partition */
		assertEquals(false, parser.getHandler(COMMAND_SET_LOCATION_DIRECTORY).getHasError());
		assertEquals(COMMAND_SET_LOCATION, parser.getHandler(COMMAND_SET_LOCATION_DIRECTORY).getCommandType());
		assertEquals(String.format(FEEDBACK_LOCATION_SET, PARAM_SET_LOCATION_DIRECTORY), 
				logic.executeCommand(COMMAND_SET_LOCATION_DIRECTORY));
		assertEquals(PARAM_SET_LOCATION_DIRECTORY, storage.getLocation());
	}
	
	@Test
	public void testAddTaskCommand() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		/* This is for the first launch of program where user hasn't set the storage location */
		File location = new File(DIRECTORY_SYSTEM+FILENAME_STORAGE);
		storage.getFileManager().createNewFile(location);
		File todo = new File(DIRECTORY_SYSTEM+FILENAME_TODO);
		File done = new File(DIRECTORY_SYSTEM+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		assertEquals(0, storage.getFileManager().getLineCount(todo));
		
		/* These are for the invalid partition */
		assertEquals(true, parser.getHandler(COMMAND_ADD_TASK_EMPTY).getHasError());
		assertEquals(FEEDBACK_ADD_TASK_FIELDS_NOT_CORRECT, logic.executeCommand(COMMAND_ADD_TASK_EMPTY));
		
		assertEquals(true, parser.getHandler(COMMAND_ADD_TASK_WITH_PASSED_DEADLINE).getHasError());
		assertEquals(FEEDBACK_ADD_TASK_DATE_BEFORE_CURRENT, 
				logic.executeCommand(COMMAND_ADD_TASK_WITH_PASSED_DEADLINE));
		
		assertEquals(true, parser.getHandler(COMMAND_ADD_TASK_WITH_STARTIME_ONLY).getHasError());
		assertEquals(FEEDBACK_ADD_TASK_FIELDS_NOT_CORRECT, 
				logic.executeCommand(COMMAND_ADD_TASK_WITH_STARTIME_ONLY));
		
		assertEquals(true, parser.getHandler(COMMAND_ADD_TASK_WITH_STARTIME_AFTER_ENDTIME).getHasError());
		assertEquals(FEEDBACK_ADD_TASK_START_AFTER_END, 
				logic.executeCommand(COMMAND_ADD_TASK_WITH_STARTIME_AFTER_ENDTIME));
		
		/* These are for the valid partition */
		assertEquals(false, parser.getHandler(COMMAND_ADD_FLOATING_TASK).getHasError());
		assertEquals(COMMAND_ADD, parser.getHandler(COMMAND_ADD_FLOATING_TASK).getCommandType());
		assertEquals(String.format(FEEDBACK_ADDED, 
				parser.getHandler(COMMAND_ADD_FLOATING_TASK).getTask().toFilteredString()), 
				logic.executeCommand(COMMAND_ADD_FLOATING_TASK));
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		
		assertEquals(false, parser.getHandler(COMMAND_ADD_FLOATING_TASK_WITH_KEYWORDS).getHasError());
		assertEquals(COMMAND_ADD, parser.getHandler(COMMAND_ADD_FLOATING_TASK_WITH_KEYWORDS).getCommandType());
		assertEquals(String.format(FEEDBACK_ADDED, 
				parser.getHandler(COMMAND_ADD_FLOATING_TASK_WITH_KEYWORDS).getTask().toFilteredString()), 
				logic.executeCommand(COMMAND_ADD_FLOATING_TASK_WITH_KEYWORDS));
		assertEquals(2, storage.getFileManager().getLineCount(todo));
		
		assertEquals(false, parser.getHandler(COMMAND_ADD_DEADLINE).getHasError());
		assertEquals(COMMAND_ADD, parser.getHandler(COMMAND_ADD_DEADLINE).getCommandType());
		assertEquals(String.format(FEEDBACK_ADDED, 
				parser.getHandler(COMMAND_ADD_DEADLINE).getTask().toFilteredString()), 
				logic.executeCommand(COMMAND_ADD_DEADLINE));
		assertEquals(3, storage.getFileManager().getLineCount(todo));
		
		assertEquals(false, parser.getHandler(COMMAND_ADD_DEADLINE_WITH_KEYWORDS).getHasError());
		assertEquals(COMMAND_ADD, parser.getHandler(COMMAND_ADD_DEADLINE_WITH_KEYWORDS).getCommandType());
		assertEquals(String.format(FEEDBACK_ADDED, 
				parser.getHandler(COMMAND_ADD_DEADLINE_WITH_KEYWORDS).getTask().toFilteredString()), 
				logic.executeCommand(COMMAND_ADD_DEADLINE_WITH_KEYWORDS));
		assertEquals(4, storage.getFileManager().getLineCount(todo));
		
		assertEquals(false, parser.getHandler(COMMAND_ADD_EVENT).getHasError());
		assertEquals(COMMAND_ADD, parser.getHandler(COMMAND_ADD_EVENT).getCommandType());
		assertEquals(String.format(FEEDBACK_ADDED, 
				parser.getHandler(COMMAND_ADD_EVENT).getTask().toFilteredString()), 
				logic.executeCommand(COMMAND_ADD_EVENT));
		assertEquals(5, storage.getFileManager().getLineCount(todo));
		
		assertEquals(false, parser.getHandler(COMMAND_ADD_EVENT_WITH_KEYWORDS).getHasError());
		assertEquals(String.format(FEEDBACK_ADDED, 
				parser.getHandler(COMMAND_ADD_EVENT_WITH_KEYWORDS).getTask().toFilteredString()), 
				logic.executeCommand(COMMAND_ADD_EVENT_WITH_KEYWORDS));
		assertEquals(6, storage.getFileManager().getLineCount(todo));
	}
	
	@Test
	public void testViewTasksMethod() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		logic.executeCommand(COMMAND_SET_LOCATION_DIRECTORY);
		
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		logic.executeCommand(COMMAND_ADD_FLOATING_TASK); // add floating task
		logic.executeCommand(COMMAND_ADD_DEADLINE); // add deadline
		logic.executeCommand(COMMAND_ADD_EVENT); // add event
		assertEquals(3, storage.getFileManager().getLineCount(todo));
		
		/* This is for the invalid partition */
		assertEquals(true, parser.getHandler(COMMAND_VIEW_TASKS_OTHERS).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_OTHERS).getCommandType());
		assertEquals(parser.getHandler(COMMAND_VIEW_TASKS_OTHERS).getFeedBack(), 
				logic.executeCommand(COMMAND_VIEW_TASKS_OTHERS));
		
		// These are for the valid partition 
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_EMPTY).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_EMPTY).getCommandType());
		assertEquals(INDEX_ONE+CHARACTER_SEPARATOR+parser.getHandler(COMMAND_ADD_DEADLINE).getTask().toString()+CHARACTER_NEW_LINE
				+INDEX_TWO+CHARACTER_SEPARATOR+parser.getHandler(COMMAND_ADD_EVENT).getTask().toString()+CHARACTER_NEW_LINE
				+INDEX_THREE+CHARACTER_SEPARATOR+parser.getHandler(COMMAND_ADD_FLOATING_TASK).getTask().toString()+CHARACTER_NEW_LINE, 
				logic.executeCommand(COMMAND_VIEW_TASKS_EMPTY));	
		assertEquals(3, storage.viewTasks(PARAM_VIEW_TASKS_EMPTY).size());	
		
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_EVENTS).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_EVENTS).getCommandType());
		assertEquals(INDEX_ONE+CHARACTER_SEPARATOR+parser.getHandler(COMMAND_ADD_EVENT).getTask().toString()+CHARACTER_NEW_LINE, 
				logic.executeCommand(COMMAND_VIEW_TASKS_EVENTS));
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_EVENTS).size());
		
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_DEADLINES).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_DEADLINES).getCommandType());
		assertEquals(INDEX_ONE+CHARACTER_SEPARATOR+parser.getHandler(COMMAND_ADD_DEADLINE).getTask().toString()+CHARACTER_NEW_LINE, 
				logic.executeCommand(COMMAND_VIEW_TASKS_DEADLINES));
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_DEADLINES).size());
		
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_FLOATING).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_FLOATING).getCommandType());
		assertEquals(INDEX_ONE+CHARACTER_SEPARATOR+parser.getHandler(COMMAND_ADD_FLOATING_TASK).getTask().toString()+CHARACTER_NEW_LINE, 
				logic.executeCommand(COMMAND_VIEW_TASKS_FLOATING));	
		assertEquals(1, storage.viewTasks(PARAM_VIEW_TASKS_FLOATING).size());
		
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_OVERDUE).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_OVERDUE).getCommandType());
		assertEquals(FEEDBACK_EMPTY_LIST, logic.executeCommand(COMMAND_VIEW_TASKS_OVERDUE));
		assertEquals(0, storage.viewTasks(PARAM_VIEW_TASKS_OVERDUE).size());
		
		assertEquals(false, parser.getHandler(COMMAND_VIEW_TASKS_DONE).getHasError());
		assertEquals(COMMAND_VIEW, parser.getHandler(COMMAND_VIEW_TASKS_DONE).getCommandType());
		assertEquals(FEEDBACK_EMPTY_LIST, logic.executeCommand(COMMAND_VIEW_TASKS_DONE));	
		assertEquals(0, storage.viewTasks(PARAM_VIEW_TASKS_DONE).size());	
	}
	
	@Test
	public void testSearchTasksMethod() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		logic.executeCommand(COMMAND_SET_LOCATION_DIRECTORY);
		
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		logic.executeCommand(COMMAND_ADD_FLOATING_TASK); // add floating task
		assertEquals(1, storage.getFileManager().getLineCount(todo));
		
		// These are for the valid partition 
		assertEquals(false, parser.getHandler(COMMAND_SEARCH_TASKS_EMPTY).getHasError());
		assertEquals(COMMAND_SEARCH, parser.getHandler(COMMAND_SEARCH_TASKS_EMPTY).getCommandType());
		assertEquals(INDEX_ONE+CHARACTER_SEPARATOR+parser.getHandler(COMMAND_ADD_FLOATING_TASK).getTask().toString()+CHARACTER_NEW_LINE, 
				logic.executeCommand(COMMAND_SEARCH_TASKS_EMPTY));
		
		assertEquals(false, parser.getHandler(COMMAND_SEARCH_TASKS_KEYWORD).getHasError());
		assertEquals(COMMAND_SEARCH, parser.getHandler(COMMAND_SEARCH_TASKS_KEYWORD).getCommandType());
		assertEquals(INDEX_ONE+CHARACTER_SEPARATOR+parser.getHandler(COMMAND_ADD_FLOATING_TASK).getTask().toString()+CHARACTER_NEW_LINE, 
				logic.executeCommand(COMMAND_SEARCH_TASKS_KEYWORD));
	
		assertEquals(false, parser.getHandler(COMMAND_SEARCH_TASKS_OTHER_KEYWORD).getHasError());
		assertEquals(COMMAND_SEARCH, parser.getHandler(COMMAND_SEARCH_TASKS_OTHER_KEYWORD).getCommandType());
		assertEquals(FEEDBACK_NO_TASK_FOUND, logic.executeCommand(COMMAND_SEARCH_TASKS_OTHER_KEYWORD));
	}
	
	
```
###### test\UITest.java
``` java
package test;

import static org.junit.Assert.assertEquals;

import java.awt.event.KeyEvent;
import java.io.File;
import java.util.ArrayList;

import org.junit.BeforeClass;
import org.junit.Test;

import simplyamazing.data.Task;
import simplyamazing.storage.Storage;
import simplyamazing.ui.CommandBarController;
import simplyamazing.ui.UI;

public class UITest {
	
	private static final String FILENAME_TODO = "\\todo.txt";
	private static final String FILENAME_DONE = "\\done.txt";
	
	private static final String CHARACTER_NEW_LINE = "\n";
	private static final String CHARACTER_SPACE = " ";
	
	private static final String COMMAND_EMPTY = "";
	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_VIEW = "view";
	private static final String COMMAND_HELP = "help";
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_ADD_EVENT = COMMAND_ADD + CHARACTER_SPACE 
			+ "hackathon in SOC from 09:30 26 May 2017 to 10:00 27 May 2017";
	private static final String COMMAND_ADD_DEADLINE = COMMAND_ADD + CHARACTER_SPACE 
			+ "cs2103 peer review by 23:59 25 May 2017";
	private static final String COMMAND_EDIT_PRIORITY = "edit 1 priority high";
	private static final String COMMAND_DELETE_DEADLINE = "delete 1";
	
	private static final String PARAM_SET_LOCATION_DIRECTORY = "C:\\Users\\Public\\Documents";
	
	private static final String FEEDBACK_COMMAND_EMPTY = "Error: Invalid command entered."
			+ " Please enter \"help\" to view all commands and their format";
	private static final String FEEDBACK_NO_PREVIOUS_COMMAND = "Error: There is no previous command to undo";
	private static final String FEEDBACK_EMPTY_LIST = "List is empty";
	
	private static final String FEEDBACK_HELP_ALL = "Key in the following to view specific command formats:\n"
			+ "1. help add\n2. help delete\n3. help edit\n4. help view\n5. help search \n6. help mark\n"
			+ "7. help unmark\n8. help undo\n9. help redo\n10. help location \n11. help exit\n";
	private static final String FEEDBACK_DELETE_DEADLINE = "\"delete 1\" command has been successfully undone.";
	
	@BeforeClass
	public static void setup() throws Exception {
		Storage storage = new Storage();
		storage.setLocation(PARAM_SET_LOCATION_DIRECTORY);
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
	}
	
	/*
	 * Operation to test: executeUserCommand(String command): String
	 * Equivalence partition: 
	 * command: [null] [not null] [valid] [not valid]
	 * Boundary values: Empty String, a String of some length
	 */	
	
	@Test
	public void testEmptyCommand() {
		UI ui = new UI();
		
		new CommandBarController().clearCommand(ui.commandBar);
		KeyEvent event = new KeyEvent(ui.commandBar, 
                KeyEvent.KEY_PRESSED, System.currentTimeMillis(), 0, 
                KeyEvent.VK_ENTER, KeyEvent.CHAR_UNDEFINED);
        ui.commandBar.dispatchEvent(event); 
	    assertEquals(FEEDBACK_COMMAND_EMPTY, ui.feedbackArea.getText()); 
	}
	
	@Test
	public void testUndoCommandWithoutAnyPreviousCommand() throws Exception {
		UI ui = new UI();
		
		ui.commandBar.setText(COMMAND_UNDO);
		KeyEvent event = new KeyEvent(ui.commandBar, 
                KeyEvent.KEY_PRESSED, System.currentTimeMillis(), 0, 
                KeyEvent.VK_ENTER, KeyEvent.CHAR_UNDEFINED);
        ui.commandBar.dispatchEvent(event); 
	    assertEquals(FEEDBACK_NO_PREVIOUS_COMMAND, ui.feedbackArea.getText());
	}
	
	@Test
	public void testHelpCommand() {
		UI ui = new UI();
		ui.commandBar.setText(COMMAND_HELP);
		KeyEvent event = new KeyEvent(ui.commandBar, 
                KeyEvent.KEY_PRESSED, System.currentTimeMillis(), 0, 
                KeyEvent.VK_ENTER, KeyEvent.CHAR_UNDEFINED);
        ui.commandBar.dispatchEvent(event); 
	    assertEquals(FEEDBACK_HELP_ALL, ui.instructionPanel.getInstrctionPanel().getText());
	}
	
	@Test
	public void testViewCommandForNoTask() {
		UI ui = new UI();
		
		ui.commandBar.setText(COMMAND_VIEW);
		KeyEvent event = new KeyEvent(ui.commandBar, 
                KeyEvent.KEY_PRESSED, System.currentTimeMillis(), 0, 
                KeyEvent.VK_ENTER, KeyEvent.CHAR_UNDEFINED);
        ui.commandBar.dispatchEvent(event); 
	    assertEquals(FEEDBACK_EMPTY_LIST, ui.feedbackArea.getText());
	}
	
	@Test
	public void testViewCommandWithTasks() throws Exception {
		UI ui = new UI();
		ui.commandBar.setText(COMMAND_ADD_EVENT);
		KeyEvent event = new KeyEvent(ui.commandBar, 
                KeyEvent.KEY_PRESSED, System.currentTimeMillis(), 0, 
                KeyEvent.VK_ENTER, KeyEvent.CHAR_UNDEFINED);
        ui.commandBar.dispatchEvent(event); 
        
        ui.commandBar.setText(COMMAND_ADD_DEADLINE);
        ui.commandBar.dispatchEvent(event); 
        
        ui.commandBar.setText(COMMAND_EDIT_PRIORITY);
        ui.commandBar.dispatchEvent(event); 
	    
        ui.commandBar.setText(COMMAND_VIEW);
        ui.commandBar.dispatchEvent(event); 
        
        File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
        Storage storage = new Storage();
        ArrayList<String> lines = storage.getFileManager().readFile(todo);
        String tasks = COMMAND_EMPTY;
        for (int i=0; i<lines.size(); i++) {
        	tasks += (i+1) + Task.FIELD_SEPARATOR + lines.get(i) + CHARACTER_NEW_LINE;
        }
        assertEquals(tasks, ui.feedback);
        storage.getFileManager().cleanFile(todo);
	}
	
	@Test
	public void testUndoCommandAfterDeleteTask() throws Exception {
		UI ui = new UI();
		ui.commandBar.setText(COMMAND_ADD_EVENT);
		KeyEvent event = new KeyEvent(ui.commandBar, 
                KeyEvent.KEY_PRESSED, System.currentTimeMillis(), 0, 
                KeyEvent.VK_ENTER, KeyEvent.CHAR_UNDEFINED);
        ui.commandBar.dispatchEvent(event); 
        
        ui.commandBar.setText(COMMAND_ADD_DEADLINE);
        ui.commandBar.dispatchEvent(event); 
        
        ui.commandBar.setText(COMMAND_EDIT_PRIORITY);
        ui.commandBar.dispatchEvent(event); 
	    
        ui.commandBar.setText(COMMAND_DELETE_DEADLINE);
        ui.commandBar.dispatchEvent(event); 
        
        ui.commandBar.setText(COMMAND_UNDO);
        ui.commandBar.dispatchEvent(event); 
        
        File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);      
        assertEquals(FEEDBACK_DELETE_DEADLINE, ui.feedback);
        new Storage().getFileManager().cleanFile(todo);
	}
}
```
