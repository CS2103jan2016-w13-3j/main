# A0112659A
###### simplyamazing\parser\Handler.java
``` java
package simplyamazing.parser;

import java.util.ArrayList;

import simplyamazing.data.Task;

public class Handler {
	private Task task;
	private String commandType;
	private String keyWord;
	private String feedback;
	private boolean hasError;
	private boolean hasEndDate;
	private ArrayList<Integer> indexes;

	private static final String INDEX_DEFAULT_VALUE = null;
	private static final String EMPTY_STRING = "";
	private static final boolean HASERROR_DEFAULT_VALUE = false;
	private static final boolean HASENDDATE_DEFAULT_VALUE = false;
	private static final Task TASK_DEFAULT_VALUE = null;

	public Handler() {
		task = new Task();
		this.commandType = EMPTY_STRING;
		this.keyWord = EMPTY_STRING;
		this.feedback = EMPTY_STRING;
		this.hasError = HASERROR_DEFAULT_VALUE;
		this.hasEndDate = HASENDDATE_DEFAULT_VALUE;
		this.indexes = new ArrayList<Integer>();
	}

	public void setCommandType(String commandType) {
		this.commandType = commandType;
	}

	public void setIndex(String index) {
		this.indexes.add(Integer.parseInt(index));
	}

	public void setKeyWord(String keyWord) {
		this.keyWord = keyWord;
	}

	public void setFeedBack(String feedback) {
		this.feedback = feedback;
	}

	public void setHasError(boolean hasError) {
		this.hasError = hasError;
	}

	public void setHasEndDate(boolean hasEndDate) {
		this.hasEndDate = hasEndDate;
	}

	public Task getTask() {
		return task;
	}

	public String getCommandType() {
		return commandType;
	}

	public ArrayList<Integer> getIndexList() {
		return indexes;
	}

	public String getKeyWord() {
		return keyWord;
	}

	public String getFeedBack() {
		return feedback;
	}

	public boolean getHasError() {
		return hasError;
	}

	public boolean getHasEndDate() {
		return hasEndDate;
	}

}
```
###### simplyamazing\parser\Parser.java
``` java
package simplyamazing.parser;

import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.util.regex.Pattern;

public class Parser {
	private static Logger logger;
	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_ADD_ALT = "+";
	private static final String COMMAND_DELETE = "delete";
	private static final String COMMAND_DELETE_ALT = "del";
	private static final String COMMAND_DELETE_ALT_2 = "-";
	private static final String COMMAND_DELETE_ALT_3 = "remove";
	private static final String COMMAND_DELETE_ALT_4 = "cancel";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_EDIT_ALT = "change";
	private static final String COMMAND_EDIT_ALT_2 = "update";
	private static final String COMMAND_VIEW = "view";
	private static final String COMMAND_VIEW_ALT = "display";
	private static final String COMMAND_VIEW_ALT_2 = "show";
	private static final String COMMAND_VIEW_ALT_3 = "list";
	private static final String COMMAND_SEARCH = "search";
	private static final String COMMAND_SEARCH_ALT = "find";
	private static final String COMMAND_SEARCH_ALT_2 = "get";
	private static final String COMMAND_HELP = "help";
	private static final String COMMAND_HELP_ALT = "?";
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_REDO = "redo";
	private static final String COMMAND_SET_LOCATION = "location";
	private static final String COMMAND_SET_LOCATION_ALT = "path";
	private static final String COMMAND_SET_LOCATION_ALT_2 = "address";
	private static final String COMMAND_MARK_AS_DONE = "done";
	private static final String COMMAND_MARK_AS_DONE_ALT = "mark";
	private static final String COMMAND_MARK_AS_DONE_ALT_2 = "finish";
	private static final String COMMAND_MARK_AS_DONE_ALT_3 = "complete";
	private static final String COMMAND_UNMARK = "undone";
	private static final String COMMAND_UNMARK_ALT = "unmark";
	private static final String COMMAND_EXIT = "exit";
	private static final String COMMAND_EXIT_ALT = "quit";
	private static final String COMMAND_EXIT_ALT_2 = "logout";
	private static final String COMMAND_INVALID = "Error: Invalid command entered. Please enter \"help\" to view command format";

	private static final String STRING_EMPTY = "";
	private static final String CHARACTER_SPACE = "\\s";

	private String firstWord = STRING_EMPTY;
	private String taskIndex = STRING_EMPTY;
	private String taskInfoWithoutIndex = STRING_EMPTY;
	private String removeFirstWord = STRING_EMPTY;

	public Parser() {
		logger = Logger.getLogger("simplyamazing");

		try {
			FileHandler fh = new FileHandler("C:\\Users\\Public\\SimplyAmazing\\logFile.txt", true);
			logger.addHandler(fh);
			SimpleFormatter formatter = new SimpleFormatter();
			fh.setFormatter(formatter);
		} catch (Exception e) {
			logger.log(Level.WARNING, "the address fro file handler is invalid");
		}
		;
	}

	/*
	 * This method is used to remove the first word of the command
	 */
	public static String removeFirstWord(String userCommand) {
		final String replace = Pattern.quote(getFirstWord(userCommand));
		return userCommand.replaceFirst(replace, STRING_EMPTY).trim();
	}

	/*
	 * This method is used to get the first word of the command
	 */
	public static String getFirstWord(String userCommand) {
		return userCommand.trim().split(CHARACTER_SPACE)[0];
	}

	private Handler parserAddCommand(Handler handler, String taskInfo) throws Exception {
		ParserAdd parserAdd = new ParserAdd();
		return parserAdd.parseAddCommand(handler, taskInfo, logger);

	}

	private Handler parserEditCommand(Handler handler, String taskInfo) throws Exception {
		ParserEdit parserEdit = new ParserEdit();
		taskIndex = getFirstWord(taskInfo);
		taskInfoWithoutIndex = removeFirstWord(taskInfo);

		return parserEdit.parseEditCommand(handler, taskIndex, taskInfoWithoutIndex, logger);
	}

	private Handler parserDeleteCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserDelete parserDelete = new ParserDelete();
		return parserDelete.parserDeleteCommand(handler, removeFirstWord, logger);
	}

	private Handler parserViewCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserView parserView = new ParserView();
		return parserView.parserViewCommand(handler, removeFirstWord, logger);
	}

	private Handler parserLocationCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserLocation parseLocation = new ParserLocation();
		return parseLocation.parseLocationCmd(handler, removeFirstWord, logger);
	}

	private Handler parserDoneCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserDone parserDone = new ParserDone();
		return parserDone.parserDoneCommand(handler, removeFirstWord, logger);
	}

	private Handler parserHelpCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserHelp parserHelp = new ParserHelp();
		return parserHelp.parserHelpCommand(handler, removeFirstWord, logger);
	}

	private Handler parserSearchCommand(Handler handler, String removeFirstWord) throws Exception {
		ParserSearch parserSearch = new ParserSearch();
		return parserSearch.parserSearchCommand(handler, removeFirstWord, logger);
	}

	/*
	 * This method is used to parse/analyze the first word of a command. There
	 * are twelve for the commands:add, delete, view, undo, redo, mark, unmark,
	 * edit, location, exit, search. We also allow the users to enter the
	 * flexible commands for each type.
	 */
	private Handler parserFirstWord(Handler handler, String firstWord, String removeFirstWord) throws Exception {
		logger.log(Level.INFO, "start to process the First word");
		switch (firstWord.toLowerCase()) {
		case COMMAND_ADD :
		case COMMAND_ADD_ALT :
			handler.setCommandType(COMMAND_ADD);
			handler = parserAddCommand(handler, removeFirstWord);
			break;
		case COMMAND_DELETE :
		case COMMAND_DELETE_ALT :
		case COMMAND_DELETE_ALT_2 :
		case COMMAND_DELETE_ALT_3 :
		case COMMAND_DELETE_ALT_4 :
			handler.setCommandType(COMMAND_DELETE);
			handler = parserDeleteCommand(handler, removeFirstWord);
			break;
		case COMMAND_EDIT :
		case COMMAND_EDIT_ALT :
		case COMMAND_EDIT_ALT_2 :
			handler.setCommandType(COMMAND_EDIT);
			handler = parserEditCommand(handler, removeFirstWord);
			break;
		case COMMAND_VIEW :
		case COMMAND_VIEW_ALT :
		case COMMAND_VIEW_ALT_2 :
		case COMMAND_VIEW_ALT_3 :
			handler.setCommandType(COMMAND_VIEW);
			handler = parserViewCommand(handler, removeFirstWord);
			break;
		case COMMAND_SEARCH :
		case COMMAND_SEARCH_ALT :
		case COMMAND_SEARCH_ALT_2 :
			handler.setCommandType(COMMAND_SEARCH);
			handler = parserSearchCommand(handler, removeFirstWord);
			break;
		case COMMAND_HELP :
		case COMMAND_HELP_ALT :
			handler.setCommandType(COMMAND_HELP);
			handler = parserHelpCommand(handler, removeFirstWord);
			break;
		case COMMAND_UNDO :
			handler.setCommandType(COMMAND_UNDO);
			break;
		case COMMAND_REDO :
			handler.setCommandType(COMMAND_REDO);
			break;
		case COMMAND_SET_LOCATION :
		case COMMAND_SET_LOCATION_ALT :
		case COMMAND_SET_LOCATION_ALT_2 :
			handler.setCommandType(COMMAND_SET_LOCATION);
			handler = parserLocationCommand(handler, removeFirstWord);
			break;
		case COMMAND_MARK_AS_DONE :
		case COMMAND_MARK_AS_DONE_ALT :
		case COMMAND_MARK_AS_DONE_ALT_2 :
		case COMMAND_MARK_AS_DONE_ALT_3 :
			handler.setCommandType(COMMAND_MARK_AS_DONE);
			handler = parserDoneCommand(handler, removeFirstWord);
			break;
		case COMMAND_UNMARK :
		case COMMAND_UNMARK_ALT :
			handler.setCommandType(COMMAND_UNMARK);
			handler = parserDoneCommand(handler, removeFirstWord);
			break;
		case COMMAND_EXIT :
		case COMMAND_EXIT_ALT :
		case COMMAND_EXIT_ALT_2 :
			handler.setCommandType(COMMAND_EXIT);
			break;
		default :
			logger.log(Level.WARNING, "the entered command type is invalid");
			handler.setHasError(true);
			handler.setFeedBack(COMMAND_INVALID);
		}
		return handler;
	}

	public Handler getHandler(String input) throws Exception {
		logger.log(Level.INFO, "before starting on getHandler");
		Handler handler = new Handler();
		firstWord = getFirstWord(input);
		removeFirstWord = removeFirstWord(input);
		handler = parserFirstWord(handler, firstWord, removeFirstWord);
		logger.log(Level.INFO, "ready to return the handler");
		return handler;
	}
}
```
###### simplyamazing\parser\ParserAdd.java
``` java
package simplyamazing.parser;

import com.joestelmach.natty.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ParserAdd {
	private static final String STRING_TIME_FORMATTER = ":";
	private static final String KEYWORD_SCHEDULE_TO = "to";
	private static final String KEYWORD_SCHEDULE_FROM = "from";
	private static final String KEYWORD_DEADLINE = "by";
	private static final String EMPTY_STRING = "";
	private static final String SPECIAL_STRING = "*";
	private static final String TIME_FORMAT = "HH:mm dd MMM yyyy";
	private static final String ERROR_MESSAGE_FIELDS_NOT_CORRECT = "Error: Please ensure the fields are correct";
	private static final String ERROR_MESSAGE_TIME_FORMAT_INVALID = "Error: Please ensure the time format is valid. Please use the \"help\"command to view the format";
	private static final String ERROR_MESSAGE_START_AFTER_END = "Error: Start date and time cannot be after the End date and time";
	private static final String ERROR_MESSAGE_DATE_BEFORE_CURRENT = "Error: Time provided must be after the current time";
	private static String description = "";
	private static String startTime = "";
	private static String endTime = "";
	private static Date startingDate = null;
	private static Date endingDate = null;
	private static int startTimeIndex;
	private static int endTimeIndex;
	private static int year;
	private boolean checkValue = false, isEvent = false, isDeadline = false, isFloatingTask = false;

	/*
	 * This method is used to parse/analyze a Add command There are three types
	 * of commands: event, deadline and floating task We allow the users to type
	 * the command in our standard format and flexible format we also allow the
	 * users to key in the duplications of keywords: from, to, by
	 */
	public Handler parseAddCommand(Handler handler, String taskInfo, Logger logger) throws Exception {
		logger.log(Level.INFO, "going to start parse the Add Command");
		checkValue = isAddingValid(handler, taskInfo, logger);
		assert handler != null;
		if (checkValue) {
			if (isEvent) { // For events
				handler.getTask().setDescription(description);
				handler.getTask().setStartTime(startingDate);
				handler.getTask().setEndTime(endingDate);
			}
			if (isDeadline) { // For deadlines
				handler.getTask().setDescription(description);
				handler.getTask().setEndTime(endingDate);
			}
			if (isFloatingTask) {// For floating tasks
				handler.getTask().setDescription(taskInfo.trim());
			}
		} else {
		}
		logger.log(Level.INFO, "return the handler to parser");
		return handler;
	}

	/*
	 * This method is used to check the adding is valid or not we will check the
	 * input contains special string or not like"*" This means the users key in
	 * the duplication of key words or not we will check the date and time
	 * format the user entered is belong to our time format or the Natty's
	 * format
	 */
	public boolean isAddingValid(Handler handler, String taskInfo, Logger logger) throws Exception {
		com.joestelmach.natty.Parser dateParser = new com.joestelmach.natty.Parser();

		logger.log(Level.INFO, "start to analyze the type of the task we add");
		if (taskInfo.contains(KEYWORD_SCHEDULE_FROM) && taskInfo.contains(KEYWORD_SCHEDULE_TO)) {
			if (taskInfo.contains(SPECIAL_STRING)) {
				assert taskInfo != null;
				int specialStrIndex = taskInfo.lastIndexOf(SPECIAL_STRING);
				if (taskInfo.substring(specialStrIndex + 1, specialStrIndex + 5).matches(KEYWORD_SCHEDULE_FROM)) {
					startTimeIndex = specialStrIndex + 1;
				} else {
					startTimeIndex = taskInfo.lastIndexOf(KEYWORD_SCHEDULE_FROM);
				}
			} else {
				assert (startTimeIndex >= 0);
				startTimeIndex = taskInfo.lastIndexOf(KEYWORD_SCHEDULE_FROM);
			}
			String taskInfoFiltered = taskInfo;
			endTimeIndex = taskInfoFiltered.lastIndexOf(KEYWORD_SCHEDULE_TO);
			
			if (taskInfoFiltered.substring(endTimeIndex).trim().matches(KEYWORD_SCHEDULE_TO)) {
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);	
				return false;
			}
			
			while (!taskInfoFiltered.substring((endTimeIndex + 2), (endTimeIndex + 3)).trim().equals(EMPTY_STRING)) {
				taskInfoFiltered = taskInfoFiltered.substring(0, endTimeIndex);
				endTimeIndex = taskInfoFiltered.lastIndexOf(KEYWORD_SCHEDULE_TO);
			}

			logger.log(Level.INFO, "Start to compare the index of \"from and \"to");
			if (startTimeIndex < endTimeIndex && !taskInfo.contains(KEYWORD_DEADLINE)) {

				startTime = Parser.removeFirstWord(taskInfo.substring(startTimeIndex, endTimeIndex).trim());
				endTime = Parser.removeFirstWord(taskInfo.substring(endTimeIndex).trim());
				description = taskInfo.substring(0, startTimeIndex);
				description = description.replace(SPECIAL_STRING, EMPTY_STRING);

				if (description.equals(EMPTY_STRING) || startTime.equals(EMPTY_STRING)
						|| endTime.equals(EMPTY_STRING)) {
					logger.log(Level.WARNING, "the field added is not correct");
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_FIELDS_NOT_CORRECT);
					return false;
				} else if (!startTime.equals(EMPTY_STRING) && !endTime.equals(EMPTY_STRING)) {
					boolean isStartFormatCorrect = followStandardFormat(startTime, logger);
					boolean isEndFormatCorrect = followStandardFormat(endTime, logger);

					SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT, Locale.ENGLISH);
					sdf.setLenient(false);
					if (isStartFormatCorrect == false && isEndFormatCorrect == false) {
						logger.log(Level.INFO, "Endtime and Startime both use Natty format");
						List<DateGroup> dateGroup1 = dateParser.parse(startTime);
						List<DateGroup> dateGroup2 = dateParser.parse(endTime);

						if (dateGroup1.isEmpty() || dateGroup2.isEmpty()) {
							logger.log(Level.WARNING, "The input time format is wrong");
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}
						List<Date> date1 = dateGroup1.get(0).getDates();
						startingDate = date1.get(0);
						List<Date> date2 = dateGroup2.get(0).getDates();
						endingDate = date2.get(0);
					} else if (isStartFormatCorrect == true && isEndFormatCorrect == true) {
						logger.log(Level.INFO, "Endtime and Startime both use our format");
						try {
							startingDate = (Date) sdf.parse(startTime);
							endingDate = (Date) sdf.parse(endTime);
						} catch (ParseException e) {
							logger.log(Level.WARNING, "Endtime and Startime are invalid for our format");
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}
					} else if (isStartFormatCorrect == true && isEndFormatCorrect == false) {
						logger.log(Level.INFO, "Startime use our format, Endtime use Natty format");
						try {
							startingDate = (Date) sdf.parse(startTime);
						} catch (ParseException e) {
							logger.log(Level.WARNING, "StartTime is invalid in our time format");
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}
						List<DateGroup> dateGroup2 = dateParser.parse(endTime);

						if (dateGroup2.isEmpty()) {
							logger.log(Level.WARNING, "EndTime is invalid in the Natty format");
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}
						List<Date> date2 = dateGroup2.get(0).getDates();
						endingDate = date2.get(0);
					} else if (isStartFormatCorrect == false && isEndFormatCorrect == true) {
						logger.log(Level.INFO, "Startime use Natty format, Endtime use our format");
						try {
							endingDate = (Date) sdf.parse(endTime);
						} catch (ParseException e) {
							logger.log(Level.WARNING, "EndTime is invalid in our time format");
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}
						List<DateGroup> dateGroup2 = dateParser.parse(startTime);

						if (dateGroup2.isEmpty()) {
							logger.log(Level.WARNING, "StartTime is invalid in the Natty format");
							handler.setHasError(true);
							handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
							return false;
						}
						List<Date> date2 = dateGroup2.get(0).getDates();
						startingDate = date2.get(0);
					}

					Date todayDate = null;
					todayDate = (Date) sdf.parse(sdf.format(new Date()));
					logger.log(Level.INFO, "start to compare the startingDate and endingDate");
					if (startingDate.after(endingDate) || startingDate.compareTo(endingDate) == 0) {
						logger.log(Level.WARNING, "startingDate is greater than or equal to the endingDate");
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_START_AFTER_END);
						return false;
					} else if (!startingDate.after(todayDate) || !endingDate.after(todayDate)) {
						logger.log(Level.WARNING, "startingDate or endingDate is before the Today's date");
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_DATE_BEFORE_CURRENT);
						return false;
					} else {
						logger.log(Level.INFO, "this is an event task");
						isEvent = true;
						return true;
					}
				}
			} else if (taskInfo.contains(KEYWORD_DEADLINE)) {
				endTimeIndex = taskInfo.lastIndexOf(KEYWORD_DEADLINE);
				startTimeIndex = taskInfo.lastIndexOf(KEYWORD_SCHEDULE_FROM);
				if (endTimeIndex < startTimeIndex) {
					logger.log(Level.INFO, "This is not an event but floating task");
					isFloatingTask = true;
					return true;
				}
			}
		}
		if (taskInfo.contains(KEYWORD_DEADLINE)) {
			logger.log(Level.INFO, "start to process the deadline tasks");
			endTimeIndex = taskInfo.lastIndexOf(KEYWORD_DEADLINE);
			endTime = Parser.removeFirstWord(taskInfo.substring(endTimeIndex));
			description = taskInfo.substring(0, endTimeIndex).trim();

			if (description.equals(EMPTY_STRING) || endTime.equals(EMPTY_STRING)) {
				logger.log(Level.WARNING, "the fields entered are not correct");
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_FIELDS_NOT_CORRECT);
				return false;
			} else if (!endTime.equals(EMPTY_STRING)) {
				boolean isEndFormatCorrect = followStandardFormat(endTime, logger);

				SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT, Locale.ENGLISH);
				sdf.setLenient(false);

				if (isEndFormatCorrect == false) {
					logger.log(Level.INFO, "Endtime use Natty");
					List<DateGroup> dateGroup3 = dateParser.parse(endTime);

					if (dateGroup3.isEmpty()) {
						logger.log(Level.WARNING, "Endtime is invalid in the Natty format");
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
						return false;
					}
					List<Date> date3 = dateGroup3.get(0).getDates();
					endingDate = date3.get(0);

				} else if (isEndFormatCorrect == true) {
					logger.log(Level.INFO, "Endtime use our time format");
					try {
						logger.log(Level.INFO, "start to parse the endTime in our time format");
						endingDate = (Date) sdf.parse(endTime);
					} catch (ParseException e) {
						logger.log(Level.WARNING, "Endtime is invalid in our time format");
						handler.setHasError(true);
						handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
						return false;
					}
				}

				Date todayDate = null;
				todayDate = (Date) sdf.parse(sdf.format(new Date()));

				if (!endingDate.after(todayDate)) {
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_DATE_BEFORE_CURRENT);
					return false;
				}
			}
			isDeadline = true;
			return true;
		} else {
			if (taskInfo.contains(STRING_TIME_FORMATTER)) {
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_FIELDS_NOT_CORRECT);
				return false;
			} else {
				if (taskInfo.trim().equals(EMPTY_STRING)) {
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_FIELDS_NOT_CORRECT);
					return false;
				}
			}
		}
		isFloatingTask = true;
		return true;
	}

	/*
	 * This method is used to check the input date which follows our time format
	 * or not There are four parts to check: time, date, month and year We use
	 * it differentiate the input from our time format and the Natty's format
	 */
	public boolean followStandardFormat(String dateTimeString, Logger logger) {
		String[] dateTimeArr = dateTimeString.trim().split(" ");

		if (dateTimeArr.length != 4) {
			return false;
		} else {
			// dateTimeArr len should be 4 here, now check end time
			String time = dateTimeArr[0];
			if ((time.contains(":") && (time.length() == 4 || time.length() == 5))) {

				int date;
				logger.log(Level.INFO, "start to process the date");
				try {
					date = Integer.parseInt(dateTimeArr[1], 10);
				} catch (NumberFormatException e) {
					logger.log(Level.WARNING, "the format for the date is invalid");
					return false;
				}
				String givenMonth = dateTimeArr[2].toLowerCase();
				if (!(givenMonth.contains("jan") || givenMonth.contains("feb") || givenMonth.contains("mar")
						|| givenMonth.contains("apr") || givenMonth.contains("may") || givenMonth.contains("jun")
						|| givenMonth.contains("jul") || givenMonth.contains("aug") || givenMonth.contains("sep")
						|| givenMonth.contains("oct") || givenMonth.contains("nov") || givenMonth.contains("dec"))) {
					// month given follows the required format
					return false;
				} else {
					logger.log(Level.INFO, "start to process the year");
					try {
						year = Integer.parseInt(dateTimeArr[3], 10);
					} catch (NumberFormatException e) {
						logger.log(Level.WARNING, "the format for the year is invalid");
						return false;
					}
				}
			} else {
				return false;
			}
			return true;
		}
	}
}
```
###### simplyamazing\parser\ParserDelete.java
``` java
package simplyamazing.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

public class ParserDelete {
	private final String COMMAND_INVALID = "Error: Index provided is not an Integer.";
	private final String SPACE = " ";
	private int size;

	public Handler parserDeleteCommand(Handler handler, String taskInfo, Logger logger) throws Exception {

		String[] indexes = taskInfo.split(SPACE);
		size = indexes.length;
		for (int i = 0; i < size; i++) {
			if (isInteger(indexes[i], logger)) {
				handler.setIndex(indexes[i]);
			} else {
				logger.log(Level.WARNING, "the command entered is invalid");
				handler.setHasError(true);
				handler.setFeedBack(COMMAND_INVALID);
				return handler;
			}
		}
		return handler;
	}

	public static boolean isInteger(String taskInfo, Logger logger) {
		logger.log(Level.INFO, "start to analyze the index");
		try {
			Integer.parseInt(taskInfo);
		} catch (NumberFormatException e) {
			logger.log(Level.WARNING, "the index is not an Integer");
			return false;
		}
		// only got here if we didn't return false
		return true;
	}
}
```
###### simplyamazing\parser\ParserDone.java
``` java
package simplyamazing.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

public class ParserDone {
	private final String COMMAND_INVALID = "Error: Index provided is not an Integer.";
	private final String SPACE = " ";
	private int size;

	/*
	 * This method is used to parse/analyze a mark command. We allow the users
	 * to mark multiple tasks as done. Different input tasks are separated by
	 * the space.
	 */
	public Handler parserDoneCommand(Handler handler, String taskInfo, Logger logger) throws Exception {

		String[] indexes = taskInfo.split(SPACE);
		size = indexes.length;
		logger.log(Level.INFO, "start to analyze the command");
		for (int i = 0; i < size; i++) {
			if (isInteger(indexes[i], logger)) {
				handler.setIndex(indexes[i]);
			} else {
				logger.log(Level.WARNING, "the index is invalid");
				handler.setHasError(true);
				handler.setFeedBack(COMMAND_INVALID);
				return handler;
			}
		}
		return handler;
	}

	/*
	 * This method is used to check the index is an Integer or not
	 */
	private boolean isInteger(String taskInfo, Logger logger) {
		logger.log(Level.INFO, "start to analyze the index");
		try {
			Integer.parseInt(taskInfo);
		} catch (NumberFormatException e) {
			logger.log(Level.WARNING, "the index is not an Integer");
			return false;
		}
		// only got here if we didn't return false
		return true;
	}
}
```
###### simplyamazing\parser\ParserEdit.java
``` java
package simplyamazing.parser;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.joestelmach.natty.*;

import simplyamazing.data.Task;

public class ParserEdit {
	private static final String PRIORITY = "priority";
	private static final String END = "end";
	private static final String START = "start";
	private static final String DESCRIPTION = "description";
	private static final String ERROR_MESSAGE_INVALID_INDEX = "Error: Index provided is not an Integer.";
	private static final String ERROR_MESSAGE_INVALID_FIELD = "Error: Please input a valid field. Use the \"help edit\" command to see all the valid fields";
	private static final String ERROR_MESSAGE_START_AFTER_END = "Error: Start date and time cannot be after the End date and time";
	private static final String ERROR_MESSAGE_DATE_BEFORE_CURRENT = "Error: Time provided must be after the current time";
	private static final String ERROR_MESSAGE_PRIORITY_LEVEL = "Error: Priority level can be only high, medium, low or none.";
	private static final String ERROR_MESSAGE_TIME_FORMAT_INVALID = "Error: Please ensure the time format is valid. Please use the \"help\"command to view the format";
	private static final String ERROR_MESSAGE_NO_END_TIME = "Error: Unable to allocate a start time when the task has no end time";
	private static final String TIME_FORMAT = "HH:mm dd MMM yyyy";
	private static Date startingDate = null;
	private static Date endingDate = null;
	private static int year;

	/*
	 * This method is used to parse/analyze a edit command There are three types
	 * of commands: event, deadline and floating task There are four fields for
	 * the edit command: description, start, end and priority We also allow
	 */
	public Handler parseEditCommand(Handler handler, String taskIndex, String taskInfoWithoutIndex, Logger logger)
			throws Exception {
		logger.log(Level.INFO, "start to check the Index of the Edit command");
		if (isInteger(taskIndex, logger)) {
			handler.setIndex(taskIndex);
		} else {
			logger.log(Level.WARNING, "the index of the command is invalid");
			handler.setHasError(true);
			handler.setFeedBack(ERROR_MESSAGE_INVALID_INDEX);
			return handler;
		}
		String[] fieldValuePairs = taskInfoWithoutIndex.split(",");
		SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT, Locale.ENGLISH);
		assert sdf != null;
		sdf.setLenient(false);

		for (int i = 0; i < fieldValuePairs.length; i++) {
			String field = Parser.getFirstWord(fieldValuePairs[i]);
			String value = Parser.removeFirstWord(fieldValuePairs[i]);

			switch (field.toLowerCase()) {
			case DESCRIPTION:
				handler.getTask().setDescription(value);
				break;
			case START:
				if (value.toLowerCase().equals("none")) {
					handler.getTask().setStartTime(Task.DEFAULT_DATE_VALUE_FOR_NULL);
				} else {
					boolean isStartFormatCorrect = followStandardFormat(value, logger);
					handler = editStartTime(sdf, isStartFormatCorrect, handler, value, logger);
				}
				break;
			case END:
				if (value.toLowerCase().equals("none")) {
					handler.getTask().setEndTime(Task.DEFAULT_DATE_VALUE_FOR_NULL);
				} else {
					boolean isEndFormatCorrect = followStandardFormat(value, logger);
					handler = editEndTime(sdf, isEndFormatCorrect, handler, value, logger);
				}
				break;
			case PRIORITY:
				logger.log(Level.INFO, "start to parse the priority");
				try {
					handler.getTask().setPriority(value);
				} catch (Exception e) {
					logger.log(Level.WARNING, "the priority level entered is invalid");
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_PRIORITY_LEVEL);
				}
				break;
			default:
				logger.log(Level.WARNING, "the field of command is invalid");
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_INVALID_FIELD);
			}
		}

		startingDate = handler.getTask().getStartTime();
		endingDate = handler.getTask().getEndTime();
		Date todayDate = new Date();
		assert todayDate != null;

		if (startingDate.compareTo(Task.DEFAULT_DATE_VALUE) != 0
				&& endingDate.compareTo(Task.DEFAULT_DATE_VALUE) != 0) {
			if (startingDate.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) != 0
					&& endingDate.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) != 0) {
				if (!startingDate.after(todayDate) || !endingDate.after(todayDate)) {
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_DATE_BEFORE_CURRENT);
				} else if (!endingDate.after(startingDate)) {
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_START_AFTER_END);
				}
			} else if (startingDate.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) == 0
					&& endingDate.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) != 0) {
				if (!endingDate.after(todayDate)) {
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_DATE_BEFORE_CURRENT);
				}
			} else if (startingDate.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) != 0
					&& endingDate.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) == 0) {
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_NO_END_TIME);
			}
		} else if (startingDate.compareTo(Task.DEFAULT_DATE_VALUE) != 0) {
			if (startingDate.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) != 0 && !startingDate.after(todayDate)) {
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_DATE_BEFORE_CURRENT);
			}

		} else if (endingDate.compareTo(Task.DEFAULT_DATE_VALUE) != 0) {
			if (endingDate.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) != 0 && !endingDate.after(todayDate)) {
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_DATE_BEFORE_CURRENT);
			}
		}
		return handler;
	}

	private Handler editStartTime(SimpleDateFormat sdf, boolean isStartFormatCorrect, Handler handler, String value,
			Logger logger) {
		com.joestelmach.natty.Parser dateParser = new com.joestelmach.natty.Parser();
		if (isStartFormatCorrect == true) {
			logger.log(Level.INFO, "startTime use our format");
			try {
				startingDate = (Date) sdf.parse(value);
			} catch (ParseException e) {
				logger.log(Level.WARNING, "startTime is invalid in our time format");
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
			}
		} else {
			logger.log(Level.INFO, "startTime use Natty");
			List<DateGroup> dateGroup3 = dateParser.parse(value);

			if (dateGroup3.isEmpty()) {
				logger.log(Level.WARNING, "startTime is invalid in the Natty format");
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
				return handler;
			}
			List<Date> date3 = dateGroup3.get(0).getDates();
			startingDate = date3.get(0);
			assert startingDate != null;
		}
		handler.getTask().setStartTime(startingDate);
		return handler;
	}

	private Handler editEndTime(SimpleDateFormat sdf, boolean isEndFormatCorrect, Handler handler, String value,
			Logger logger) {
		com.joestelmach.natty.Parser dateParser = new com.joestelmach.natty.Parser();
		if (isEndFormatCorrect == true) {
			logger.log(Level.INFO, "endTime use our format");
			try {
				endingDate = (Date) sdf.parse(value);
			} catch (ParseException e) {
				logger.log(Level.WARNING, "endTime is invalid in our time format");
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
			}
		} else {
			logger.log(Level.INFO, "endTime use Natty");
			List<DateGroup> dateGroup4 = dateParser.parse(value);

			if (dateGroup4.isEmpty()) {
				logger.log(Level.WARNING, "endTime is invalid in the Natty format");
				handler.setHasError(true);
				handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
				return handler;
			}
			List<Date> date4 = dateGroup4.get(0).getDates();
			endingDate = date4.get(0);
		}
		handler.getTask().setEndTime(endingDate);
		return handler;
	}

	/*
	 * This method is used to test the validity of the index.
	 */
	public static boolean isInteger(String taskInfo, Logger logger) {
		logger.log(Level.INFO, "start to analyze the index");
		try {
			Integer.parseInt(taskInfo);
		} catch (NumberFormatException e) {
			logger.log(Level.WARNING, "the index is not an Integer");
			return false;
		}
		return true;
	}

	public boolean followStandardFormat(String dateTimeString, Logger logger) {
		String[] dateTimeArr = dateTimeString.trim().split(" ");

		if (dateTimeArr.length != 4) {
			return false;
		} else {
			// dateTimeArr len should be 4 here, now check end time
			String time = dateTimeArr[0];
			if ((time.contains(":") && (time.length() == 4 || time.length() == 5))) {

				int date;
				logger.log(Level.INFO, "start to process the date");
				try {
					date = Integer.parseInt(dateTimeArr[1], 10);
				} catch (NumberFormatException e) {
					logger.log(Level.WARNING, "the format for the date is invalid");
					return false;
				}
				// reach here means that it time given follows format and date
				// given is an integer

				String givenMonth = dateTimeArr[2].toLowerCase();
				if (!(givenMonth.contains("jan") || givenMonth.contains("feb") || givenMonth.contains("mar")
						|| givenMonth.contains("apr") || givenMonth.contains("may") || givenMonth.contains("jun")
						|| givenMonth.contains("jul") || givenMonth.contains("aug") || givenMonth.contains("sep")
						|| givenMonth.contains("oct") || givenMonth.contains("nov") || givenMonth.contains("dec"))) {
					// month given follows the required format
					return false;
				} else {
					logger.log(Level.INFO, "start to process the year");
					try {
						year = Integer.parseInt(dateTimeArr[3], 10);
					} catch (NumberFormatException e) {
						logger.log(Level.WARNING, "the format for the year is invalid");
						return false;
					}
				}
			} else {
				return false;
			}
			return true;
		}
	}
}
```
###### simplyamazing\parser\ParserHelp.java
``` java
package simplyamazing.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

public class ParserHelp {
	private final String STRING_ADD = "add";
	private final String STRING_DELETE = "delete";
	private final String STRING_VIEW = "view";
	private final String STRING_UNDO = "undo";
	private final String STRING_REDO = "redo";
	private final String STRING_MARK = "mark";
	private final String STRING_UNMARK = "unmark";
	private final String STRING_EDIT = "edit";
	private final String STRING_SEARCH = "search";
	private final String STRING_LOCATION = "location";
	private final String STRING_EXIT = "exit";
	private final String STRING_EMPTY = "";

	private final String COMMAND_INVALID = "Error: Please input a valid keyword. Use the \"help\" command to view all valid keywords";
    
	/*
	 * This method is used to parse/analyze a help command. There are twelve fields for
	 * the help command: , add, delete, view, undo, redo, mark, unmark, edit, location, 
	 * exit, search.
	 */
	public Handler parserHelpCommand(Handler handler, String taskInfo, Logger logger) throws Exception {
		logger.log(Level.INFO, "start to parse the help command");
		switch (taskInfo.toLowerCase()) {
		case STRING_ADD :
			handler.setKeyWord(STRING_ADD);
			break;
		case STRING_DELETE :
			handler.setKeyWord(STRING_DELETE);
			break;
		case STRING_VIEW :
			handler.setKeyWord(STRING_VIEW);
			break;
		case STRING_UNDO :
			handler.setKeyWord(STRING_UNDO);
			break;
		case STRING_REDO :
			handler.setKeyWord(STRING_REDO);
			break;
		case STRING_MARK :
			handler.setKeyWord(STRING_MARK);
			break;
		case STRING_UNMARK :
			handler.setKeyWord(STRING_UNMARK);
			break;
		case STRING_EDIT :
			handler.setKeyWord(STRING_EDIT);
			break;
		case STRING_LOCATION :
			handler.setKeyWord(STRING_LOCATION);
			break;
		case STRING_EXIT :
			handler.setKeyWord(STRING_EXIT);
			break;
		case STRING_SEARCH :
			handler.setKeyWord(STRING_SEARCH);
			break;
		case STRING_EMPTY :
			handler.setKeyWord(STRING_EMPTY);
			break;
		default :
			logger.log(Level.WARNING, "the entered command is invalid");
			handler.setHasError(true);
			handler.setFeedBack(COMMAND_INVALID);
		}
		return handler;
	}
}
```
###### simplyamazing\parser\ParserLocation.java
``` java
package simplyamazing.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

public class ParserLocation {
	private static final String STRING_EMPTY = "";
	private static final String INVALID_LOCATION = "Error: Location provided is invalid";

	public Handler parseLocationCmd(Handler handler, String taskInfo, Logger logger) throws Exception {
		logger.log(Level.INFO, "start to parse the location command");
		if (taskInfo.equals(STRING_EMPTY)) {
			logger.log(Level.WARNING, "the location address is empty");
			handler.setHasError(true);
			handler.setFeedBack(INVALID_LOCATION);
		} else {
			handler.setKeyWord(taskInfo);
		}
		return handler;
	}
}
```
###### simplyamazing\parser\ParserSearch.java
``` java
package simplyamazing.parser;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.logging.Level;
import java.util.logging.Logger;
import com.joestelmach.natty.DateGroup;

public class ParserSearch {
	private static final String TIME_FORMAT = "HH:mm dd MMM yyyy";
	private static final String ERROR_MESSAGE_TIME_FORMAT_INVALID = "Error: Please ensure the time format is valid. Please use the \"help\"command to view the format";
	private static final String SPACE = " ";
	private static final String EMPTY_STRING = "";
	private static Date endingDate = null;
	private static int year;
	private static String outputYear = "";
	private boolean checkValue;

	public Handler parserSearchCommand(Handler handler, String taskInfo, Logger logger) throws Exception {
		logger.log(Level.INFO, "start to parse the search command");
		checkValue = isSearchingKeyWord(handler, taskInfo, logger);
		assert handler != null;
		if (checkValue == true) {
			handler.setKeyWord(taskInfo);
		}
		return handler;
	}

	public boolean isSearchingKeyWord(Handler handler, String taskInfo, Logger logger) throws Exception {
		logger.log(Level.INFO, "start to parse the searching keyword");
		if (taskInfo.equals(EMPTY_STRING)) {
			handler.setKeyWord(taskInfo);
			return false;
		} else {
			String givenMonth = taskInfo.substring(0, 3).toLowerCase();
			String[] monthAndYear = taskInfo.split(SPACE);
			if (monthAndYear.length == 2) {
				outputYear = "" + taskInfo.split(SPACE)[1];
				if (givenMonth.contains("jan") || givenMonth.contains("feb") || givenMonth.contains("mar")
						|| givenMonth.contains("apr") || givenMonth.contains("may") || givenMonth.contains("jun")
						|| givenMonth.contains("jul") || givenMonth.contains("aug") || givenMonth.contains("sep")
						|| givenMonth.contains("oct") || givenMonth.contains("nov") || givenMonth.contains("dec")) {

					handler.setKeyWord(givenMonth + SPACE + outputYear);
					return false;
				} else {
					return true;
				}
			}

			com.joestelmach.natty.Parser dateParser = new com.joestelmach.natty.Parser();
			boolean isEndFormatCorrect = followStandardFormat(taskInfo, logger);
			SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT, Locale.ENGLISH);
			assert sdf != null;
			sdf.setLenient(false);

			if (isEndFormatCorrect == true) {
				logger.log(Level.INFO, "Endtime use our time format");
				try {
					endingDate = (Date) sdf.parse(taskInfo);
					handler.setHasEndDate(true);
					handler.getTask().setEndTime(endingDate);
				} catch (ParseException e) {
					logger.log(Level.WARNING, "EndTime is invalid in our time format");
					handler.setHasError(true);
					handler.setFeedBack(ERROR_MESSAGE_TIME_FORMAT_INVALID);
					return false;
				}
			} else {
				List<DateGroup> dateGroup2 = dateParser.parse(taskInfo);
				logger.log(Level.INFO, "Endtime use Natty");
				if (dateGroup2.isEmpty()) {
					return true;
				}
				List<Date> date2 = dateGroup2.get(0).getDates();
				endingDate = date2.get(0);
				handler.setHasEndDate(true);
				handler.getTask().setEndTime(endingDate);
			}
			return false;
		}

	}

	private boolean followStandardFormat(String dateTimeString, Logger logger) {
		String[] dateTimeArr = dateTimeString.trim().split(" ");

		if (dateTimeArr.length != 4) {
			return false;
		} else {
			// dateTimeArr len should be 4 here, now check end time
			String time = dateTimeArr[0];
			if ((time.contains(":") && (time.length() == 4 || time.length() == 5))) {

				int date;
				logger.log(Level.INFO, "start to process the date");
				try {
					date = Integer.parseInt(dateTimeArr[1], 10);
				} catch (NumberFormatException e) {
					logger.log(Level.WARNING, "the format for the date is invalid");
					return false;
				}
				// reach here means that it time given follows format and date
				// given is an int

				String givenMonth = dateTimeArr[2].toLowerCase();
				if (!(givenMonth.contains("jan") || givenMonth.contains("feb") || givenMonth.contains("mar")
						|| givenMonth.contains("apr") || givenMonth.contains("may") || givenMonth.contains("jun")
						|| givenMonth.contains("jul") || givenMonth.contains("aug") || givenMonth.contains("sep")
						|| givenMonth.contains("oct") || givenMonth.contains("nov") || givenMonth.contains("dec"))) {
					// month given follows the required format
					return false;
				} else {
					logger.log(Level.INFO, "start to process the year");
					try {
						year = Integer.parseInt(dateTimeArr[3], 10);
					} catch (NumberFormatException e) {
						logger.log(Level.WARNING, "the format for the year is invalid");
						return false;
					}
				}
			} else {
				return false;
			}
			return true;
		}
	}
}
```
###### simplyamazing\parser\ParserView.java
``` java
package simplyamazing.parser;

import java.util.logging.Level;
import java.util.logging.Logger;

public class ParserView {
	private final String STRING_EVENT = "events";
	private final String STRING_DEADLINE = "deadlines";
	private final String STRING_EMPTY = "";
	private final String STRING_DONE = "done";
	private final String STRING_TASKS = "tasks";
	private final String STRING_OVERDUE = "overdue";
	private final String COMMAND_INVALID = "Error: Please input a valid keyword. Use the \"help view\" command to see all the valid keywords";

	public Handler parserViewCommand(Handler handler, String taskInfo, Logger logger) throws Exception {
		logger.log(Level.INFO, "start to parse the search command");
		switch (taskInfo.toLowerCase()) {
		case STRING_EVENT :
			handler.setKeyWord(STRING_EVENT);
			break;
		case STRING_DEADLINE :
			handler.setKeyWord(STRING_DEADLINE);
			break;
		case STRING_EMPTY :
			handler.setKeyWord(STRING_EMPTY);
			break;
		case STRING_TASKS :
			handler.setKeyWord(STRING_TASKS);
			break;
		case STRING_OVERDUE :
			handler.setKeyWord(STRING_OVERDUE);
			break;
		case STRING_DONE :
			handler.setKeyWord(STRING_DONE);
			break;
		default :
			logger.log(Level.WARNING, "the entered command is invalid");
			handler.setHasError(true);
			handler.setFeedBack(COMMAND_INVALID);
		}
		return handler;
	}
}
```
###### test\ParserTest.java
``` java
package test;

import static org.junit.Assert.*;
import org.junit.Test;
import simplyamazing.parser.Parser;

public class ParserTest {
	private static final String EDIT_COMMAND_VALID_DESCRIPTION = "edit 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_ALT = "change 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_ALT_2 = "update 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_CAP = "EDIT 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_CAP_FIRSTCHAR = "Edit 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_CAP_SECONDCHAR = "eDit 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_CAP_THIRDCHAR = "edIt 1 description dancing";
	private static final String EDIT_COMMAND_VALID_DESCRIPTION_CAP_FOURTHCHAR = "ediT 1 description dancing";
	private static final String EDIT_COMMAND_VALID_ENDTIME = "edit 1 end 22:00 05 MAY 2016";
	private static final String EDIT_COMMAND_VALID_ENDTIME_FLEX = "EDIT 1 END 8pm next Friday";
	private static final String EDIT_COMMAND_VALID_ENDTIME_NONE = "edit 1 EnD nONE";
	private static final String EDIT_COMMAND_VALID_STARTTIME = "edit 1 start 23:00 20 Apr 2016";
	private static final String EDIT_COMMAND_VALID_STARTTIME_FLEX = "edit 1 staRT 9am tomorrow";
	private static final String EDIT_COMMAND_VALID_STARTTIME_NONE = "edit 1 START NoNe";
	private static final String EDIT_COMMAND_VALID_PRIORITY = "edit 1 priority high";
	private static final String EDIT_COMMAND_VALID_FEEDBACK = "";
	private static final String EDIT_COMMAND_INVALID_STARTTIME_BEFORE_CURRENT = "edit 2 start 12:00 30 Mar 2016";
	private static final String EDIT_COMMAND_INVALID_ENDTIME_BEFORE_CURRENT = "edit 3 end 14:00 01 Apr 2016";
	private static final String EDIT_COMMAND_INVALID_TWO_KEYWORDS = "edit 3 start 12:00 24 Mar 2016,end 15:00"
			+ " 26 Mar 2016";
	private static final String EDIT_COMMAND_INVALID_WRONG_KEYWORD = "edit 2 drink";
	private static final String EDIT_COMMAND_INVALID_WITHOUT_INDEX = "edit startTime 12:00 20 Mar 2016";
	private static final String EDIT_COMMAND_INVALID_STARTTIME = "edit 1 STart 19:00 30 Feb 2017";
	private static final String EDIT_COMMAND_INVALID_STARTTIME_DUMMY = "edit 1 StArT aBCD";
	private static final String EDIT_COMMAND_INVALID_STARTTIME_AFTER_ENDTIME = "edit 2 start 23:00 18 Apr 2017,"
			+ " end 21:00 19 Apr 2016";
	private static final String EDIT_COMMAND_INVALID_STARTTIME_EQUAL_ENDTIME = "edit 1 start 11:00 20 Apr 2016,"
			+ " end 11:00 20 Apr 2016";
	private static final String EDIT_COMMAND_INVALID_STARTTIME_NONE_ENDTIME_BEFORE_TODAY = "edit 2 STarT none,"
			+ " END 22:00 05 APR 2016";
	private static final String EDIT_COMMAND_INVALID_STARTTIME_NOTNONE_ENDTIME_NONE = "EDIT 2 stART 11:00 30 Apr"
			+ " 2017, EnD NOne";
	private static final String EDIT_COMMAND_INVALID_ENDTIME = "EdIT 1 eND 21:00 45 MaR 2017";
	private static final String EDIT_COMMAND_INVALID_ENDTIME_DUMMY = "EDit 1 ENd abCDEF";
	private static final String EDIT_COMMAND_INVALID_ENDTIME_DATE = "eDIT 1 eND 23:59 AA MAy 2018";
	private static final String EDIT_COMMAND_INVALID_ENDTIME_MONTH = "EDit 1 ENd 21:00 23 ABC 2019";
	private static final String EDIT_COMMAND_INVALID_ENDTIME_YEAR = "EDIT 1 eND 20:00 23 OCT ABCD";
	private static final String EDIT_COMMAND_INVALID_PRIORITY = "edit 1 priority abc";
	private static final String EDIT_COMMAND_INVALID_INDEX_FEEDBACK = "Error: Index provided is not an Integer.";
	private static final String EDIT_COMMAND_INVALID_DATE_BEFORE_CURRENT_FEEDBACK = "Error: Time provided must be"
			+ " after the current time";
	private static final String EDIT_COMMAND_INVALID_START_AFTER_END_FEEDBACK = "Error: Start date and time cannot"
			+ " be after the End date and time";
	private static final String EDIT_COMMAND_ERROR_MESSAGE_PRIORITY_LEVEL_FEEDBACK = "Error: Priority level can be"
			+ " only high, medium, low or none.";
	private static final String EDIT_COMMAND_ERROR_MESSAGE_NO_END_TIME_FEEDBACK = "Error: Unable to allocate a start"
			+ " time when the task has no end time";
	private static final String EDIT_COMMAND_INVALID_FEEDBACK = "Error: Please input a valid field. Use the \"help"
			+ " edit\" command to see all the valid fields";
	private static final String EDIT_COMMAND_INVALID_TIMEFORMAT_FEEDBACK = "Error: Please ensure the time format "
			+ "is valid. Please use the \"help\"command to view the format";
	private static final String EDIT_COMMAND_INVALID_NATTY_FEEDBACK = "";

	private static final String ADD_COMMAND_TYPE_VALID = "add";
	private static final String ADD_COMMAND_FLOATING_VALID = "add go home";
	private static final String ADD_COMMAND_FLOATING_VALID_CAP = "ADD go home";
	private static final String ADD_COMMAND_FLOATING_VALID_ALT = "+ go home";
	private static final String ADD_COMMAND_FLOATING_VALID_CAP_FIRSTCHAR = "Add go home";
	private static final String ADD_COMMAND_FLOATING_VALID_CAP_SECONDCHAR = "aDd go home";
	private static final String ADD_COMMAND_FLOATING_VALID_CAP_THIRDCHAR = "adD go home";
	private static final String ADD_COMMAND_FLOATING_VALID_COMPLEX = "add watch nba to 18:00 29 Apr 2016 by me from"
			+ " 19:00 29 Apr 2016";
	private static final String ADD_COMMAND_VALID_FEEDBACK = "";
	private static final String ADD_COMMAND_DEADLINE_VALID = "add finish homework by 22:00 20 Apr 2017";
	private static final String ADD_COMMAND_DEADLINE_VALID_NATTY = "add buy pens by next Monday 9pm";
	private static final String ADD_COMMAND_DEADLINE_VALID_FEEDBACK = "";
	private static final String ADD_COMMAND_EVENT_VALID = "add have a dinner from 19:00 28 Apr 2016 to 21:00 28 Apr"
			+ " 2016";
	private static final String ADD_COMMAND_EVENT_VALID_SPECIAL_STRING = "add walk *from two days from now to next "
			+ "Friday 9pm";
	private static final String ADD_COMMAND_EVENT_VALID_SPECIAL_STRING_2 = "add *camping from 11am tomorrow to 3pm "
			+ "tomorrow";
	private static final String ADD_COMMAND_EVENT_VALID_STDSTART_NATTYEND = "add watch movies from 20:00 30 APr 2016"
			+ " to 2016-04-30 9pm";
	private static final String ADD_COMMAND_EVENT_VALID_STDEND_NATTYSTART = "add pary from next Tuesday 6pm to 21:00"
			+ " 25 Apr 2016";
	private static final String ADD_COMMAND_WITH_ONLY_STARTTIME_INVALID = "add walk from 14:00 10 May 2017";
	private static final String ADD_COMMAND_STARTTIME_BEFORE_CURRENTTIME = "add test from 13:00 12 Mar 2016 to 14:00"
			+ " 11 Apr 2016";
	private static final String ADD_COMMAND_DEADLINE_NO_DESCRIPTION = "add by 23:00 01 May 2016";
	private static final String ADD_COMMAND_STARTIME_BIGGER_THAN_ENDTIME = "add swim from 21:00 22 Mar 2017 to 17:00"
			+ " 10 Mar 2016";
	private static final String ADD_COMMAND_EVENT_NO_DESCRIPTION = "add from 13:00 02 May 2016 to 16:00 02 May 2016";
	private static final String ADD_COMMAND_EVENT_FROM_AFTER_TO = "add go to nus to 12:00 04 May 2016 from 13:00 05"
			+ " May 2016";
	private static final String ADD_COMMAND_EVENT_WRONG_TIME_FORMAT = "add testing from e:rr to b:ca";
	private static final String ADD_COMMAND_EVENT_INVALID_STANDARD_TIMEFORMAT = "add go fishing from 12:00 28 Apr "
			+ "2016 to 13:00 29 Feb 2017";
	private static final String ADD_COMMAND_EVENT_INVALID_STANDARD_START_NATTY_END = "add dinner from 13:00 50 APr "
			+ "2016 to 4pm next Wednesday";
	private static final String ADD_COMMAND_EVENT_INVALID_STANDARD_START_NATTY_END_2 = "add lunch from 13:00 28 Apr "
			+ "2016 to ABCD";
	private static final String ADD_COMMAND_EVENT_INVALID_STANDARD_END_NATTY_START = "add talk from 5pm tomorrow to "
			+ "12:00 40 May 2016";
	private static final String ADD_COMMAND_EVENT_INVALID_STANDARD_END_NATTY_START_2 = "add discuss from Dummy to "
			+ "15:00 19 Apr 2017";
	private static final String ADD_COMMAND_DEADLINES_ENDTIME_BEFORE_CURRENT = "add demo by 14:00 23 Mar 2016";
	private static final String ADD_COMMAND_DEADLINES_INVALID_STANDARD_END = "add report by 23:59 60 Jun 2016";
	private static final String ADD_COMMAND_DEADLINES_INVALID_STANDARD_END_DATE = "add going by 23:00 AA May 2017";
	private static final String ADD_COMMAND_DEADLINES_INVALID_STANDARD_END_MONTH = "add hair cut by 21:00 23 BCA 2017";
	private static final String ADD_COMMAND_DEADLINES_WRONG_ENDTIME = "add study by ww:aa";
	private static final String ADD_COMMAND_NONE = "add ";
	private static final String ADD_COMMAND_EVENT_VALID_FEEDBACK = "";
	private static final String ADD_COMMAND_INVALID_FEEDBACK = "Error: Start date and time cannot be after the End "
			+ "date and time";
	private static final String ADD_COMMAND_INVALID_NATTY_FEEDBACK = "";
	private static final String ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK = "Error: Please ensure the fields "
			+ "are correct";
	private static final String ADD_COMMAND_ERROR_MESSAGE_DATE_BEFORE_CURRENT_FEEDBACK = "Error: Time provided must "
			+ "be after the current time";
	private static final String ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK = "Error: Please ensure the time format"
			+ " is valid. Please use the \"help\"command to view the format";

	private static final String HELP_COMMAND_VALID = "help";
	private static final String HELP_COMMAND_ADD_VALID = "help add";
	private static final String HELP_COMMAND_ADD_VALID_ALT = "? add";
	private static final String HELP_COMMAND_REDO_VALID_ALT = "? rEdO";
	private static final String HELP_COMMAND_UNDONE_VALID_ALT = "? unMArk";
	private static final String HELP_COMMAND_ADD_VALID_CAP = "HELP add";
	private static final String HELP_COMMAND_DELETE_VALID = "help delete";
	private static final String HELP_COMMAND_EDIT_VALID = "help edit";
	private static final String HELP_COMMAND_VIEW_VALID = "help view";
	private static final String HELP_COMMAND_MARK_VALID = "help MArk";
	private static final String HELP_COMMAND_SEARCH_VALID = "help search";
	private static final String HELP_COMMAND_UNDO_VALID = "help undo";
	private static final String HELP_COMMAND_LOCATION_VALID = "help location";
	private static final String HELP_COMMAND_EXIT_VALID = "help exit";
	private static final String HELP_COMMAND_VALID_FEEDBACK = "";
	private static final String HELP_COMMAND_INVALID_WITH_STRING = "help abc";
	private static final String HELP_COMMAND_INVALID_FEEDBACK = "Error: Please input a valid keyword. Use the "
			+ "\"help\" command to view all valid keywords";

	private static final String DELETE_COMMAND_VALID_INDEX = "delete 1";
	private static final String DELETE_COMMAND_VALID_ALT = "- 1";
	private static final String DELETE_COMMAND_VALID_ALT_2 = "del 1";
	private static final String DELETE_COMMAND_VALID_ALT_3 = "remove 1";
	private static final String DELETE_COMMAND_VALID_ALT_4 = "cancel 1";
	private static final String DELETE_COMMAND_VALID_CAP = "DELETE 1";
	private static final String DELETE_COMMAND_VALID_ALT_2_CAP = "DEL 1";
	private static final String DELETE_COMMAND_VALID_ALT_3_CAP = "REMOVE 1";
	private static final String DELETE_COMMAND_VALID_ALT_4_CAP = "CANCEL 1";
	private static final String DELETE_COMMAND_VALID_INDEX_FEEDBACK = "";
	private static final String DELETE_COMMAND_INVALID_DUMMY_STRING = "delete cba";
	private static final String DELETE_COMMAND_INVALID_FEEDBACK = "Error: Index provided is not an Integer.";

	private static final String LOCATION_COMMAND_INVALID = "location ";
	private static final String LOCATION_COMMAND_VALID = "location C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_VALID_ALT = "path C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_VALID_ALT_2 = "address C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_VALID_CAP = "LOCATION C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_VALID_ALT_CAP = "PATH C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_VALID_ALT_2_CAP = "ADDRESS C:\"Users\"Ishpal\"Desktop\"Task Data";
	private static final String LOCATION_COMMAND_INVALID_FEEDBACK = "Error: Location provided is invalid";
	private static final String LOCATION_COMMAND_VALID_FEEDBACK = "";
	private static final boolean LOCATION_COMMAND_ERROR = true;

	private static final String DONE_COMMAND_VALID = "done 1";
	private static final String DONE_COMMAND_VALID_ALT = "finish 1";
	private static final String DONE_COMMAND_VALID_ALT_2 = "complete 1";
	private static final String DONE_COMMAND_VALID_ALT_3 = "mark 1";
	private static final String DONE_COMMAND_VALID_CAP = "DONE 1";
	private static final String DONE_COMMAND_VALID_ALT_CAP = "FINISH 1";
	private static final String DONE_COMMAND_VALID_ALT_2_CAP = "COMPLETE 1";
	private static final String DONE_COMMAND_VALID_ALT_3_CAP = "MARK 1";
	private static final String DONE_COMMAND_VALID_FEEDBACK = "";
	private static final String DONE_COMMAND_INVALID_WRONG_KEYWORD = "done home";
	private static final String DONE_COMMAND_INVALID_FEEDBACK = "Error: Index provided is not an Integer.";
	private static final String DONE_COMMAND_VALID_INDEX = "1";

	private static final String VIEW_COMMAND_VALID = "view";
	private static final String VIEW_COMMAND_EVENT_VALID = "view events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT = "display events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT_2 = "show events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT_3 = "list events";
	private static final String VIEW_COMMAND_EVENT_VALID_CAP = "VIEW events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT_CAP = "DISPLAY events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT_2_CAP = "SHOW events";
	private static final String VIEW_COMMAND_EVENT_VALID_ALT_3_CAP = "LIST events";
	private static final String VIEW_COMMAND_DEADLINES_VALID = "view deadlines";
	private static final String VIEW_COMMAND_TASKS_VALID = "view tasks";
	private static final String VIEW_COMMAND_DONE_VALID = "view done";
	private static final String VIEW_COMMAND_OVERDUE_VALID = "view overdue";
	private static final String VIEW_COMMAND_VALID_FEEDBACK = "";
	private static final String VIEW_COMMAND_INVALID_WRONG_KEYWORD = "view abc";
	private static final String VIEW_COMMAND_INVALID_FEEDBACK = "Error: Please input a valid keyword. Use the "
			+ "\"help view\" command to see all the valid keywords";

	private static final String SEARCH_COMMAND_VALID_EMPTY = "SEARCH";
	private static final String SEARCH_COMMAND_VALID_FLEXICMD = "sEaRch this Sunday";
	private static final String SEARCH_COMMAND_VALID_STANDARDFMT = "searCH 22:00 01 May 2017";
	private static final String SEARCH_COMMAND_VALID_MONTH = "Search Apr";
	private static final String SEARCH_COMMAND_VALID_MONTH_AND_YEAR = "Search MAY 2017";
	private static final String SEARCH_COMMAND_VALID = "search dinner";
	private static final String SEARCH_COMMAND_VALID_ALT = "find dinner";
	private static final String SEARCH_COMMAND_VALID_CAP = "SEARCH dinner";
	private static final String SEARCH_COMMAND_VALID_ALT_CAP = "FIND dinner";
	private static final String SEARCH_COMMAND_VALID_KEYWORD = "dinner";
	private static final String SEARCH_COMMAND_INVALID_STANDARDFMT = "seARch 21:00 30 Feb 2016";
	private static final String SEARCH_COMMAND_INVALID_STANDARDFMT_2 = "SEarCh 20:00 Ab May 2016";
	private static final String SEARCH_COMMAND_INVALID_MONTH = "SeARCH 18:00 23 UUU 2017";
	private static final String SEARCH_COMMAND_INVALID_YEAR = "SEaRcH 18:00 23 MAY ABCD";
	private static final String SEARCH_COMMAND_VALID_FEEDBACK = "";
	private static final String SEARCH_COMMAND_INVALID_FEEDBACK = "Error: Please ensure the time format is "
			+ "valid. Please use the \"help\"command to view the format";
	private static final String SEARCH_COMMAND_INVALID_FEEDBACK_TO_NATTY = "";

	private static final String UNDO_COMMAND_VALID = "undo";
	private static final String UNDO_COMMAND_VALID_FEEDBACK = "";

	private static final String REDO_COMMAND_VALID = "redo";
	private static final String REDO_COMMAND_VALID_FEEDBACK = "";

	private static final String UNDONE_COMMAND_VALID = "undone 1 2";
	private static final String UNDONE_COMMAND_VALID_ALT = "unMARK 1";
	private static final String UNDONE_COMMAND_VALID_FEEDBACK = "";
	private static final String UNDONE_COMMAND_INVALID_WRONG_KEYWORD = "done WOrk";
	private static final String UNDONE_COMMAND_INVALID_FEEDBACK = "Error: Index provided is not an Integer.";

	private static final String EXIT_COMMAND_VALID = "exit";
	private static final String EXIT_COMMAND_VALID_ALT = "quit";
	private static final String EXIT_COMMAND_VALID_ALT_2 = "logout";
	private static final String EXIT_COMMAND_VALID_CAP = "EXIT";
	private static final String EXIT_COMMAND_VALID_ALT_CAP = "QUIT";
	private static final String EXIT_COMMAND_VALID_ALT_2_CAP = "LOGOUT";
	private static final String EXIT_COMMAND_VALID_CAP_FIRSTCHAR = "Exit";
	private static final String EXIT_COMMAND_VALID_CAP_SECONDCHAR = "eXit";
	private static final String EXIT_COMMAND_VALID_CAP_THIRDCHAR = "exIt";
	private static final String EXIT_COMMAND_VALID_CAP_FOURTHCHAR = "exiT";
	private static final String EXIT_COMMAND_VALID_FEEDBACK = "";

	private static final String WRONG_COMMAND_TYPE = "redoing";
	private static final String WRONG_COMMAND_TYPE_FEEDBACK = "Error: Invalid command entered. Please enter"
			+ " \"help\" to view command format";

	private static Parser parser = new Parser();

	@Test // (expected = Exception.class)
	/*
	 * The following test uses the equivalence partitioning for heuristic
	 * testing. There are two equivalent partitions which are valid and invalid
	 * commands.
	 */
	public void testAddCommand() throws Exception {
		assertEquals(ADD_COMMAND_TYPE_VALID, parser.getHandler(ADD_COMMAND_FLOATING_VALID).getCommandType());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_FLOATING_VALID).getFeedBack());
		assertEquals(ADD_COMMAND_EVENT_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_EVENT_VALID).getFeedBack());
		assertEquals(ADD_COMMAND_EVENT_VALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_VALID_SPECIAL_STRING).getFeedBack());
		assertEquals(ADD_COMMAND_EVENT_VALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_VALID_SPECIAL_STRING_2).getFeedBack());
		assertEquals(ADD_COMMAND_EVENT_VALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_VALID_STDSTART_NATTYEND).getFeedBack());
		assertEquals(ADD_COMMAND_EVENT_VALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_VALID_STDEND_NATTYSTART).getFeedBack());
		assertEquals(ADD_COMMAND_DEADLINE_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_DEADLINE_VALID).getFeedBack());
		assertEquals(ADD_COMMAND_DEADLINE_VALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_DEADLINE_VALID_NATTY).getFeedBack());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_FLOATING_VALID_CAP).getFeedBack());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_FLOATING_VALID_ALT).getFeedBack());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_FLOATING_VALID_CAP_FIRSTCHAR).getFeedBack());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_FLOATING_VALID_CAP_SECONDCHAR).getFeedBack());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_FLOATING_VALID_CAP_THIRDCHAR).getFeedBack());
		assertEquals(ADD_COMMAND_VALID_FEEDBACK, parser.getHandler(ADD_COMMAND_FLOATING_VALID_COMPLEX).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK,
				parser.getHandler(ADD_COMMAND_WITH_ONLY_STARTTIME_INVALID).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_STARTIME_BIGGER_THAN_ENDTIME).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_MESSAGE_DATE_BEFORE_CURRENT_FEEDBACK,
				parser.getHandler(ADD_COMMAND_STARTTIME_BEFORE_CURRENTTIME).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK,
				parser.getHandler(ADD_COMMAND_DEADLINE_NO_DESCRIPTION).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_NO_DESCRIPTION).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_FROM_AFTER_TO).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_MESSAGE_DATE_BEFORE_CURRENT_FEEDBACK,
				parser.getHandler(ADD_COMMAND_DEADLINES_ENDTIME_BEFORE_CURRENT).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_WRONG_TIME_FORMAT).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_INVALID_STANDARD_TIMEFORMAT).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_INVALID_STANDARD_START_NATTY_END).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_INVALID_STANDARD_START_NATTY_END_2).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_INVALID_STANDARD_END_NATTY_START).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_EVENT_INVALID_STANDARD_END_NATTY_START_2).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_DEADLINES_WRONG_ENDTIME).getFeedBack());
		assertEquals(ADD_COMMAND_ERROR_TIME_FORMAT_INVALID_FEEDBACK,
				parser.getHandler(ADD_COMMAND_DEADLINES_INVALID_STANDARD_END).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_FIELDS_NOT_CORRECT_FEEDBACK,
				parser.getHandler(ADD_COMMAND_NONE).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_NATTY_FEEDBACK,
				parser.getHandler(ADD_COMMAND_DEADLINES_INVALID_STANDARD_END_DATE).getFeedBack());
		assertEquals(ADD_COMMAND_INVALID_NATTY_FEEDBACK,
				parser.getHandler(ADD_COMMAND_DEADLINES_INVALID_STANDARD_END_MONTH).getFeedBack());
	}

	@Test // (expected = Exception.class)
	public void testLocationCommand() throws Exception {
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_VALID).getFeedBack());
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_VALID_ALT).getFeedBack());
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_VALID_ALT_2).getFeedBack());
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_VALID_CAP).getFeedBack());
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_VALID_ALT_CAP).getFeedBack());
		assertEquals(LOCATION_COMMAND_VALID_FEEDBACK,
				parser.getHandler(LOCATION_COMMAND_VALID_ALT_2_CAP).getFeedBack());
		assertEquals(LOCATION_COMMAND_INVALID_FEEDBACK, parser.getHandler(LOCATION_COMMAND_INVALID).getFeedBack());
		assertEquals(LOCATION_COMMAND_ERROR, parser.getHandler(LOCATION_COMMAND_INVALID).getHasError());
	}

	@Test
	public void testEditCommand() throws Exception {
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_ALT).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_ALT_2).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_CAP).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_CAP_FIRSTCHAR).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_CAP_SECONDCHAR).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_CAP_THIRDCHAR).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_VALID_DESCRIPTION_CAP_FOURTHCHAR).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_STARTTIME).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_STARTTIME_FLEX).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_STARTTIME_NONE).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_ENDTIME).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_ENDTIME_FLEX).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_ENDTIME_NONE).getFeedBack());
		assertEquals(EDIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EDIT_COMMAND_VALID_PRIORITY).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_WRONG_KEYWORD).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_TIMEFORMAT_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_STARTTIME).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_TIMEFORMAT_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_STARTTIME_DUMMY).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_TIMEFORMAT_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_ENDTIME).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_TIMEFORMAT_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_ENDTIME_DUMMY).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_INDEX_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_WITHOUT_INDEX).getFeedBack());
		assertEquals(EDIT_COMMAND_ERROR_MESSAGE_PRIORITY_LEVEL_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_PRIORITY).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_DATE_BEFORE_CURRENT_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_STARTTIME_BEFORE_CURRENT).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_DATE_BEFORE_CURRENT_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_ENDTIME_BEFORE_CURRENT).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_DATE_BEFORE_CURRENT_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_TWO_KEYWORDS).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_START_AFTER_END_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_STARTTIME_AFTER_ENDTIME).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_START_AFTER_END_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_STARTTIME_EQUAL_ENDTIME).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_DATE_BEFORE_CURRENT_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_STARTTIME_NONE_ENDTIME_BEFORE_TODAY).getFeedBack());
		assertEquals(EDIT_COMMAND_ERROR_MESSAGE_NO_END_TIME_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_STARTTIME_NOTNONE_ENDTIME_NONE).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_NATTY_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_ENDTIME_DATE).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_NATTY_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_ENDTIME_MONTH).getFeedBack());
		assertEquals(EDIT_COMMAND_INVALID_TIMEFORMAT_FEEDBACK,
				parser.getHandler(EDIT_COMMAND_INVALID_ENDTIME_YEAR).getFeedBack());
	}

	@Test // (expected = Exception.class)
	public void testHelpCommand() throws Exception {
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_ADD_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_ADD_VALID_ALT).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_REDO_VALID_ALT).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_UNDONE_VALID_ALT).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_ADD_VALID_CAP).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_DELETE_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_VIEW_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_LOCATION_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_MARK_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_EXIT_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_SEARCH_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_EDIT_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_VALID_FEEDBACK, parser.getHandler(HELP_COMMAND_UNDO_VALID).getFeedBack());
		assertEquals(HELP_COMMAND_INVALID_FEEDBACK, parser.getHandler(HELP_COMMAND_INVALID_WITH_STRING).getFeedBack());
	}

	@Test // (expected = Exception.class)
	public void testDeleteCommand() throws Exception {
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_INDEX).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_ALT).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_ALT_2).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_ALT_3).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_ALT_4).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK, parser.getHandler(DELETE_COMMAND_VALID_CAP).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK,
				parser.getHandler(DELETE_COMMAND_VALID_ALT_2_CAP).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK,
				parser.getHandler(DELETE_COMMAND_VALID_ALT_3_CAP).getFeedBack());
		assertEquals(DELETE_COMMAND_VALID_INDEX_FEEDBACK,
				parser.getHandler(DELETE_COMMAND_VALID_ALT_4_CAP).getFeedBack());
		assertEquals(DELETE_COMMAND_INVALID_FEEDBACK,
				parser.getHandler(DELETE_COMMAND_INVALID_DUMMY_STRING).getFeedBack());
	}

	@Test // (expected = Exception.class)
	public void testDoneOrUnDoneCommand() throws Exception {
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT_2).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT_3).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_CAP).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT_CAP).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT_2_CAP).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_FEEDBACK, parser.getHandler(DONE_COMMAND_VALID_ALT_3_CAP).getFeedBack());
		assertEquals(DONE_COMMAND_VALID_INDEX, parser.getHandler(DONE_COMMAND_VALID).getIndexList().get(0).toString());
		assertEquals(DONE_COMMAND_INVALID_FEEDBACK,
				parser.getHandler(DONE_COMMAND_INVALID_WRONG_KEYWORD).getFeedBack());
	}

	@Test
	public void testViewCommand() throws Exception {
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_EVENT_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT_2).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT_3).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_EVENT_VALID_CAP).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT_CAP).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT_2_CAP).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_EVENT_VALID_ALT_3_CAP).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_DEADLINES_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_TASKS_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_DONE_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_VALID_FEEDBACK, parser.getHandler(VIEW_COMMAND_OVERDUE_VALID).getFeedBack());
		assertEquals(VIEW_COMMAND_INVALID_FEEDBACK,
				parser.getHandler(VIEW_COMMAND_INVALID_WRONG_KEYWORD).getFeedBack());
	}

	@Test
	public void testSearchCommand() throws Exception {
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID_EMPTY).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID_ALT).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID_CAP).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID_ALT_CAP).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_KEYWORD, parser.getHandler(SEARCH_COMMAND_VALID).getKeyWord());
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID_MONTH).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK,
				parser.getHandler(SEARCH_COMMAND_VALID_MONTH_AND_YEAR).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID_FLEXICMD).getFeedBack());
		assertEquals(SEARCH_COMMAND_VALID_FEEDBACK, parser.getHandler(SEARCH_COMMAND_VALID_STANDARDFMT).getFeedBack());
		assertEquals(SEARCH_COMMAND_INVALID_FEEDBACK,
				parser.getHandler(SEARCH_COMMAND_INVALID_STANDARDFMT).getFeedBack());
		assertEquals(SEARCH_COMMAND_INVALID_FEEDBACK_TO_NATTY,
				parser.getHandler(SEARCH_COMMAND_INVALID_STANDARDFMT_2).getFeedBack());
		assertEquals(SEARCH_COMMAND_INVALID_FEEDBACK_TO_NATTY,
				parser.getHandler(SEARCH_COMMAND_INVALID_MONTH).getFeedBack());
		assertEquals(SEARCH_COMMAND_INVALID_FEEDBACK_TO_NATTY,
				parser.getHandler(SEARCH_COMMAND_INVALID_YEAR).getFeedBack());
	}

	@Test
	public void testUndoCommand() throws Exception {
		assertEquals(UNDO_COMMAND_VALID_FEEDBACK, parser.getHandler(UNDO_COMMAND_VALID).getFeedBack());
	}

	@Test
	public void testExitCommand() throws Exception {
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_ALT).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_ALT_2).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_CAP).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_ALT_CAP).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_ALT_2_CAP).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_CAP_FIRSTCHAR).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_CAP_SECONDCHAR).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_CAP_THIRDCHAR).getFeedBack());
		assertEquals(EXIT_COMMAND_VALID_FEEDBACK, parser.getHandler(EXIT_COMMAND_VALID_CAP_FOURTHCHAR).getFeedBack());
	}

	@Test
	public void testInvalidCommand() throws Exception {
		assertEquals(WRONG_COMMAND_TYPE_FEEDBACK, parser.getHandler(WRONG_COMMAND_TYPE).getFeedBack());
	}

	@Test
	public void testRedoCommand() throws Exception {
		assertEquals(REDO_COMMAND_VALID_FEEDBACK, parser.getHandler(REDO_COMMAND_VALID).getFeedBack());
	}

	@Test
	public void testUndoneCommand() throws Exception {
		assertEquals(UNDONE_COMMAND_VALID_FEEDBACK, parser.getHandler(UNDONE_COMMAND_VALID).getFeedBack());
		assertEquals(UNDONE_COMMAND_VALID_FEEDBACK, parser.getHandler(UNDONE_COMMAND_VALID_ALT).getFeedBack());
		assertEquals(UNDONE_COMMAND_INVALID_FEEDBACK,
				parser.getHandler(UNDONE_COMMAND_INVALID_WRONG_KEYWORD).getFeedBack());

	}

}
```
###### test\TaskTest.java
``` java
package test;

import static org.junit.Assert.assertEquals;

import java.util.Date;

import org.junit.Test;

import simplyamazing.data.Task;

public class TaskTest {
	
	@Test
	public void testFloatingTaskCreation() {
		Task task = new Task("go swimming");
		Task taskCompare = new Task("go swimming");
		assertEquals("go swimming, , , ,incomplete", task.toString());
		assertEquals(1, task.getTaskType());
		assertEquals(0,task.compareTo(taskCompare));
	}
	
	@Test
	public void testDeadlineCreation() throws Exception {
		Task task = new Task();
		task = new Task("go swimming", "17:30 30 May 2016");
		assertEquals("go swimming, ,17:30 30 May 2016, ,incomplete", task.toString());
	}
	
	@Test 
	public void testEventCreation() throws Exception {
		Task task = new Task();
		task = new Task("go swimming", "15:30 28 MAY 2016", "17:30 30 May 2016");
		assertEquals("go swimming,15:30 28 May 2016,17:30 30 May 2016, ,incomplete", task.toString());
	}

	@Test
	public void testSetDescriptionMethod() {
		Task task = new Task();
		task.setDescription("study for exam");
		assertEquals("study for exam, , , ,incomplete", task.toString());
		assertEquals("study for exam", task.getDescription());
	}
	
	@Test
	public void testSetStartTimeMethod() throws Exception {
		Task task = new Task("go home");
		task.setStartTime("15:30 28 Apr 2016");
		Task taskCompare = new Task("go to school");
		taskCompare.setStartTime("15:29 28 Apr 2016");
		assertEquals(1,task.compareTo(taskCompare));
		assertEquals("go home,15:30 28 Apr 2016, , ,incomplete", task.toString());
		assertEquals("15:30 28 Apr 2016",Task.convertDateToString(task.getStartTime()));
		task.setStartTime("19:00 31 MAy 2016"); 
		Date startTime = task.getStartTime();
		task.setStartTime(startTime);
		assertEquals("19:00 31 May 2016",Task.convertDateToString(task.getStartTime()));
	}
	
	@Test
	public void testSetEndTimeMethod() throws Exception {
		Task task = new Task("go swimming");
		task.setEndTime("17:30 30 may 2016");
		Task taskCompare = new Task("go shopping");
		taskCompare.setEndTime("17:31 30 MAY 2016");
		assertEquals(-1,task.compareTo(taskCompare));
		assertEquals("go swimming, ,17:30 30 May 2016, ,incomplete", task.toString());
		task.setEndTime("20:30 31 may 2016"); 
		Date endTime = task.getEndTime();
		task.setEndTime(endTime);
		assertEquals("20:30 31 May 2016",Task.convertDateToString(task.getEndTime()));
	}
	
	@Test
	public void testSetPriorityMethod() throws Exception {
		Task task = new Task("study for exam");
		task.setPriority("hiGH");
		assertEquals("study for exam, , ,high,incomplete", task.toString());
		task.setPriority("meDIUM");
		assertEquals("study for exam, , ,medium,incomplete", task.toString());
		task.setPriority("LOW");
		assertEquals("study for exam, , ,low,incomplete", task.toString());
		task.setPriority(0);
		task.setPriority("NOne");
		assertEquals(0, task.getPriority());
	}
	
	@Test
	public void testSetDoneMethod() {
		Task task = new Task("go swimming");
		task.setDone(true);
		assertEquals("go swimming, , , ,done", task.toString());
		task.setDone(false);
		assertEquals("go swimming, , , ,incomplete", task.toString());
	}
}
```
