# A0125136N
###### simplyamazing\logic\Logic.java
``` java

package simplyamazing.logic;

import java.util.ArrayList;
import java.util.Date;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import simplyamazing.data.Task;
import simplyamazing.parser.Handler;
import simplyamazing.parser.Parser;
import simplyamazing.storage.Storage;

/*
 * This class manages the flow of the program execution for SimplyAmazing.
 * It is responsible for breaking down the user's command, with the help of the Parser component and then
 * executing the instruction through interacting with the Storage component.
 * 
 * @author A0125136N
 */

public class Logic {
 
	private static Logger logger;
	private static Parser parserObj;
	private static Storage storageObj;
	private static ArrayList<Task> taskList;
	private static String lastModifyCommand;
	private static String previousCommandString;
	private static Handler commandHandler;
	
	private static final String STRING_EMPTY = "";
	private static final String FILE_PATH = "C:\\Users\\Public\\SimplyAmazing\\logFile.txt";
	private static final String DOUBLE_QUOTATION = "\"";
	
	private static final int EXIT_WITHOUT_ERROR = 0;
	private static final int EMPTY_LIST_SIZE = 0;
	private static final int ONE_ELEMENT_IN_LIST = 1;
	private static final int FIRST_ELEMENT_INDEX = 0;
	private static final int INVALID_INDEX = -1;
	
	//The following are error messages which will be displayed to the user
	private static final String ERROR_INVALID_DIRECTORY = "Error: Not a valid directory";
	private static final String ERROR_INVALID_INDEX = "Error: The Index entered is invalid";
	private static final String ERROR_INVALID_INDEX_MULTIPLE = "Error: One of the given indexes is invalid";
	private static final String ERROR_PREVIOUS_COMMAND_INVALID = "Error: There is no previous command to undo"; 
	private static final String ERROR_PREVIOUS_COMMAND_INVALID_REDO = "Error: There is no previous command to redo";
	private static final String ERROR_NO_END_TIME = "Error: Unable to allocate a start time when the task has no end time";
	private static final String ERROR_INVALID_END_TIME = "Error: Unable to remove end time for an event";
	private static final String ERROR_START_AFTER_END = "Error: New start time cannot be after the end time";
	private static final String ERROR_START_SAME_AS_END = "Error: New start time cannot be the same as the end time";
	private static final String ERROR_END_BEFORE_START = "Error: New end time cannot be before the start time";
	private static final String ERROR_END_SAME_AS_START = "Error: New end time cannot be the same as the start time";
	private static final String ERROR_DOUBLE_UNDO = "Error: Unable to undo an undo command. Use the redo command instead";
	private static final String ERROR_DOUBLE_REDO = "Error: Unable to redo a redo command. Use the undo command instead";
	private static final String ERROR_INVALID_COMMAND = "Error: Invalid command entered. Please enter \"help\""
			+ " to view all commands and their format";

	// The following are messages which will be displayed to the user
	private static final String MESSAGE_EMPTY_LIST = "List is empty";
	private static final String MESSAGE_UNDO_SUCCESSFUL = " command has been successfully undone.";
	private static final String MESSAGE_REDO_SUCCESSFUL = " command has been successfully executed again.";
	private static final String MESSAGE_NO_TASKS_FOUND = "There are no tasks containing the given keyword";
	private static final String MESSAGE_HELP_REDO = "Redo the most recent command\nCommand: redo\n";
	private static final String MESSAGE_HELP_UNDO = "Undo the most recent command\nCommand: undo\n";
	
	private static final String MESSAGE_HELP_EXIT = "Exits SimplyAmazing\nCommand: exit\n\n\nNote: You may also use "
			+ "\"logout\" or \"quit\" instead of \"exit\"";
	
	private static final String MESSAGE_HELP_UNMARK = "Unmarks a completed task\nCommand: undone <task index>\n\n"
			+ "Example:\nundone 2\n\n\nNote: You may also use the keyword \"unmark\" instead of \"undone\"";
	
	private static final String MESSAGE_HELP_SEARCH = "Search for tasks containing the given keyword or date \n"
			+ "Command: search <keyword> or search<date>\n\nExample:\nsearch meeting\n\n\n"
			+ "Note: You may also use the keyword \"find\" instead of \"search\"";
	
	private static final String MESSAGE_HELP_MARK = "Marks task as completed\nCommand: done <task index>\n\n"
			+ "Example:\ndone 2\n\n\n"
			+ "Note: You may also use the keywords \"mark\", \"complete\" or \"finish\" instead of \"done\"";
	
	private static final String MESSAGE_HELP_DELETE = "Delete task from list\nCommand: delete <task index>\n\n"
			+ "Example:\ndelete 1\n\n\n"
			+ "Note: You may also use the keywords \"-\", \"del\", \"remove\" or \"cancel\" instead of \"delete\"";
	
	private static final String MESSAGE_HELP_EDIT = "Edit content in a task\nCommand: edit <task index> <task header> "
			+ "<updated content>\n\n"
			+ "Example:\n1. edit 4 description send marketing report\n\n2. edit 3 start 22:00 26 may 2016,"
			+ " end 22:40 26 may 2016\n\n3. edit 1 priority high\n\n\n"
			+ "Note: You may also use the keywords \"change\" or \"update\" instead of \"edit\"";

	private static final String MESSAGE_HELP = "Key in the following to view specific command formats:\n"
			+ "1. help add\n2. help delete\n3. help edit\n4. help view\n5. help search \n6. help mark\n"
			+ "7. help unmark\n8. help undo\n9. help redo\n10. help location \n11. help exit\n";

	private static final String MESSAGE_HELP_LOCATION = "Sets the storage location or folder for application data\n"
			+ "Command: location <path>\n" + "\n"
			+ "Example:\nlocation C:\\Users\\Jim\\Desktop\\Task Data\n\n\n"
			+ "Note: You may also use the keywords \"path\" or \"address\" instead of \"location\"";

	private static final String MESSAGE_HELP_VIEW = "1.Display all tasks\n Command: view\n\n"
			+ "2.Display tasks with deadlines\nCommand: view deadlines\n\n"
			+ "3.Display all events\nCommand: view events\n\n"
			+ "4.Display tasks without deadlines\nCommand: view tasks\n\n"
			+ "5.Display completed tasks\nCommand: view done\n\n"
			+ "6.Display overdue tasks\nCommand: view overdue\n\n\n"
			+ "Note: You may also use the keywords \"display\", \"show\" or \"list\" instead of \"view\"";

	private static final String MESSAGE_HELP_ADD_TASK = "1.Add a task to the list\nCommand: add <task description>\n\n"
			+ "Example: add Prepare presentation\n\n\n2.Add an event to the list\n"
			+ "command: add <task description> from <start time hh:mm> <start date dd MMM yyyy> to\n<end time hh:mm> "
			+ "<end date dd MMM yyyy>\n\n"
			+ "Example: add Company annual dinner from 19:00 29 Dec 2016 to 22:00 29 dec 2016\n\n\n"
			+ "3.Add a deadline to the list\ncommand: add <task description> by <end time hh:mm> <end date dd MMM yyyy>\n\n"
			+ "Example: add Submit marketing report by 17:00 20 Dec 2016\n\n\n"
			+ "Note: You may use the keyword \"+\" instead of \"add\"";


	enum CommandType {
		ADD_TASK, VIEW_LIST, DELETE_TASK,INVALID,
		SEARCH_KEYWORD, UNDO_LAST, EDIT_TASK, SET_LOCATION,
		MARK_TASK, UNMARK_TASK, REDO, HELP, EXIT;
	};


	public Logic() {
		parserObj = new Parser();
		storageObj = new Storage();
		taskList = new ArrayList<Task>();
		commandHandler = new Handler();
		lastModifyCommand = STRING_EMPTY;
		previousCommandString = STRING_EMPTY;
		logger = Logger.getLogger("simplyamazing");
		try {
			FileHandler fileHandler = new FileHandler(FILE_PATH, true);
			logger.addHandler(fileHandler);
			SimpleFormatter formatter = new SimpleFormatter();  
			fileHandler.setFormatter(formatter);
		} catch (Exception e) {
			System.out.println("Error while setting up filehandler");
		}
	}


	private static CommandType getCommandType(String commandWord) {
		assert commandWord != null;
		
		if (commandWord.equalsIgnoreCase("add")) {
			return CommandType.ADD_TASK;
		} else if (commandWord.equalsIgnoreCase("delete")) {
			return CommandType.DELETE_TASK;
		} else if (commandWord.equalsIgnoreCase("view")) {
			return CommandType.VIEW_LIST;
		} else if (commandWord.equalsIgnoreCase("edit")) {
			return CommandType.EDIT_TASK;
		} else if (commandWord.equalsIgnoreCase("search")) {
			return CommandType.SEARCH_KEYWORD;
		} else if (commandWord.equalsIgnoreCase("undo")) {
			return CommandType.UNDO_LAST;
		} else if (commandWord.equalsIgnoreCase("redo")) {
			return CommandType.REDO;
		} else if (commandWord.equalsIgnoreCase("location")) {
			return CommandType.SET_LOCATION;
		} else if (commandWord.equalsIgnoreCase("done")) {
			return CommandType.MARK_TASK;
		} else if (commandWord.equalsIgnoreCase("undone")) {
			return CommandType.UNMARK_TASK;
		} else if (commandWord.equalsIgnoreCase("help")) {
			return CommandType.HELP;
		} else if (commandWord.equalsIgnoreCase("exit")) {
			return CommandType.EXIT;
		} else {
			return CommandType.INVALID;
		}
	}

	
	/*
	 * This method controls how the command is executed, based on the different command types given.
	 * It is also responsible for passing on feedback messages, regarding the status of the commands,
	 * to the UI
	 */
	public String executeCommand(String userCommand) throws Exception {
		logger.log(Level.INFO, "going to execute command");

		commandHandler = parserObj.getHandler(userCommand);
		assert commandHandler != null;                      
		logger.log(Level.INFO, "commandHandler is not null");

		String commandWord = commandHandler.getCommandType();
		CommandType commandType = getCommandType(commandWord);
		String feedback = STRING_EMPTY;

		switch (commandType) {
		case ADD_TASK :
			feedback = executeAddCommand(commandHandler);
			break;
		case DELETE_TASK :
			feedback = executeDeleteCommand(commandHandler);
			break;
		case VIEW_LIST :
			feedback = executeViewCommand(commandHandler);
			break;
		case EDIT_TASK :
			feedback = executeEditCommand(commandHandler);
			break;
		case SEARCH_KEYWORD :
			feedback = executeSearchCommand(commandHandler);
			break;
		case UNDO_LAST :
			feedback = executeUndoCommand(commandHandler);
			break;
		case REDO :
			feedback = executeRedoCommand(commandHandler);
			break;
		case SET_LOCATION :
			feedback = executeSetLocationCommand(commandHandler);
			break;
		case MARK_TASK :
			feedback = executeMarkCommand(commandHandler);
			break;
		case UNMARK_TASK :
			feedback = executeUnmarkCommand(commandHandler);
			break;
		case HELP :
			feedback = executeHelpCommand(commandHandler);
			break;
		case EXIT :
			System.exit(EXIT_WITHOUT_ERROR);
		default:
			return ERROR_INVALID_COMMAND;
		}
		
		previousCommandString = userCommand;
		assert previousCommandString != null;
		boolean isListModified = hasListBeenModified(commandType);

		if (isListModified == true) {
			logger.log(Level.INFO, "command has modified the list, setting new lastModify Command now");
			lastModifyCommand = userCommand;
		}
		logger.log(Level.INFO, "about to return to UI");
		return feedback;
	}

	
	/*
	 * This method is responsible for executing the add command and reporting on its success to the 
	 * UI
	 */
	private static String executeAddCommand(Handler commandHandler) throws Exception {
		if (commandHandler.getHasError() == true) {
			logger.log(Level.WARNING, "handler has reported an error in add");
			return commandHandler.getFeedBack();

		} else {
			logger.log(Level.INFO, "no error with add, interacting with storage now");
			Task taskToAdd = commandHandler.getTask();
			assert taskToAdd != null;
			return storageObj.addTask(taskToAdd);
		}
	}
	
	
	/*
	 * This method executes the delete command. The status of the command, whether it is successful or
	 * unsuccessful will be returned to the UI which will then display it to the user.
	 */
	private static String executeDeleteCommand(Handler commandHandler) throws Exception {
		if (commandHandler.getHasError() == true) {
			logger.log(Level.WARNING, "handler has reported an error in delete");
			return commandHandler.getFeedBack();

		} else {

			ArrayList<Integer> listToDelete = commandHandler.getIndexList();
			boolean isIndexValid = true;
			int indexToDelete = INVALID_INDEX;
			
			if (listToDelete.size() == ONE_ELEMENT_IN_LIST) {
				logger.log(Level.INFO, "list contains only one task to delete");
				indexToDelete = listToDelete.get(FIRST_ELEMENT_INDEX);

				isIndexValid = canRetrieveIndex(indexToDelete);
				
				if (isIndexValid == false) {
					logger.log(Level.WARNING, "index given is invalid");
					return ERROR_INVALID_INDEX;
				}
				
				logger.log(Level.INFO, "index valid, interacting with storage now");
				Task taskToDelete = taskList.get(indexToDelete - 1);
				return storageObj.deleteTask(taskToDelete);
				
			} else {
				return deleteMultiple(listToDelete);
			}
		}
	}
	
	
	/*
	 * This method facilitates the deletion of multiple indexes. It checks if all indexes are valid
	 * before deleting.
	 */
	private static String deleteMultiple(ArrayList<Integer> listToDelete) throws Exception {
		boolean isIndexValid = true;
		int indexToDelete = INVALID_INDEX;
		logger.log(Level.INFO, "list contains more than one task to delete");
		ArrayList<Task> tasksToDelete = new ArrayList<Task>();
		
		for (int i = 0; i < listToDelete.size(); i++) {
			indexToDelete = listToDelete.get(i);
			isIndexValid = canRetrieveIndex(indexToDelete);
			
			if (isIndexValid == false) {
				logger.log(Level.WARNING, "one of the indexes given is invalid");
				return ERROR_INVALID_INDEX_MULTIPLE;
			} else {
				tasksToDelete.add(taskList.get(indexToDelete - 1));
			}
		}
		logger.log(Level.INFO, "all indexes valid, interacting with storage now");
		return storageObj.deleteMultipleTasks(tasksToDelete);
	}
	
	
	/*
	 * This method is responsible for executing the view command. It returns a String containing
	 * either all pending tasks, overdue tasks or completed task, to the UI.
	 */
	private static String executeViewCommand(Handler commandHandler) throws Exception {
		if (commandHandler.getHasError() == true) {
			logger.log(Level.WARNING, "handler has reported an error in view");
			return commandHandler.getFeedBack();

		} else {
			logger.log(Level.INFO, "before executing view command");
			String keyWord = commandHandler.getKeyWord();
			assert keyWord != null;
			taskList = storageObj.viewTasks(keyWord);
			return convertListToString(taskList);
		}
	}


	/*
	 * This method is responsible for the execution of the Edit command. It reports on the success of
	 * the command to the UI. 
	 */
	private static String executeEditCommand(Handler commandHandler) throws Exception {
		if (commandHandler.getHasError() == true) {
			logger.log(Level.WARNING, "handler has reported an error in edit");
			return commandHandler.getFeedBack();

		} else { 
			// only one task can be edited at a time, hence check the index of the first task
			ArrayList<Integer> listToEdit = commandHandler.getIndexList();
			int indexToEdit = listToEdit.get(FIRST_ELEMENT_INDEX);
			boolean isIndexValid = canRetrieveIndex(indexToEdit);

			if (isIndexValid == false) {
				logger.log(Level.WARNING, "index given is invalid");
				return ERROR_INVALID_INDEX;

			} else {
				logger.log(Level.INFO, "index valid, editing now");
				Task fieldsToChange = commandHandler.getTask();
				Task originalTask = taskList.get(indexToEdit - 1);
				String dateErrorMessage = hasDateError(fieldsToChange, originalTask);

				if (dateErrorMessage.equals(STRING_EMPTY)) {
					logger.log(Level.INFO, "date field is valid, interacting with storage now");
					return storageObj.editTask(originalTask, fieldsToChange);

				} else {
					logger.log(Level.WARNING, "invalid date field");
					return dateErrorMessage;

				}
			}
		}
	}

	
	/*
	 * This method executes the search command which allows the user to search for tasks
	 * based on a given date or an description. It returns a shortlist of tasks containing the specified
	 * keyword/date to the UI and this will then be shown to the user.
	 */
	private static String executeSearchCommand(Handler commandHandler) throws Exception {			
		if (commandHandler.getHasError() == true) {
			logger.log(Level.WARNING, "handler has reported an error in search");
			return commandHandler.getFeedBack();
		}

		if (commandHandler.getHasEndDate() == true) {
			Date endDate = commandHandler.getTask().getEndTime();
			taskList = storageObj.searchTasksByDate(endDate);

			if (taskList.size() == EMPTY_LIST_SIZE) {
				logger.log(Level.INFO, "There are no tasks containing the date");
				return MESSAGE_NO_TASKS_FOUND;
			} else {
				logger.log(Level.INFO, "tasks have been retrieved, converting into a string now");
				return convertListToString(taskList);
			}
		} else {

			String keyword = commandHandler.getKeyWord();
			taskList = storageObj.searchTasks(keyword);

			if (taskList.size() == EMPTY_LIST_SIZE) {
				logger.log(Level.INFO, "There are no tasks containing the keyword");
				return MESSAGE_NO_TASKS_FOUND;
			} else {
				logger.log(Level.INFO, "tasks have been retrieved, converting into a string now");
				return convertListToString(taskList);
			}
		}
	}

	
	/*
	 * This method executes the undo command, which allows the user to undo their most
	 * recent command.
	 */
	private static String executeUndoCommand(Handler commandHandler) throws Exception {
		boolean isPreviousCommandValid = hasPreviousCommand();

		if (isPreviousCommandValid == false) {				
			logger.log(Level.WARNING, "nothing to undo");
			return ERROR_PREVIOUS_COMMAND_INVALID;
 
		} else {	
			if (previousCommandString.equals("undo")) {
				logger.log(Level.WARNING, "double undo");
				return ERROR_DOUBLE_UNDO;
			} else {
				logger.log(Level.INFO, "there is a previous command and it is not undo, undoing now");
				storageObj.restore(lastModifyCommand);
				String feedback = DOUBLE_QUOTATION + lastModifyCommand + DOUBLE_QUOTATION + MESSAGE_UNDO_SUCCESSFUL;
				return feedback;
			}
		}
	}
	
	
	/*
	 * This method allows the user to redo an action that has recently been undone.
	 */
	private static String executeRedoCommand(Handler commandHandler) throws Exception {
		boolean isPreviousCommandValid = hasPreviousCommand();

		if (isPreviousCommandValid == false) {				
			logger.log(Level.WARNING, "no previous command to redo");
			return ERROR_PREVIOUS_COMMAND_INVALID_REDO;

		} else {
			if (previousCommandString.equals("redo")) {
				logger.log(Level.WARNING, "double redo");
				return ERROR_DOUBLE_REDO;
			} else {
				logger.log(Level.INFO, "previous command is valid, redoing now");
				logger.log(Level.INFO, "there is a previous command and it is not redo, undoing now");
				storageObj.restore(lastModifyCommand);
				String feedback = DOUBLE_QUOTATION + lastModifyCommand + DOUBLE_QUOTATION + MESSAGE_REDO_SUCCESSFUL;
				return feedback;
			}
		}
	}	
		
	
	/*
	 * This method allows the user to set the storage location so that SimplyAmazing would be able
	 * to save the user's data into the specified location
	 */
	private static String executeSetLocationCommand(Handler commandHandler) throws Exception {
		if (commandHandler.getHasError() == true) {			
			logger.log(Level.WARNING, "handler has reported an error in location");
			return commandHandler.getFeedBack();

		} else {			
			String directoryPath = commandHandler.getKeyWord();
			assert directoryPath != null;
			String feedback = STRING_EMPTY;

			try {
				logger.log(Level.INFO, "setting the location");
				feedback = storageObj.setLocation(directoryPath);
			} catch (Exception e) {
				logger.log(Level.WARNING, "storage has reported an error in location");
				feedback = ERROR_INVALID_DIRECTORY;
			}
			return feedback;
		}
	}


	/*
	 * This method allows the mark command to be executed so that a user would be able to
	 * mark a task as completed.
	 */
	private static String executeMarkCommand(Handler commandHandler) throws Exception {
		if (commandHandler.getHasError() == true) {
			logger.log(Level.WARNING, "handler has reported an error in mark");
			return commandHandler.getFeedBack();

		} else {

			ArrayList<Integer> listToMark = commandHandler.getIndexList();
			boolean isIndexValid = true;
			int indexToMark = INVALID_INDEX;

			if (listToMark.size() == ONE_ELEMENT_IN_LIST) {
				logger.log(Level.INFO, "only one task to mark as done");
				indexToMark = listToMark.get(FIRST_ELEMENT_INDEX);

				isIndexValid = canRetrieveIndex(indexToMark);
				if (isIndexValid == false) {
					logger.log(Level.WARNING, "index given is invalid");
					return ERROR_INVALID_INDEX;
				}
				
				logger.log(Level.INFO, "index valid, interacting with storage now");
				Task taskToMark = taskList.get(indexToMark - 1);
				return storageObj.markTaskDone(taskToMark);
				
			} else {
				logger.log(Level.INFO, "more than one task to mark as done");
				return markMultiple(listToMark);
			}
		}
	}
	
	
	/*
	 * This method facilitates marking multiple indexes as done. It checks if all indexes are valid
	 * before marking them.
	 */
	private static String markMultiple(ArrayList<Integer> listToMark) throws Exception {
		boolean isIndexValid = true;
		int indexToMark = INVALID_INDEX;
		ArrayList<Task> tasksToMark = new ArrayList<Task>();

		for (int i = 0; i < listToMark.size(); i++) {
			indexToMark = listToMark.get(i);
			isIndexValid = canRetrieveIndex(indexToMark);
			
			if (isIndexValid == false) {
				logger.log(Level.WARNING, "one of the indexes given is invalid");
				return ERROR_INVALID_INDEX_MULTIPLE;
			} else {
				tasksToMark.add(taskList.get(indexToMark - 1 ));
			}
		}
		logger.log(Level.INFO, "indexes valid, interacting with storage now");
		return storageObj.markMultipleTasksDone(tasksToMark);
	}

	
	/*
	 * This method allows the unmark command to be executed so that the user would be able
	 * to unmark a completed task. Before this command can be successfully executed the user
	 * will have to execute the "view done" command.
	 */
	private static String executeUnmarkCommand(Handler commandHandler) throws Exception {
		if (commandHandler.getHasError() == true) {
			logger.log(Level.WARNING, "handler has reported an error in unmark");
			return commandHandler.getFeedBack();	
		}

		ArrayList<Integer> listToUnmark = commandHandler.getIndexList();
		boolean isIndexValid = true;
		int indexToUnmark = INVALID_INDEX;

		if (listToUnmark.size() == ONE_ELEMENT_IN_LIST) {
			logger.log(Level.INFO, "only 1 index to unmark");
			indexToUnmark = listToUnmark.get(FIRST_ELEMENT_INDEX);

			isIndexValid = canRetrieveIndex(indexToUnmark);
			if (isIndexValid == false) {
				logger.log(Level.WARNING, "index given is invalid");
				return ERROR_INVALID_INDEX;
			}
			logger.log(Level.INFO, "index valid, unmarking now");
			Task taskToUnmark = taskList.get(indexToUnmark - 1);
			return storageObj.markTaskUndone(taskToUnmark);

		} else {
			logger.log(Level.INFO, "more than 1 index to unmark");
			return unmarkMultiple(listToUnmark);
		}
	}

	
	/*
	 * This method facilitates unmarking multiple indexes. It checks if all indexes are valid
	 * before unmarking them.
	 */
	private static String unmarkMultiple(ArrayList<Integer> listToUnmark) throws Exception {
		boolean isIndexValid = true;
		int indexToUnmark = INVALID_INDEX;
		ArrayList<Task> tasksToUnmark = new ArrayList<Task>();

		for (int i = 0; i < listToUnmark.size(); i++) {
			indexToUnmark = listToUnmark.get(i);
			isIndexValid = canRetrieveIndex(indexToUnmark);
			
			if (isIndexValid == false) {
				logger.log(Level.WARNING, "one of the indexes given is invalid");
				return ERROR_INVALID_INDEX_MULTIPLE;
			} else {
				tasksToUnmark.add(taskList.get(indexToUnmark - 1 ));
			}
		}
		logger.log(Level.INFO, "indexes valid, interacting with storage to unmark");
		return storageObj.markMultipleTasksUndone(tasksToUnmark);
	}

	
	/*
	 * This method allows the help command to be executed. It returns the required
	 * help message to the UI.
	 */
	private static String executeHelpCommand(Handler commandHandler) throws Exception {
		if (commandHandler.getHasError() == true) {
			logger.log(Level.WARNING, "handler has reported an error in help");
			return commandHandler.getFeedBack();

		} else {
			logger.log(Level.INFO, "no error, help keyword is valid.");
			
			if(commandHandler.getKeyWord().equals(STRING_EMPTY)) {
				return MESSAGE_HELP;
			} else if (commandHandler.getKeyWord().equals("add")) {
				return MESSAGE_HELP_ADD_TASK;
			} else if (commandHandler.getKeyWord().equals("delete")) {
				return MESSAGE_HELP_DELETE;
			} else if (commandHandler.getKeyWord().equals("view")) {
				return MESSAGE_HELP_VIEW;
			} else if (commandHandler.getKeyWord().equals("search")) {
				return MESSAGE_HELP_SEARCH;
			} else if (commandHandler.getKeyWord().equals("edit")) {
				return MESSAGE_HELP_EDIT;
			} else if (commandHandler.getKeyWord().equals("exit")) {
				return MESSAGE_HELP_EXIT;
			} else if (commandHandler.getKeyWord().equals("location")) {
				return MESSAGE_HELP_LOCATION;
			} else if (commandHandler.getKeyWord().equals("undo")) {
				return MESSAGE_HELP_UNDO;
			} else if (commandHandler.getKeyWord().equals("redo")) {
				return MESSAGE_HELP_REDO;
			} else if (commandHandler.getKeyWord().equals("unmark")) {
				return MESSAGE_HELP_UNMARK;
			} else {
				return MESSAGE_HELP_MARK;
			}
		}
	}

	
	/*
	 * This method checks if a command has modified the list of tasks. This
	 * ensures that the undo and redo commands function correctly by undoing or 
	 * redoing only commands which have modified the list of tasks.
	 */
	private static boolean hasListBeenModified(CommandType commandType) {
		assert commandType != null;
		
		if (commandType.equals(CommandType.ADD_TASK)) {
			return true;
		} else if (commandType.equals(CommandType.DELETE_TASK)) {
			return true;
		} else if (commandType.equals(CommandType.EDIT_TASK)) {
			return true;
		} else if (commandType.equals(CommandType.MARK_TASK)) {
			return true;
		} else if (commandType.equals(CommandType.UNMARK_TASK)) {
			return true;
		} else {
			return false;
		}
	}

	
	/*
	 * This method checks to see if an index given by the user is valid or invalid.
	 * This ensures that the program is able to detect if the user has given an invalid
	 * index and would allow the program to act accordingly
	 */
	private static boolean canRetrieveIndex(int index) {
		if (index <= EMPTY_LIST_SIZE || index > taskList.size()) {
			return false;
		} else {
			return true;
		}
	}

	
	/*
	 * This method checks if the edited date/dates specified by the user is/are valid
	 * or invalid. If invalid then an error message will be created.
	 */
	private static String hasDateError(Task fieldsToChange, Task originalTask) throws Exception {
		Date newStartTime = fieldsToChange.getStartTime();
		Date newEndTime = fieldsToChange.getEndTime();
		Date previousStartTime = originalTask.getStartTime();
		Date previousEndTime = originalTask.getEndTime();
		
		// if both start time and end time are not modified
		if (!(newStartTime.compareTo(Task.DEFAULT_DATE_VALUE) != 0 && newEndTime.compareTo(Task.DEFAULT_DATE_VALUE) != 0)) { 
			// start time is modified
			if (newStartTime.compareTo(Task.DEFAULT_DATE_VALUE) != 0) {
				// no end time => it's a floating task 
				if (newStartTime.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) !=0 && previousEndTime.compareTo(Task.DEFAULT_DATE_VALUE) == 0) { 
					return ERROR_NO_END_TIME;

				} else { // it's a deadline
					if (newStartTime.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) !=0 && newStartTime.after(previousEndTime)) {
						return ERROR_START_AFTER_END;
					}
					if (newStartTime.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) !=0 && newStartTime.equals(previousEndTime)) {
						return ERROR_START_SAME_AS_END;

					}
				}
			} else if (newEndTime.compareTo(Task.DEFAULT_DATE_VALUE) != 0) { // end time is modified
				// has start time => it's an event
				if (previousStartTime.compareTo(Task.DEFAULT_DATE_VALUE) != 0) { 
					if (newEndTime.compareTo(Task.DEFAULT_DATE_VALUE_FOR_NULL) == 0) {
						return ERROR_INVALID_END_TIME;
					} else {
						if (newEndTime.before(previousStartTime)) {
							return ERROR_END_BEFORE_START;
						}
						if (newEndTime.equals(previousStartTime)) {
							return ERROR_END_SAME_AS_START;
						}
					}
				}
			} 
		}
		return STRING_EMPTY;
	}

	
	private static boolean hasPreviousCommand() {
		if (lastModifyCommand.equals(STRING_EMPTY)) {
			return false;

		} else {
			return true;
		}
	}
	
	
	/*
	 * This method returns the previous command to the UI so that it can be made available for the user
	 */
	public String getPreviousCommand() {
		return previousCommandString;
	}
	
	
	/*
	 * This method returns the a String containing all the tasks in the list so that the 
	 * UI is able to display them to the user
	 */
	public static String getView() throws Exception {
		taskList = storageObj.viewTasks(STRING_EMPTY);
		return convertListToString(taskList);
	}

	
	/*
	 * This method receives a list of tasks and converts it to a String, which can then
	 * be used by the UI to display to the user
	 */
	private static String convertListToString(ArrayList<Task> listToConvert) {
		assert listToConvert != null;
		if (listToConvert.size() == EMPTY_LIST_SIZE) {
			return MESSAGE_EMPTY_LIST;
		}
		String convertedList = STRING_EMPTY;

		for (int i = 0; i < listToConvert.size(); i++) {
			Task taskToPrint = listToConvert.get(i);
			convertedList += (i + 1) + "," + taskToPrint.toString() + "\n";
		}
		return convertedList;
	}
}
```
###### test\LogicTest.java
``` java
package test;

import static org.junit.Assert.*;

import java.io.File;
import org.junit.Test;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.FixMethodOrder;
import org.junit.runners.MethodSorters;
import simplyamazing.logic.Logic;
import simplyamazing.storage.Storage;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class LogicTest { 
	
	private static Logic logicObj;
	private static Storage storageObj;
	
	private static final String COMMAND_SET_LOCATION_DIRECTORY = "location C:\\Users\\Public\\SimplyAmazing";
	private static final String FILENAME_TODO = "\\todo.txt";
	private static final String FILENAME_DONE = "\\done.txt";
	private static final String FILENAME_TODO_BACKUP = "\\todoBackup.txt";
	private static final String FILENAME_DONE_BACKUP = "\\doneBackup.txt";
	private static final String PARAM_SET_LOCATION_DIRECTORY = "C:\\Users\\Public\\SimplyAmazing";
	
	
	private static final String UNDO_NOTHING_FEEDBACK = "Error: There is no previous command to undo";
	private static final String REDO_NOTHING_FEEDBACK = "Error: There is no previous command to redo";
	private static final String ADD_INVALID_FEEDBACK = "Error: Please ensure the fields are correct";
	private static final String ADD_INVALID = "add ";
	private static final String UNRECOGNIZED_COMMAND = "hello";
	private static final String UNRECOGNIZED_COMMAND_STRING_EMPTY = "";
	private static final String UNRECOGNIZED_COMMAND_FEEDBACK = "Error: Invalid command entered. Please enter \"help\""
			+ " to view all commands and their format";
	
		
	private static final String LOCATION_EMPTY_STRING = "location ";
	private static final String LOCATION_EMPTY_STRING_FEEDBACK = "Error: Location provided is invalid";
	private static final String LOCATION_COMMAND_FAIL = "location just a placeholder";
	private static final String LOCATION_COMMAND_PASS = "location C:\\Users\\Public\\SimplyAmazing";
	private static final String LOCATION_FEEDBACK_FAIL = "Error: Not a valid directory";
	private static final String LOCATION_FEEDBACK_PASS = "Storage location of task data has been sucessfully set as"
			+ " C:\\Users\\Public\\SimplyAmazing.";
	
	
	private static final String ADD_TASK_PASS = "add hello world";
	private static final String ADD_TASK_PASS_FEEDBACK = "Task [hello world] has been added.";
	private static final String ADD_DEADLINE_PASS = "add cs2103 peer review by 23:59 25 May 2016";
	private static final String ADD_DEADLINE_PASS_FEEDBACK = "Task [cs2103 peer review by 23:59 25 May 2016] has been added.";
	private static final String ADD_EVENT_PASS = "add hackathon in SOC from 09:30 26 May 2016 to 10:00 27 May 2016";
	private static final String ADD_EVENT_PASS_FEEDBACK = "Task [hackathon in SOC from 09:30 26 May 2016 to 10:00 27 May 2016] has been added.";
	private static final String ADD_TASK_WITH_STARTIME_ONLY = "add sleep from 03:00 24 May 2016";
	private static final String ADD_ERROR_MESSAGE = "Error: Please ensure the fields are correct";
	private static final String ADD_TASK_ENDTIME_BEFORE_STARTIME = "add play fifa from 14:00 30 May 2016 to 13:00 30 May 2016";
	private static final String ADD_TASK_ENDTIME_BEFORE_STARTIME_FEEDBACK = "Error: Start date and time cannot be after the End date and time";
	private static final String ADD_END_BEFORE_CURRENT = "add visit the dentist by 22:00 2 Apr 2016";
	private static final String ADD_START_BEFORE_CURRENT = "add visit the dentist from 22:00 2 Apr 2016 to 23:00 2 Apr 2016";
	private static final String ADD_BEFORE_CURRENT_FEEDBACK = "Error: Time provided must be after the current time";
	
	
	private static final String VIEW_INVALID = "view nothing";
	private static final String VIEW_EMPTY_LIST = "List is empty";
	private static final String VIEW_DONE = "view done";
	private static final String VIEW_OVERDUE = "view overdue";
	private static final String VIEW_VALID = "view";
	private static final String VIEW_INVALID_FEEDBACK = "Error: Please input a valid keyword. Use the \"help view\" command"
			+ " to see all the valid keywords" ;
	private static final String VIEW_VALID_FEEDBACK = "1,cs2103 peer review, ,23:59 25 May 2016, ,incomplete\n"
			+ "2,hackathon in SOC,09:30 26 May 2016,10:00 27 May 2016, ,incomplete\n"
			+ "3,hello world, , , ,incomplete\n";
	
	
	private static final String DELETE_INVALID_INDEX_LARGER = "delete 5";
	private static final String DELETE_INVALID_INDEX_FEEDBACK = "Error: The Index entered is invalid";
	private static final String DELETE_INVALID_INDEX_ZERO = "delete 0";
	private static final String DELETE_INVALID_INDEX_NEGATIVE = "delete -1";
	private static final String DELETE_STRING = "delete hello";
	private static final String DELETE_STRING_FEEDBACK = "Error: Index provided is not an Integer.";
	private static final String DELETE_VALID_MULTIPLE = "delete 1 2";
	private static final String DELETE_VALID_MULTIPLE_FEEDBACK = "Provided tasks have been successfully deleted.";
	private static final String DELETE_INVALID_MULTIPLE = "delete 1 2 5";
	private static final String DELETE_INVALID_MULTIPLE_FEEDBACK = "Error: One of the given indexes is invalid";
	private static final String DELETE_VALID_INDEX = "delete 2";
	private static final String DELETE_VALID_INDEX_FEEDBACK = "Task [hackathon in SOC from 09:30 26 May 2016 to 10:00 27 May 2016]"
			+ " has been successfully deleted.";
	
	
	private static final String EDIT_INDEX_INVALID_FEEDBACK = "Error: The Index entered is invalid";
	private static final String EDIT_INDEX_LARGER = "edit 10 priority high";
	private static final String EDIT_INDEX_NEGATIVE = "edit -1 priority high";
	private static final String EDIT_INDEX_ZERO = "edit 0 priority high";
	private static final String EDIT_INDEX_STRING = "edit abc priority high";
	private static final String EDIT_INDEX_STRING_FEEDBACK = "Error: Index provided is not an Integer.";
	private static final String EDIT_INVALID_FIELD = "edit 1 anyfield anyvalue";
	private static final String EDIT_INVALID_FIELD_FEEDBACK = "Error: Please input a valid field. Use the \"help edit\""
			+ " command to see all the valid fields";
	
	private static final String EDIT_TIME_BEFORE_CURRENT_FEEDBACK = "Error: Time provided must be after the current time";
	private static final String EDIT_START_BEFORE_CURRENT = "edit 1 start 22:00 2 apr 2016";
	private static final String EDIT_END_BEFORE_CURRENT = "edit 1 end 22:00 2 apr 2016";
	private static final String EDIT_START_AFTER_END = "edit 1 start 00:00 26 may 2016";
	private static final String EDIT_START_AFTER_END_FEEDBACK = "Error: New start time cannot be after the end time";
	private static final String EDIT_START_EQUALS_END = "edit 1 start 23:59 25 may 2016";
	private static final String EDIT_START_EQUALS_END_FEEDBACK = "Error: New start time cannot be the same as the end time";
	private static final String EDIT_START_NO_END= "edit 3 start 17:00 20 may 2016";
	private static final String EDIT_START_NO_END_FEEDBACK= "Error: Unable to allocate a start time when the task has no end time";
	
	private static final String EDIT_END_BEFORE_START = "edit 2 end 09:00 26 may 2016";
	private static final String EDIT_END_BEFORE_START_FEEDBACK = "Error: New end time cannot be before the start time";
	private static final String EDIT_END_EQUALS_START = "edit 2 end 09:30 26 may 2016";
	private static final String EDIT_END_EQUALS_START_FEEDBACK = "Error: New end time cannot be the same as the start time";
	
	private static final String EDIT_EVENT_START_AFTER_END= "edit 3 start 11:00 20 may 2016, end 10:00 20 may 2016";
	private static final String EDIT_EVENT_START_EQUAL_END= "edit 3 start 11:00 20 may 2016, end 11:00 20 may 2016";
	private static final String EDIT_EVENT_START_BEFORE_CURRENT = "edit 3 start 12:00 3 apr 2016, end 10:00 20 may 2016";
	private static final String EDIT_EVENT_START_AFTER_END_FEEDBACK= "Error: Start date and time cannot be after the End date and time";
	
	private static final String EDIT_VALID = "edit 3 description hello world";
	private static final String EDIT_VALID_FEEDBACK = "Task [hello world] has been successfully updated.";
	
	private static final String EDIT_PRIORITY_INVALID = "edit 1 priority nothing"; 
	private static final String EDIT_PRIORITY_INVALID_FEEDBACK = "Error: Priority level can be only high, medium, low or none.";
	private static final String EDIT_PRIORITY_HIGH = "edit 1 priority high"; 
	private static final String EDIT_PRIORITY_MEDIUM =  "edit 1 priority medium";
	private static final String EDIT_PRIORITY_LOW = "edit 1 priority low"; 
	private static final String EDIT_PRIORITY_NONE = "edit 1 priority none";
	private static final String EDIT_PRIORITY_NONE_FEEDBACK = "Task [cs2103 peer review by 23:59 25 May 2016] has been successfully updated.";
	private static final String EDIT_PRIORITY_HIGH_FEEDBACK = "Task [cs2103 peer review by 23:59 25 May 2016 with high priority] "
			+ "has been successfully updated.";
	private static final String EDIT_PRIORITY_LOW_FEEDBACK = "Task [cs2103 peer review by 23:59 25 May 2016 with low priority]"
			+ " has been successfully updated.";
	private static final String EDIT_PRIORITY_MEDIUM_FEEDBACK = "Task [cs2103 peer review by 23:59 25 May 2016 with medium priority]"
			+ " has been successfully updated.";
	
	private static final String MARK_INVALID_INDEX_NEGATIVE = "done -1";
	private static final String MARK_INVALID_INDEX_ZERO = "done 0";
	private static final String MARK_INVALID_INDEX_LARGER = "done 30";
	private static final String MARK_INVALID_INDEX_FEEDBACK = "Error: The Index entered is invalid";
	private static final String MARK_INVALID_INDEX_STRING = "done abcd";
	private static final String MARK_INVALID_COMMAND_FEEDBACK = "Error: Index provided is not an Integer.";
	private static final String MARK_INVALID_INDEX_MULTIPLE = "done 1 2 -1";
	private static final String MARK_INVALID_INDEX_MULTIPLE_FEEDBACK = "Error: One of the given indexes is invalid";
	private static final String MARK_VALID_INDEX_MULTIPLE = "done 1 2";
	private static final String MARK_VALID_INDEX_MULTIPLE_FEEDBACK = "Provided tasks have been marked as done.";
	private static final String MARK_VALID_INDEX  = "done 2";
	private static final String MARK_VALID_FEEDBACK = "Task [hello world] has been marked as done.";
	
	
	private static final String UNMARK_INVALID_INDEX_FEEDBACK = "Error: The Index entered is invalid";
	private static final String UNMARK_INVALID_INDEX_NEGATIVE = "unmark -1";
	private static final String UNMARK_INVALID_INDEX_ZERO = "unmark 0";
	private static final String UNMARK_INVALID_INDEX_LARGER = "unmark 3";
	private static final String UNMARK_INVALID_INDEX_STRING = "unmark abc";
	private static final String UNMARK_INVALID_COMMAND_FEEDBACK = "Error: Index provided is not an Integer.";
	private static final String UNMARK_INVALID_MULTIPLE = "unmark 1 2 3";
	private static final String UNMARK_INVALID_MULTIPLE_FEEDBACK = "Error: One of the given indexes is invalid";
	private static final String UNMARK_VALID_MULTIPLE = "unmark 1 2";
	private static final String UNMARK_VALID_MULTIPLE_FEEDBACK = "Provided tasks have been marked as incomplete.";
	private static final String UNMARK_VALID = "unmark 2";
	private static final String UNMARK_VALID_FEEDBACK = "Task [hello world] has been marked as incomplete.";
	
	
	private static final String SEARCH_VALID_KEYWORD = "search hello";
	private static final String SEARCH_VALID_FEEDBACK = "1,hello world, , , ,incomplete\n";
	private static final String SEARCH_INVALID_KEYWORD = "search joke";
	private static final String SEARCH_NOT_FOUND_FEEDBACK = "There are no tasks containing the given keyword";
	private static final String SEARCH_WRONG_DATE = "search 19:00 25 Dec 2016";
	private static final String SEARCH_VALID_DATE = "search 25 May 2016";
	private static final String SEARCH_VALID_DATE_FEEDBACK = "1,cs2103 peer review, ,23:59 25 May 2016, ,incomplete\n"
			+ "2,hello world, , , ,incomplete\n";
	private static final String SEARCH_EMPTY_STRING = "search ";
	private static final String SEARCH_EMPTY_STRING_FEEDBACK = "1,cs2103 peer review, ,23:59 25 May 2016, ,incomplete\n"
			+ "2,hackathon in SOC,09:30 26 May 2016,10:00 27 May 2016, ,incomplete\n3,hello world, , , ,incomplete\n";
	private static final String SEARCH_INVALID_DATE = "search 15:00 29 feb 2017";
	private static final String SEARCH_INVALID_DATE_FEEDBACK = "Error: Please ensure the time format is valid. "
			+ "Please use the \"help\"command to view the format";
	
	
	private static final String UNDO = "undo";
	private static final String UNDO_FEEDBACK = "\"unmark 2\" command has been successfully undone.";
	private static final String UNDO_DOUBLE_FEEDBACK = "Error: Unable to undo an undo command. Use the redo command instead";
	
	private static final String REDO = "redo";
	private static final String REDO_FEEDBACK = "\"unmark 2\" command has been successfully executed again.";
	private static final String REDO_DOUBLE_FEEDBACK= "Error: Unable to redo a redo command. Use the undo command instead";
	
	private static final String HELP_INVALID = "help 1";
	private static final String HELP_INVALID_FEEDBACK = "Error: Please input a valid keyword. Use the \"help\""
			+ " command to view all valid keywords";
	
	private static final String HELP_VALID = "help";
	private static final String HELP_VALID_FEEDBACK = "Key in the following to view specific command formats:\n"
			+ "1. help add\n2. help delete\n3. help edit\n4. help view\n5. help search \n6. help mark\n"
			+ "7. help unmark\n8. help undo\n9. help redo\n10. help location \n11. help exit\n";

	private static final String HELP_VALID_UNDO = "help undo";
	private static final String HELP_VALID_UNDO_FEEDBACK = "Undo the most recent command\nCommand: undo\n";
	
	private static final String HELP_VALID_REDO = "help redo";
	private static final String HELP_VALID_REDO_FEEDBACK = "Redo the most recent command\nCommand: redo\n";
	
	private static final String HELP_VALID_UNMARK = "help unmark";
	private static final String HELP_VALID_UNMARK_FEEDBACK =  "Unmarks a completed task\nCommand: undone <task index>\n\n"
			+ "Example:\nundone 2\n\n\nNote: You may also use the keyword \"unmark\" instead of \"undone\"";
	
	private static final String HELP_VALID_MARK = "help mark";
	private static final String HELP_VALID_MARK_FEEDBACK = "Marks task as completed\nCommand: done <task index>\n\n"
			+ "Example:\ndone 2\n\n\n"
			+ "Note: You may also use the keywords \"mark\", \"complete\" or \"finish\" instead of \"done\"";
	
	private static final String HELP_VALID_DELETE = "help delete";
	private static final String HELP_VALID_DELETE_FEEDBACK = "Delete task from list\nCommand: delete <task index>\n\n"
			+ "Example:\ndelete 1\n\n\n"
			+ "Note: You may also use the keywords \"-\", \"del\", \"remove\" or \"cancel\" instead of \"delete\"";
			
	private static final String HELP_VALID_SEARCH = "help search";
	private static final String HELP_VALID_SEARCH_FEEDBACK = "Search for tasks containing the given keyword or date \n"
			+ "Command: search <keyword> or search<date>\n\nExample:\nsearch meeting\n\n\n"
			+ "Note: You may also use the keyword \"find\" instead of \"search\"";
	
	private static final String HELP_VALID_EXIT = "help exit";
	private static final String HELP_VALID_EXIT_FEEDBACK = "Exits SimplyAmazing\nCommand: exit\n\n\nNote: You may also use "
			+ "\"logout\" or \"quit\" instead of \"exit\"";
	
	private static final String HELP_VALID_VIEW = "help view";
	private static final String HELP_VALID_VIEW_FEEDBACK = "1.Display all tasks\n Command: view\n\n"
			+ "2.Display tasks with deadlines\nCommand: view deadlines\n\n"
			+ "3.Display all events\nCommand: view events\n\n"
			+ "4.Display tasks without deadlines\nCommand: view tasks\n\n"
			+ "5.Display completed tasks\nCommand: view done\n\n"
			+ "6.Display overdue tasks\nCommand: view overdue\n\n\n"
			+ "Note: You may also use the keywords \"display\", \"show\" or \"list\" instead of \"view\"";
	
	private static final String HELP_VALID_EDIT = "help edit";
	private static final String HELP_VALID_EDIT_FEEDBACK = "Edit content in a task\nCommand: edit <task index> <task header> "
			+ "<updated content>\n\n"
			+ "Example:\n1. edit 4 description send marketing report\n\n2. edit 3 start 22:00 26 may 2016,"
			+ " end 22:40 26 may 2016\n\n3. edit 1 priority high\n\n\n"
			+ "Note: You may also use the keywords \"change\" or \"update\" instead of \"edit\"";
	
	private static final String HELP_VALID_ADD = "help add";
	private static final String HELP_VALID_ADD_FEEDBACK =  "1.Add a task to the list\nCommand: add <task description>\n\n"
			+ "Example: add Prepare presentation\n\n\n2.Add an event to the list\n"
			+ "command: add <task description> from <start time hh:mm> <start date dd MMM yyyy> to\n<end time hh:mm> "
			+ "<end date dd MMM yyyy>\n\n"
			+ "Example: add Company annual dinner from 19:00 29 Dec 2016 to 22:00 29 dec 2016\n\n\n"
			+ "3.Add a deadline to the list\ncommand: add <task description> by <end time hh:mm> <end date dd MMM yyyy>\n\n"
			+ "Example: add Submit marketing report by 17:00 20 Dec 2016\n\n\n"
			+ "Note: You may use the keyword \"+\" instead of \"add\"";
	
	private static final String HELP_VALID_LOCATION = "help location";
	private static final String HELP_VALID_LOCATION_FEEDBACK = "Sets the storage location or folder for application data\n"
			+ "Command: location <path>\n" + "\n"
			+ "Example:\nlocation C:\\Users\\Jim\\Desktop\\Task Data\n\n\n"
			+ "Note: You may also use the keywords \"path\" or \"address\" instead of \"location\"";
	
	
	
	@BeforeClass
	public static void setUpClass() throws Exception{
		logicObj = new Logic();
		storageObj = new Storage();
		logicObj.executeCommand(COMMAND_SET_LOCATION_DIRECTORY);
		
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		File todoBackup = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO_BACKUP);
		File doneBackup = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE_BACKUP);
		storageObj.getFileManager().cleanFile(todo);
		storageObj.getFileManager().cleanFile(done);
		storageObj.getFileManager().cleanFile(todoBackup);
		storageObj.getFileManager().cleanFile(doneBackup);
	}
	
	
	@Test
	public void test1ValidCommandTypes() throws Exception{
		assertEquals(UNDO_NOTHING_FEEDBACK, logicObj.executeCommand(UNDO));  
		assertEquals(REDO_NOTHING_FEEDBACK, logicObj.executeCommand(REDO));
		assertEquals(ADD_INVALID_FEEDBACK,logicObj.executeCommand(ADD_INVALID));
		assertEquals(UNRECOGNIZED_COMMAND_FEEDBACK, logicObj.executeCommand(UNRECOGNIZED_COMMAND));
		assertEquals(UNRECOGNIZED_COMMAND_FEEDBACK, logicObj.executeCommand(UNRECOGNIZED_COMMAND_STRING_EMPTY));
		
	}
	
	

	/*
	 * The following test has 2 equivalent partitions, valid and invalid commands.
	 */
	@Test
	public void test2AddCommand() throws Exception{
		// valid partition
		assertEquals(ADD_TASK_PASS_FEEDBACK, logicObj.executeCommand(ADD_TASK_PASS));
		assertEquals(ADD_DEADLINE_PASS_FEEDBACK, logicObj.executeCommand(ADD_DEADLINE_PASS));
		assertEquals(ADD_EVENT_PASS_FEEDBACK, logicObj.executeCommand(ADD_EVENT_PASS));		
		// invalid partition
		assertEquals(ADD_ERROR_MESSAGE, logicObj.executeCommand(ADD_TASK_WITH_STARTIME_ONLY));
		assertEquals(ADD_TASK_ENDTIME_BEFORE_STARTIME_FEEDBACK, logicObj.executeCommand(ADD_TASK_ENDTIME_BEFORE_STARTIME));
		assertEquals(ADD_BEFORE_CURRENT_FEEDBACK, logicObj.executeCommand(ADD_END_BEFORE_CURRENT));
		assertEquals(ADD_BEFORE_CURRENT_FEEDBACK, logicObj.executeCommand(ADD_START_BEFORE_CURRENT));
	}
	
	

	/*
	 * The following test has 2 partitions, valid and invalid, based on the validity of the command
	 */
	@Test
	public void test3ViewCommand() throws Exception{
		// invalid partition
		assertEquals(VIEW_INVALID_FEEDBACK, logicObj.executeCommand(VIEW_INVALID));
		// valid partition
		assertEquals(VIEW_EMPTY_LIST, logicObj.executeCommand(VIEW_DONE));
		assertEquals(VIEW_EMPTY_LIST, logicObj.executeCommand(VIEW_OVERDUE));
		assertEquals(VIEW_VALID_FEEDBACK,logicObj.executeCommand(VIEW_VALID));
		
	}	
	
	
	@Test 
	public void test4EditCommand() throws Exception{
		logicObj.executeCommand(VIEW_VALID);
		
		// test indexes first
		assertEquals(EDIT_INDEX_INVALID_FEEDBACK, logicObj.executeCommand(EDIT_INDEX_LARGER));
		assertEquals(EDIT_INDEX_INVALID_FEEDBACK, logicObj.executeCommand(EDIT_INDEX_NEGATIVE));
		assertEquals(EDIT_INDEX_INVALID_FEEDBACK, logicObj.executeCommand(EDIT_INDEX_ZERO));
		assertEquals(EDIT_INDEX_STRING_FEEDBACK, logicObj.executeCommand(EDIT_INDEX_STRING));
		assertEquals(EDIT_INVALID_FIELD_FEEDBACK,logicObj.executeCommand(EDIT_INVALID_FIELD));
		
		
		assertEquals(EDIT_TIME_BEFORE_CURRENT_FEEDBACK,logicObj.executeCommand(EDIT_START_BEFORE_CURRENT));
		assertEquals(EDIT_START_AFTER_END_FEEDBACK,logicObj.executeCommand(EDIT_START_AFTER_END));
		assertEquals(EDIT_TIME_BEFORE_CURRENT_FEEDBACK, logicObj.executeCommand(EDIT_END_BEFORE_CURRENT));
		assertEquals(EDIT_START_EQUALS_END_FEEDBACK,logicObj.executeCommand(EDIT_START_EQUALS_END));
		
		assertEquals(EDIT_START_NO_END_FEEDBACK, logicObj.executeCommand(EDIT_START_NO_END));
		assertEquals(EDIT_EVENT_START_AFTER_END_FEEDBACK, logicObj.executeCommand(EDIT_EVENT_START_AFTER_END));
		assertEquals(EDIT_EVENT_START_AFTER_END_FEEDBACK, logicObj.executeCommand(EDIT_EVENT_START_EQUAL_END));
		assertEquals(EDIT_TIME_BEFORE_CURRENT_FEEDBACK, logicObj.executeCommand(EDIT_EVENT_START_BEFORE_CURRENT));
		
		assertEquals(EDIT_END_BEFORE_START_FEEDBACK, logicObj.executeCommand(EDIT_END_BEFORE_START));
		assertEquals(EDIT_END_EQUALS_START_FEEDBACK, logicObj.executeCommand(EDIT_END_EQUALS_START));
		
		assertEquals(EDIT_PRIORITY_INVALID_FEEDBACK,logicObj.executeCommand(EDIT_PRIORITY_INVALID));
		
		assertEquals(EDIT_VALID_FEEDBACK, logicObj.executeCommand(EDIT_VALID));
		assertEquals(EDIT_PRIORITY_HIGH_FEEDBACK,logicObj.executeCommand(EDIT_PRIORITY_HIGH));
		assertEquals(EDIT_PRIORITY_MEDIUM_FEEDBACK,logicObj.executeCommand(EDIT_PRIORITY_MEDIUM));
		assertEquals(EDIT_PRIORITY_LOW_FEEDBACK,logicObj.executeCommand(EDIT_PRIORITY_LOW));
		assertEquals(EDIT_PRIORITY_NONE_FEEDBACK,logicObj.executeCommand(EDIT_PRIORITY_NONE));
	
	}
	
	
	/*
	 * The following test case has 2 partitions, based on whether the search results can be found or not.
	 * It also checks the corner case where the user does not give a keyword after the search command
	 */
	@Test
	public void test5SearchCommand() throws Exception{
		//results not found partition
		assertEquals(SEARCH_NOT_FOUND_FEEDBACK,logicObj.executeCommand(SEARCH_INVALID_KEYWORD));
		logicObj.executeCommand(VIEW_VALID);
		logicObj.executeCommand( "edit 3 end 19:00 1 Jun 2016");
		assertEquals(SEARCH_NOT_FOUND_FEEDBACK, logicObj.executeCommand(SEARCH_WRONG_DATE));
		logicObj.executeCommand(UNDO);
		assertEquals(SEARCH_INVALID_DATE_FEEDBACK, logicObj.executeCommand(SEARCH_INVALID_DATE));
		// results found partition
		assertEquals(SEARCH_VALID_FEEDBACK, logicObj.executeCommand(SEARCH_VALID_KEYWORD));
		assertEquals(SEARCH_EMPTY_STRING_FEEDBACK,logicObj.executeCommand(SEARCH_EMPTY_STRING));
		assertEquals(SEARCH_VALID_DATE_FEEDBACK, logicObj.executeCommand(SEARCH_VALID_DATE));
		
	}
	
	
	/*
	 * The following test case contains 2 equivalent partitions, a valid and an invalid one. Within the invalid
	 * partition there are 3 boundary cases, a negative boundary where the index is below what is expected,
	 * a positive boundary, where the index is larger than expected and the third boundary where a string is given a
	 * the index.
	 */
	@Test
	public void test6DeleteCommand() throws Exception{
		// invalid partition
		logicObj.executeCommand(VIEW_VALID);
		// string as index case
		assertEquals(DELETE_STRING_FEEDBACK, logicObj.executeCommand(DELETE_STRING));
		// larger boundary case
		assertEquals(DELETE_INVALID_INDEX_FEEDBACK, logicObj.executeCommand(DELETE_INVALID_INDEX_LARGER));
		// negative boundary case
		assertEquals(DELETE_INVALID_INDEX_FEEDBACK, logicObj.executeCommand(DELETE_INVALID_INDEX_NEGATIVE));
		assertEquals(DELETE_INVALID_INDEX_FEEDBACK, logicObj.executeCommand(DELETE_INVALID_INDEX_ZERO));
		assertEquals(DELETE_INVALID_MULTIPLE_FEEDBACK, logicObj.executeCommand(DELETE_INVALID_MULTIPLE));
		
		// valid partition
		assertEquals(DELETE_VALID_MULTIPLE_FEEDBACK, logicObj.executeCommand(DELETE_VALID_MULTIPLE));
		logicObj.executeCommand(UNDO);
		logicObj.executeCommand(VIEW_VALID);
		assertEquals(DELETE_VALID_INDEX_FEEDBACK, logicObj.executeCommand(DELETE_VALID_INDEX));

	}

	
	@Test
	/*
	 * The following test case contains 2 equivalent partitions, a valid and an invalid one. Within the invalid
	 * partition there are 3 boundary cases, a negative boundary where the index is below what is expected,
	 * a positive boundary, where the index is larger than expected and the third boundary where a string is given a
	 * the index.
	 */
	public void test7MarkCommand() throws Exception{
		// invalid partition
		logicObj.executeCommand(VIEW_VALID);
		// negative boundary case
		assertEquals(MARK_INVALID_INDEX_FEEDBACK, logicObj.executeCommand(MARK_INVALID_INDEX_NEGATIVE));
		assertEquals(MARK_INVALID_INDEX_FEEDBACK, logicObj.executeCommand(MARK_INVALID_INDEX_ZERO));
		// larger boundary case
		assertEquals(MARK_INVALID_INDEX_FEEDBACK, logicObj.executeCommand(MARK_INVALID_INDEX_LARGER));
		// string as index case
		assertEquals(MARK_INVALID_COMMAND_FEEDBACK, logicObj.executeCommand(MARK_INVALID_INDEX_STRING));
		logicObj.executeCommand(VIEW_VALID);
		assertEquals(MARK_INVALID_INDEX_MULTIPLE_FEEDBACK, logicObj.executeCommand(MARK_INVALID_INDEX_MULTIPLE));
		
		// valid partition
		assertEquals(MARK_VALID_INDEX_MULTIPLE_FEEDBACK, logicObj.executeCommand(MARK_VALID_INDEX_MULTIPLE));
		logicObj.executeCommand(UNDO);
		logicObj.executeCommand(VIEW_VALID);
		assertEquals(MARK_VALID_FEEDBACK, logicObj.executeCommand(MARK_VALID_INDEX));
	}
	
	
	@Test
	public void test8UnmarkCommand() throws Exception{
		logicObj.executeCommand(VIEW_VALID);
		logicObj.executeCommand("done 1");
		logicObj.executeCommand(VIEW_DONE);
		assertEquals(UNMARK_INVALID_INDEX_FEEDBACK, logicObj.executeCommand(UNMARK_INVALID_INDEX_NEGATIVE));
		logicObj.executeCommand(VIEW_DONE);
		assertEquals(UNMARK_INVALID_INDEX_FEEDBACK, logicObj.executeCommand(UNMARK_INVALID_INDEX_ZERO));
		logicObj.executeCommand(VIEW_DONE);
		assertEquals(UNMARK_INVALID_INDEX_FEEDBACK, logicObj.executeCommand(UNMARK_INVALID_INDEX_LARGER));
		logicObj.executeCommand(VIEW_DONE);
		assertEquals(UNMARK_INVALID_COMMAND_FEEDBACK, logicObj.executeCommand(UNMARK_INVALID_INDEX_STRING));
		logicObj.executeCommand(VIEW_DONE);
		assertEquals(UNMARK_INVALID_MULTIPLE_FEEDBACK, logicObj.executeCommand(UNMARK_INVALID_MULTIPLE));
		logicObj.executeCommand(VIEW_DONE);
		assertEquals(UNMARK_VALID_MULTIPLE_FEEDBACK, logicObj.executeCommand(UNMARK_VALID_MULTIPLE));
		logicObj.executeCommand(UNDO);
		logicObj.executeCommand(VIEW_DONE);
		assertEquals(UNMARK_VALID_FEEDBACK, logicObj.executeCommand(UNMARK_VALID));
	}
	
		
	@Test
	public void test91UndoCommand() throws Exception {
		assertEquals(UNDO_FEEDBACK, logicObj.executeCommand(UNDO));
		assertEquals(UNDO_DOUBLE_FEEDBACK,logicObj.executeCommand(UNDO));
		
	}
	
	
	@Test
	public void test9RedoCommand() throws Exception {
		assertEquals(REDO_FEEDBACK, logicObj.executeCommand(REDO));
		assertEquals(REDO_DOUBLE_FEEDBACK,logicObj.executeCommand(REDO));
	}
	
	
	@Test
	public void testHelpCommand() throws Exception{
		assertEquals(HELP_VALID_FEEDBACK, logicObj.executeCommand(HELP_VALID));
		assertEquals(HELP_INVALID_FEEDBACK, logicObj.executeCommand(HELP_INVALID));
		assertEquals(HELP_VALID_UNDO_FEEDBACK, logicObj.executeCommand(HELP_VALID_UNDO));
		assertEquals(HELP_VALID_MARK_FEEDBACK, logicObj.executeCommand(HELP_VALID_MARK));
		assertEquals(HELP_VALID_DELETE_FEEDBACK, logicObj.executeCommand(HELP_VALID_DELETE));
		assertEquals(HELP_VALID_VIEW_FEEDBACK, logicObj.executeCommand(HELP_VALID_VIEW));
		assertEquals(HELP_VALID_EDIT_FEEDBACK, logicObj.executeCommand(HELP_VALID_EDIT));
		assertEquals(HELP_VALID_SEARCH_FEEDBACK, logicObj.executeCommand(HELP_VALID_SEARCH));
		assertEquals(HELP_VALID_LOCATION_FEEDBACK, logicObj.executeCommand(HELP_VALID_LOCATION));
		assertEquals(HELP_VALID_UNMARK_FEEDBACK, logicObj.executeCommand(HELP_VALID_UNMARK));
		assertEquals(HELP_VALID_REDO_FEEDBACK, logicObj.executeCommand(HELP_VALID_REDO));
		assertEquals(HELP_VALID_ADD_FEEDBACK, logicObj.executeCommand(HELP_VALID_ADD));
		assertEquals(HELP_VALID_EXIT_FEEDBACK, logicObj.executeCommand(HELP_VALID_EXIT));
	}
	
	
	@Test
	/*
	 * This test case has 2 partitions, namely valid and invalid. These refer to the validity of the command input
	 * The correct partition encompasses all valid file paths while the incorrect encompasses all invalid file paths
	 */
	public void testSetLocation() throws Exception {
		// valid partition
		assertEquals(LOCATION_FEEDBACK_PASS, logicObj.executeCommand(LOCATION_COMMAND_PASS));

		// invalid partition
		assertEquals(LOCATION_EMPTY_STRING_FEEDBACK, logicObj.executeCommand(LOCATION_EMPTY_STRING));
		assertEquals(LOCATION_FEEDBACK_FAIL, logicObj.executeCommand(LOCATION_COMMAND_FAIL));
	}
	
	
	@AfterClass
	public static void tearDownClass() throws Exception {
		logicObj = new Logic();
		storageObj = new Storage();
		logicObj.executeCommand(COMMAND_SET_LOCATION_DIRECTORY);
		
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		File todoBackup = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO_BACKUP);
		File doneBackup = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE_BACKUP);
		
		storageObj.getFileManager().cleanFile(todo);
		storageObj.getFileManager().cleanFile(done);
		storageObj.getFileManager().cleanFile(todoBackup);
		storageObj.getFileManager().cleanFile(doneBackup);
	}
	
}
```
###### test\SystemTest.java
``` java
	private static final String FEEDBACK_HELP_UNDO = "Undo the most recent command\nCommand: undo\n";;
	private static final String FEEDBACK_HELP_REDO = "Redo the most recent command\nCommand: redo\n";
	private static final String FEEDBACK_HELP_UNMARK = "Unmarks a completed task\n"
			+ "Command: undone <task index>\n\nExample:\nundone 2\n\n\n"
			+ "Note: You may also use the keyword \"unmark\" instead of \"undone\"";
	private static final String FEEDBACK_HELP_MARK = "Marks task as completed\n"
			+ "Command: done <task index>\n\nExample:\ndone 2\n\n\n"
			+ "Note: You may also use the keywords \"mark\", \"complete\" or \"finish\" instead of \"done\"";
	
	private static final String FEEDBACK_HELP_DELETE = "Delete task from list\n"
			+ "Command: delete <task index>\n\nExample:\ndelete 1\n\n\n"
			+ "Note: You may also use the keywords \"-\", \"del\", \"remove\" or \"cancel\" "
			+ "instead of \"delete\"";
	
	private static final String FEEDBACK_HELP_SEARCH = "Search for tasks containing the given keyword or date \n"
			+ "Command: search <keyword> or search<date>\n\nExample:\nsearch meeting\n\n\n"
			+ "Note: You may also use the keyword \"find\" instead of \"search\"";
	
	private static final String FEEDBACK_HELP_EXIT = "Exits SimplyAmazing\nCommand: exit\n\n\nNote: "
			+ "You may also use \"logout\" or \"quit\" instead of \"exit\"";
	
	private static final String FEEDBACK_HELP_ALL = "Key in the following to view specific command formats:\n"
			+ "1. help add\n2. help delete\n3. help edit\n4. help view\n5. help search \n6. help mark\n"
			+ "7. help unmark\n8. help undo\n9. help redo\n10. help location \n11. help exit\n";
	
	private static final String FEEDBACK_HELP_VIEW = "1.Display all tasks\n Command: view\n\n"
			+ "2.Display tasks with deadlines\n"
			+ "Command: view deadlines\n\n3.Display all events\nCommand: view events\n\n"
			+ "4.Display tasks without deadlines\nCommand: view tasks\n\n"
			+ "5.Display completed tasks\nCommand: view done\n\n6.Display overdue tasks\n"
			+ "Command: view overdue\n\n\n"
			+ "Note: You may also use the keywords \"display\", \"show\" or \"list\" instead of \"view\"";
	
	private static final String FEEDBACK_HELP_EDIT =  "Edit content in a task\n"
			+ "Command: edit <task index> <task header> <updated content>\n\n"
			+ "Example:\n1. edit 4 description send marketing report\n\n"
			+ "2. edit 3 start 22:00 26 may 2016, end 22:40 26 may 2016\n\n"
			+ "3. edit 1 priority high\n\n\n"
			+ "Note: You may also use the keywords \"change\" or \"update\" instead of \"edit\"";
	
	private static final String FEEDBACK_HELP_ADD =  "1.Add a task to the list\n"
			+ "Command: add <task description>\n\nExample: add Prepare presentation\n\n\n"
			+ "2.Add an event to the list\ncommand: add <task description> "
			+ "from <start time hh:mm> <start date dd MMM yyyy> to\n<end time hh:mm> <end date dd MMM yyyy>\n\n"
			+ "Example: add Company annual dinner from 19:00 29 Dec 2016 to 22:00 29 dec 2016\n\n\n"
			+ "3.Add a deadline to the list\ncommand: add <task description> "
			+ "by <end time hh:mm> <end date dd MMM yyyy>\n\n"
			+ "Example: add Submit marketing report by 17:00 20 Dec 2016\n\n\n"
			+ "Note: You may use the keyword \"+\" instead of \"add\"";
	
	
	private static final String FEEDBACK_HELP_LOCATION = "Sets the storage location or folder "
			+ "for application data\nCommand: location <path>\n" + CHARACTER_NEW_LINE
			+ "Example:\nlocation C:\\Users\\Jim\\Desktop\\Task Data\n\n\n"
			+ "Note: You may also use the keywords \"path\" or \"address\" instead of \"location\"";

```
###### test\SystemTest.java
``` java
	@Test 
	public void testHelpMethod() throws Exception  {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		logic.executeCommand(COMMAND_SET_LOCATION_DIRECTORY);
		
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		
		assertEquals(true, parser.getHandler(COMMAND_HELP_INVALID).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_INVALID).getCommandType());
		assertEquals(parser.getHandler(COMMAND_HELP_INVALID).getFeedBack(), 
				logic.executeCommand(COMMAND_HELP_INVALID));
		
		assertEquals(true, parser.getHandler(COMMAND_HELP_INTEGER).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_INTEGER).getCommandType());
		assertEquals(parser.getHandler(COMMAND_HELP_INTEGER).getFeedBack(), 
				logic.executeCommand(COMMAND_HELP_INTEGER));
		
		assertEquals(false, parser.getHandler(COMMAND_HELP_ALL).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_ALL).getCommandType());
		assertEquals(FEEDBACK_HELP_ALL, logic.executeCommand(COMMAND_HELP_ALL));
		
		assertEquals(false, parser.getHandler(COMMAND_HELP_ADD).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_ADD).getCommandType());
		assertEquals(FEEDBACK_HELP_ADD, logic.executeCommand(COMMAND_HELP_ADD));
		
		assertEquals(false, parser.getHandler(COMMAND_HELP_VIEW).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_VIEW).getCommandType());
		assertEquals(FEEDBACK_HELP_VIEW, logic.executeCommand(COMMAND_HELP_VIEW));

		assertEquals(false, parser.getHandler(COMMAND_HELP_DELETE).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_DELETE).getCommandType());
		assertEquals(FEEDBACK_HELP_DELETE, logic.executeCommand(COMMAND_HELP_DELETE));
		
		assertEquals(false, parser.getHandler(COMMAND_HELP_EDIT).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_EDIT).getCommandType());
		assertEquals(FEEDBACK_HELP_EDIT, logic.executeCommand(COMMAND_HELP_EDIT));
		
		assertEquals(false, parser.getHandler(COMMAND_HELP_MARK).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_MARK).getCommandType());
		assertEquals(FEEDBACK_HELP_MARK, logic.executeCommand(COMMAND_HELP_MARK));
		
		assertEquals(false, parser.getHandler(COMMAND_HELP_UNDO).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_UNDO).getCommandType());
		assertEquals(FEEDBACK_HELP_UNDO, logic.executeCommand(COMMAND_HELP_UNDO));
		
		assertEquals(false, parser.getHandler(COMMAND_HELP_SEARCH).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_SEARCH).getCommandType());
		assertEquals(FEEDBACK_HELP_SEARCH, logic.executeCommand(COMMAND_HELP_SEARCH));
		
		assertEquals(false, parser.getHandler(COMMAND_HELP_LOCATION).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_LOCATION).getCommandType());
		assertEquals(FEEDBACK_HELP_LOCATION, logic.executeCommand(COMMAND_HELP_LOCATION));
		
		assertEquals(false, parser.getHandler(COMMAND_HELP_EXIT).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_EXIT).getCommandType());
		assertEquals(FEEDBACK_HELP_EXIT, logic.executeCommand(COMMAND_HELP_EXIT));
		
		assertEquals(false, parser.getHandler(COMMAND_HELP_UNMARK).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_UNMARK).getCommandType());
		assertEquals(FEEDBACK_HELP_UNMARK, logic.executeCommand(COMMAND_HELP_UNMARK));
		
		assertEquals(false, parser.getHandler(COMMAND_HELP_REDO).getHasError());
		assertEquals(COMMAND_HELP, parser.getHandler(COMMAND_HELP_REDO).getCommandType());
		assertEquals(FEEDBACK_HELP_REDO, logic.executeCommand(COMMAND_HELP_REDO));
	}
	
	
	@Test
	public void testDeleteMethod() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		logic.executeCommand(COMMAND_SET_LOCATION_DIRECTORY);
		
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		logic.executeCommand(COMMAND_ADD_FLOATING_TASK);
		logic.executeCommand(COMMAND_ADD_DEADLINE);
		logic.executeCommand(COMMAND_ADD_EVENT);
		
		// test for invalid indexes
		assertEquals(false, parser.getHandler(COMMAND_DELETE_NEGATIVE_INDEX).getHasError());
		assertEquals(COMMAND_DELETE, parser.getHandler(COMMAND_DELETE_NEGATIVE_INDEX).getCommandType());
		assertEquals(FEEDBACK_INVALID_INDEX, logic.executeCommand(COMMAND_DELETE_NEGATIVE_INDEX));
		
		assertEquals(false, parser.getHandler(COMMAND_DELETE_ZERO_INDEX).getHasError());
		assertEquals(COMMAND_DELETE, parser.getHandler(COMMAND_DELETE_ZERO_INDEX).getCommandType());
		assertEquals(FEEDBACK_INVALID_INDEX, logic.executeCommand(COMMAND_DELETE_ZERO_INDEX));
		
		assertEquals(false, parser.getHandler(COMMAND_DELETE_LARGER_INDEX).getHasError());
		assertEquals(COMMAND_DELETE, parser.getHandler(COMMAND_DELETE_LARGER_INDEX).getCommandType());
		assertEquals(FEEDBACK_INVALID_INDEX, logic.executeCommand(COMMAND_DELETE_LARGER_INDEX));
		
		assertEquals(true, parser.getHandler(COMMAND_DELETE_STRING).getHasError());
		assertEquals(COMMAND_DELETE, parser.getHandler(COMMAND_DELETE_STRING).getCommandType());
		assertEquals(FEEDBACK_INDEX_IS_STRING, logic.executeCommand(COMMAND_DELETE_STRING));
		
		assertEquals(false, parser.getHandler(COMMAND_DELETE_MULTIPLE_INVALID).getHasError());
		assertEquals(COMMAND_DELETE, parser.getHandler(COMMAND_DELETE_MULTIPLE_INVALID).getCommandType());
		assertEquals(FEEDBACK_MULTIPLE_INVALID, logic.executeCommand(COMMAND_DELETE_MULTIPLE_INVALID));
		
		// valid deletion
		assertEquals(3, storage.getFileManager().getLineCount(todo));
		logic.executeCommand(COMMAND_VIEW_TASKS_EMPTY);
		assertEquals(false, parser.getHandler(COMMAND_DELETE_SINGLE).getHasError());
		assertEquals(COMMAND_DELETE, parser.getHandler(COMMAND_DELETE_SINGLE).getCommandType());
		assertEquals(String.format(FEEDBACK_DELETED, 
				parser.getHandler(COMMAND_ADD_DEADLINE).getTask().toFilteredString()), 
				logic.executeCommand(COMMAND_DELETE_SINGLE));
		
		assertEquals(false, parser.getHandler(COMMAND_DELETE_MULTIPLE).getHasError());
		assertEquals(COMMAND_DELETE, parser.getHandler(COMMAND_DELETE_MULTIPLE).getCommandType());
		assertEquals(FEEDBACK_MULTIPLE_DELETE_VALID, logic.executeCommand(COMMAND_DELETE_MULTIPLE));
	}
	
	@Test
	public void testDoneMethod() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		logic.executeCommand(COMMAND_SET_LOCATION_DIRECTORY);
		
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		logic.executeCommand(COMMAND_ADD_FLOATING_TASK);
		logic.executeCommand(COMMAND_ADD_DEADLINE);
		logic.executeCommand(COMMAND_ADD_EVENT);
		
		// test for invalid indexes
		assertEquals(false, parser.getHandler(COMMAND_MARK_NEGATIVE_INDEX).getHasError());
		assertEquals(COMMAND_MARK_AS_DONE, parser.getHandler(COMMAND_MARK_NEGATIVE_INDEX).getCommandType());
		assertEquals(FEEDBACK_INVALID_INDEX, logic.executeCommand(COMMAND_MARK_NEGATIVE_INDEX));
		
		assertEquals(false, parser.getHandler(COMMAND_MARK_ZERO_INDEX).getHasError());
		assertEquals(COMMAND_MARK_AS_DONE, parser.getHandler(COMMAND_MARK_ZERO_INDEX).getCommandType());
		assertEquals(FEEDBACK_INVALID_INDEX, logic.executeCommand(COMMAND_MARK_ZERO_INDEX));
		
		assertEquals(false, parser.getHandler(COMMAND_MARK_LARGER_INDEX).getHasError());
		assertEquals(COMMAND_MARK_AS_DONE, parser.getHandler(COMMAND_MARK_LARGER_INDEX).getCommandType());
		assertEquals(FEEDBACK_INVALID_INDEX, logic.executeCommand(COMMAND_MARK_LARGER_INDEX));
		
		assertEquals(true, parser.getHandler(COMMAND_MARK_STRING).getHasError());
		assertEquals(COMMAND_MARK_AS_DONE, parser.getHandler(COMMAND_MARK_STRING).getCommandType());
		assertEquals(FEEDBACK_INDEX_IS_STRING, logic.executeCommand(COMMAND_MARK_STRING));
		
		assertEquals(false, parser.getHandler(COMMAND_MARK_MULTIPLE_INVALID).getHasError());
		assertEquals(COMMAND_MARK_AS_DONE, parser.getHandler(COMMAND_MARK_MULTIPLE_INVALID).getCommandType());
		assertEquals(FEEDBACK_MULTIPLE_INVALID, logic.executeCommand(COMMAND_MARK_MULTIPLE_INVALID));
		
		// valid done
		assertEquals(3, storage.getFileManager().getLineCount(todo));
		
		logic.executeCommand(COMMAND_VIEW_TASKS_EMPTY);
		assertEquals(false, parser.getHandler(COMMAND_MARK_SINGLE).getHasError());
		assertEquals(COMMAND_MARK_AS_DONE, parser.getHandler(COMMAND_MARK_SINGLE).getCommandType());
		assertEquals(String.format(FEEDBACK_MARKED_DONE, 
				parser.getHandler(COMMAND_ADD_DEADLINE).getTask().toFilteredString()), 
				logic.executeCommand(COMMAND_MARK_SINGLE));
		
		logic.executeCommand(COMMAND_VIEW_TASKS_EMPTY);
		assertEquals(false, parser.getHandler(COMMAND_MARK_MULTIPLE).getHasError());
		assertEquals(COMMAND_MARK_AS_DONE, parser.getHandler(COMMAND_MARK_MULTIPLE).getCommandType());
		assertEquals(FEEDBACK_MULTIPLE_DONE_VALID, logic.executeCommand(COMMAND_MARK_MULTIPLE));
	}
	
	@Test
	public void testUndoMethod() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		logic.executeCommand(COMMAND_SET_LOCATION_DIRECTORY);
		
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		assertEquals(false, parser.getHandler(COMMAND_UNDO).getHasError());
		assertEquals(COMMAND_UNDO, parser.getHandler(COMMAND_UNDO).getCommandType());
		assertEquals(FEEDBACK_NOTHING_TO_UNDO, logic.executeCommand(COMMAND_UNDO));
		
		logic.executeCommand(COMMAND_ADD_EVENT);
		
		assertEquals(false, parser.getHandler(COMMAND_UNDO).getHasError());
		assertEquals(COMMAND_UNDO, parser.getHandler(COMMAND_UNDO).getCommandType());
		assertEquals(String.format(FEEDBACK_UNDO, COMMAND_ADD_EVENT), logic.executeCommand(COMMAND_UNDO));
	}
	
	@Test
	public void testRedoMethod() throws Exception {
		Logic logic = new Logic();
		Parser parser = new Parser();
		Storage storage = new Storage();
		
		logic.executeCommand(COMMAND_SET_LOCATION_DIRECTORY);
		
		File todo = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_TODO);
		File done = new File(PARAM_SET_LOCATION_DIRECTORY+FILENAME_DONE);
		storage.getFileManager().cleanFile(todo);
		storage.getFileManager().cleanFile(done);
		
		assertEquals(false, parser.getHandler(COMMAND_REDO).getHasError());
		assertEquals(COMMAND_REDO, parser.getHandler(COMMAND_REDO).getCommandType());
		assertEquals(FEEDBACK_NOTHING_TO_REDO, logic.executeCommand(COMMAND_REDO));
		
		logic.executeCommand(COMMAND_ADD_EVENT);
		logic.executeCommand(COMMAND_UNDO);
		
		assertEquals(false, parser.getHandler(COMMAND_REDO).getHasError());
		assertEquals(COMMAND_REDO, parser.getHandler(COMMAND_REDO).getCommandType());
		assertEquals(String.format(FEEDBACK_REDO, COMMAND_ADD_EVENT), logic.executeCommand(COMMAND_REDO));
	}
}
```
